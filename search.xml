<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>写在前面</title>
    <url>/2020/02/21/ca8bfdf3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp;我们一生会遇到很多人，经历很多事，把这些经历，这些人和事，把自己的所想所感记录下来，就是一种财富，这也是我搭建这个站点的初衷。<a id="more"></a><br>&ensp;&ensp;&ensp;&ensp;每一个逐梦的人，在奔跑的道路上都是孤独且艰辛的。这就需要把我们把在这个过程中学习的心得、过程、笔记、代码分享出来，找到和我一同追逐的人，因为一个人长跑很辛苦，有人同行就会好很多，就算没有人同行，我们的读者，我们的观众也会为你鼓掌加油，这些也是让我持续前行的动力。<br>&ensp;&ensp;&ensp;&ensp;你喜欢的人在努力，你却在想怎么说我爱你。</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>attribute_alias_函数属性</title>
    <url>/2023/12/20/4bc75bd4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="attribute-alias-函数属性"><a href="#attribute-alias-函数属性" class="headerlink" title="_attribute_((alias)) 函数属性"></a>_<em>attribute</em>_((alias)) 函数属性</h1><blockquote>
<p>This function attribute enables you to specify multiple aliases for a function.</p>
<p>Aliases must be defined in the same translation unit as the original function.</p>
</blockquote>
<p>此函数属性使您可以为函数指定多个别名。</p>
<p>别名必须在与原始函数相同的翻译单元中定义。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>统计hexo网站的访问地区和IP</title>
    <url>/2023/12/16/d6199888.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://clustrmaps.com/&source=article&objectId=1585686">clustrmaps.com</a> 是美国的一家数据网站，能够汇总公共记录来分析美国城市的社会人口和商业环境。</p>
<p>网址提供了生成访问者地址分布图的代码，可以嵌入到网站或博客中，来显示来自世界各地访问者的实时地图，有助于发展您隐藏的兴趣社区。最重要的是，这个功能是<strong>免费</strong>的。</p>
<a id="more"></a>

<h2 id="注册登录"><a href="#注册登录" class="headerlink" title="注册登录"></a>注册登录</h2><p>登录<a href="https://clustrmaps.com/">网站</a>然后注册一个账户。</p>
<img src="/images/image-20231216143536631.png" alt="image-20231216143536631" style="zoom: 67%;" />

<h2 id="选择自己喜欢的类型"><a href="#选择自己喜欢的类型" class="headerlink" title="选择自己喜欢的类型"></a>选择自己喜欢的类型</h2><p>按照提示的步骤一步一步填写，然后选择自己喜欢的类型，如下：</p>
<img src="/images/image-20231216143947473.png" alt="image-20231216143947473" style="zoom: 67%;" />

<h2 id="获取对应的代码"><a href="#获取对应的代码" class="headerlink" title="获取对应的代码"></a>获取对应的代码</h2><p>根据提示选择适合自己的代码，然后嵌入到自己的主体layout文件中。</p>
<p><img src="/images/image-20231216144244096.png" alt="image-20231216144244096"></p>
<h2 id="将代码插入到对应的位置"><a href="#将代码插入到对应的位置" class="headerlink" title="将代码插入到对应的位置"></a>将代码插入到对应的位置</h2><p>拷贝网站出现的脚本 javascript代码，粘贴到Next主题下某个位置。博主测试过如下两个位置，挑选一个配置即可以。推荐位置二，自定义程度高。 </p>
<ul>
<li><p>位置一：将代码插入到 themes\next\layout_partials\header.swig 的最后。</p>
</li>
<li><p>位置二：将代码插入到 \themes\next\layout_macro\sidebar.swig 文件的图层中。</p>
<img src="/images/image-20231216144900470.png" alt="image-20231216144900470" style="zoom:67%;" />



</li>
</ul>
<h2 id="重新部署网页"><a href="#重新部署网页" class="headerlink" title="重新部署网页"></a>重新部署网页</h2><p>重新部署网站，就可以在首页看到实时访客来源图，如我的网站首页所示。另外，点击地图，可以看到更详细的信息，包括访客的地图、浏览设备以及IP，效果图如左侧栏：</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://clustrmaps.com/">https://clustrmaps.com/</a></p>
<p>[2] <a href="https://cloud.tencent.com/developer/article/1585686">https://cloud.tencent.com/developer/article/1585686</a></p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>多路径配置文件 multipath.conf（译）</title>
    <url>/2023/12/16/5832bb4e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h3><p>multipath.conf - 多路径守护程序配置文件</p>
<h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><blockquote>
<p>multipath-tools v0.9.6 (07/05, 2023)</p>
</blockquote>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>/etc/multipath.conf 是多路径守护程序的配置文件。它用于覆盖multipathd的内置配置表。 任何第一个非空白字符为“#”的行都被视为注释行。 空行将被忽略。</p>
<p>当前使用的 multipathd 配置可以使用 multipath -t 或 multipathd show config 命令显示。</p>
<a id="more"></a>

<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>配置文件包含以下形式的条目：</p>
<pre><code>&lt;章节&gt; &#123;
    &lt;配置项&gt; &lt;值&gt;
    ...
    &lt;章节&gt; &#123;
        &lt;配置项&gt; &lt;值&gt;
        ...
    &#125;
&#125;
</code></pre>
<p>每个部分包含一个或多个属性或小节。 属性或小节的可识别关键字取决于它们出现的部分。</p>
<p>&lt;配置项&gt; 和 &lt;值&gt; 必须位于同一行。 &lt;配置项&gt; 是本手册页中列出的关键字之一。 &lt;值&gt; 可以是一个简单的单词（不包含空格，也不包含字符 ‘“‘、’#’ 和 ‘!’），也可以是用双引号 (“…”) 括起来的一个字符串。在带引号的字符串之外， 以“#”和“!”开头的文本 被视为注释并被忽略直到行尾。在带引号的字符串内，’#’ 和 ‘!’ 是普通字符，并且保留空格。要在双引号字符串中表示双引号字符，请使用两个连续的双引号 (‘“”‘)。因此 ‘2.5” SSD’ 可以写为 “2.5” “ SSD”。</p>
<p>左大括号 (‘{‘) 必须跟在同一行的（子）节名称之后。 标记（子）节结束的右大括号 (‘}’) 必须是该行中唯一的非空白字符。 除了双引号内的空格之外，空格都会被忽略，因此上面示例中显示的缩进对人类读者有帮助，但不是强制性的。</p>
<p><strong>正则表达式注意事项：</strong>multipath.conf 语法允许将许多属性值指定为 POSIX 扩展正则表达式（请参阅 regex(7)）。 这些正则表达式区分大小写且不锚定，因此表达式“bar”匹配“barbie”、“rhabarber”和“wunderbar”，但不匹配“Barbie”。 为了避免不需要的子字符串匹配，可以使用使用特殊字符“^”和“$”的标准正则表达式语法。</p>
<p>可以识别以下章节关键字：</p>
<ul>
<li><p><strong>defaults</strong>    本节定义了属性的默认值，只要在适当的设备或多路径部分中没有给出值，就会使用这些默认值。</p>
</li>
<li><p><strong>blacklist</strong>    本节定义应从多路径拓扑发现中排除哪些设备。</p>
</li>
<li><p><strong>blacklist_exceptions</strong>    本部分定义哪些设备应包含在多路径拓扑发现中，尽管已列在黑名单部分中。</p>
</li>
<li><p><strong>multipaths</strong>    本节定义多路径拓扑。 它们通过全球标识符 (WWID) 进行索引。 有关 WWID 生成的详细信息，请参阅下面的 WWID 生成部分。 本节中设置的属性优先于所有其他属性。</p>
</li>
<li><p><strong>devices</strong>    本节定义设备特定的设置。 设备按供应商、产品和版本进行标识。</p>
</li>
<li><p><strong>overrides</strong>    本节定义应覆盖所有设备的设备特定设置的属性值。</p>
</li>
</ul>
<h4 id="defaults"><a href="#defaults" class="headerlink" title="defaults"></a>defaults</h4><p>defaults 部分可识别以下关键字：</p>
<ul>
<li><p><strong>verbosity</strong>  默认详细程度。 值越高，详细程度越高。 有效级别在 0 到 6 之间。</p>
<p>默认值：2</p>
</li>
<li><p><strong>polling_interval</strong>  两次路径检查之间的时间间隔（以秒为单位）。 对于正常运行的路径，检查之间的间隔将逐渐增加到 max_polling_interval。如果使用 systemd，则该值将被 multipathd.service 定义中的 WatchdogSec 设置覆盖。</p>
<p>默认值：5</p>
</li>
<li><p><strong>max_polling_interval</strong>  两次路径检查之间的最大间隔（以秒为单位）。</p>
<p>默认值：4 *  polling_interval</p>
</li>
<li><p><strong>reassign_maps</strong>  启用设备映射器映射的重新分配。 使用此选项，multipathd 将重新映射现有的设备映射器映射，以始终指向多路径设备，而不是底层块设备。 可能的值为 yes 和 no。</p>
<p>默认值：依赖于特定的系统</p>
</li>
<li><p><strong>multipath_dir</strong>  存储动态共享对象的目录。 在编译时定义，通常为/lib64/multipath/或/lib/multipath/。</p>
</li>
<li><p><strong>path_selector</strong>  使用的默认路径选择器算法； 它们由内核多路径目标（target）提供。 选择器算法共有三种：</p>
<ul>
<li>round-robin 0  循环路径组中的每个路径，向每个路径发送相同数量的 I/O。 行为的某些方面可以通过以下属性进行控制：rr_min_io、rr_min_io_rq 和 rr_weight。</li>
<li>queue-length 0  （自 2.6.31 内核起）根据路径上未完成的 I/O 数量选择下一批 I/O 的路径。</li>
<li>service-time 0  （自 2.6.31 内核起）根据路径的未完成 I/O 量及其相对吞吐量选择下一组 I/O 的路径。</li>
</ul>
<p>默认值：service-time 0</p>
</li>
<li><p><strong>path_grouping_policy</strong>  应用于未指定多路径的默认路径分组策略。 可能的值为：</p>
<ul>
<li>failover 每个优先级组一条路径。</li>
<li>multibus  一个优先级组中的所有路径。</li>
<li>group_by_serial 每个序列号一个优先级组。</li>
<li>group_by_prio  每个优先级值一个优先级组。 优先级由配置文件中指定为全局、每个控制器或每个多路径选项的标注程序确定。</li>
<li>group_by_node_name  每个目标节点名称一个优先级组。 目标节点名称在 /sys/class/fc_transport/target*/node_name 中获取。</li>
</ul>
<p>默认值：failover</p>
</li>
<li><p><strong>uid_attrs</strong>  设置此选项会激活按 WWID 合并 uevent，这可能会提高 uevent 处理效率。 此外，它是配置 udev 属性以用于确定唯一路径标识符 (WWID) 的替代方法。</p>
<p>该选项的值是一个空格分隔的记录列表，如“type:ATTR”，其中 type 与设备节点名称的开头匹配（例如 sd:ATTR 与 sda 匹配），ATTR 是 udev 属性的名称 用于匹配设备。</p>
<p>如果此选项已配置并且与设备的设备节点名称匹配，它将覆盖用于确定此设备的 WWID 的任何其他已配置方法。</p>
<p>默认值为：&lt;未设置&gt;。 要启用 uevent 合并，请将其设置为 到“sd：ID_SERIAL dasd：ID_UID nvme：ID_WWN”。</p>
</li>
<li><p><strong>uid_attribute</strong>  udev 属性提供唯一的路径标识符 (WWID)。 如果 uid_attribute 设置为空字符串，则使用 sysfs 方法而不是使用 udev 来确定 WWID（在生产中不推荐；请参阅下面的 WWID 生成）。</p>
<p>默认值为：ID_SERIAL，适用于 SCSI 设备。</p>
<p>默认值为：ID_UID，适用于 DASD 设备。</p>
<p>默认为：ID_WWN，适用于 NVMe 设备。</p>
</li>
<li><p><strong>getuid_callout</strong>  （由 uid_attribute 取代）用于标注的默认程序和参数，以获取唯一路径标识符。 应使用绝对路径指定。</p>
<p>默认值：未设置。</p>
</li>
<li><p><strong>prio</strong>  路径优先级例程的名称。指定的例程应该返回一个数值，指定该路径的相对优先级。数字越高，优先级越高。“none”是一个有效值。目前实现了以下路径优先级例程：</p>
<ul>
<li><strong>const</strong>  返回常量优先级 1。</li>
<li><strong>sysfs</strong> 使用 sysfs 属性 access_state 和 Preferred_path 生成路径优先级。 该优先级排序器接受可选的 prio_arg exclusive_pref_bit。</li>
<li><strong>emc</strong>  （取决于硬件）为 CLARiiON CX/AX 和 EMC VNX 以及 Unity 系列等 DGC 类阵列生成路径优先级。</li>
<li><strong>alua</strong>  （取决于硬件）根据 SCSI-3 ALUA 设置生成路径优先级。 该优先级排序器接受可选的 prio_arg Exclusive_pref_bit。</li>
<li><strong>ontap</strong>  （取决于硬件）生成 NetApp ONTAP 类和 OEM 阵列作为 IBM NSeries 的路径优先级。</li>
<li><strong>rdac</strong>  （取决于硬件）为 LSI/Engenio/NetApp RDAC 类（如 NetApp SANtricity E/EF 系列）以及来自 IBM DELL SGI STK 和 SUN 的 OEM 阵列生成路径优先级。</li>
<li><strong>hp_sw</strong>  （取决于硬件）专门为具有活动/备用模式的 HP/COMPAQ/DEC HSG80 和 MSA/HSV 阵列生成路径优先级。</li>
<li><strong>hds</strong> （取决于硬件）为除 AMS 2000 之外的 Hitachi AMS 系列阵列生成路径优先级。</li>
<li><strong>random</strong> 生成 1 到 10 之间的随机优先级。</li>
<li><strong>weightedpath</strong>  根据正则表达式和作为参数提供的优先级生成路径优先级。 需要 prio_args 关键字。</li>
<li><strong>path_latency</strong>  基于延迟算法生成路径优先级。 需要 prio_args 关键字。</li>
<li><strong>ana</strong>  （取决于硬件）根据 NVMe ANA 设置生成路径优先级。</li>
<li><strong>datacore</strong>  （取决于硬件）为某些 DataCore 存储阵列生成路径优先级。 需要 prio_args 关键字。</li>
<li><strong>iet</strong>  （仅限 iSCSI）根据 IP 地址生成 iSCSI 目标的路径优先级。 需要 prio_args 关键字。</li>
</ul>
<p>默认值取决于 detector_prio 设置：如果 detector_prio 为 yes（默认），则默认优先级算法为 sysfs（NetAPP E 系列除外，该算法为 alua）。 如果 detector_prio 为 no，则默认优先级算法为 const。</p>
</li>
<li><p><strong>prio_args</strong>  要传递给 prio 函数的参数。 这仅适用于某些优先级器：</p>
<ul>
<li><p>weighted 需要“&lt;hbtl|devname|serial|wwn&gt; &lt;regex1&gt; &lt;prio1&gt; &lt;regex2&gt; &lt;prio2&gt; …”形式的值。</p>
<ul>
<li>hbtl 正则表达式可以是 SCSI H:B:T:L 格式。 例如：1:0:.:. ，*：0：0：。</li>
<li>devname 正则表达式可以是设备名称格式。 例如： sda 、 sd.e。</li>
<li>serial 正则表达式可以是序列号格式。 例如： .*J1FR.*324 。 可以通过 sysfs 或运行 multipathd show paths format “%z” 来查找序列号。 例如：0395J1FR904324。</li>
<li>wwn 正则表达式的形式可以是“host_wwnn:host_wwpn:target_wwnn:target_wwpn”，这些值可以通过 sysfs 或运行 <code>multipathd show paths</code> 格式“%N:%R:%n:%r”来查找。 例如： 0x200100e08ba0aea0:0x210100e08ba0aea0:.*:.* , .*:.*:iqn.2009-10.com.redhat.msp.lab.ask-06:.*。</li>
</ul>
</li>
<li><p>path_latency 需要“io_num=&lt;20&gt; base_num=&lt;10&gt;”形式的值。</p>
<ul>
<li><p>io_num 连续发送到当前路径的读IO数量，用于计算平均路径延迟。 有效值：整数，[2, 200]。</p>
</li>
<li><p>base_num 对数刻度的基数值，用于划分不同的优先级。 有效值：整数，[2, 10]。 最大平均延迟值为 100s，最小平均延迟值为 1us。 例如：如果base_num=10，路径将被分组为路径延迟 &lt;=1us、(1us, 10us]、(10us, 100us]、(100us, 1ms]、(1ms, 10ms]、(10ms, 100ms]、（100ms、1s]、（1s、10s]、（10s、100s]、&gt;100s。</p>
</li>
<li><p>alua 如果设置了 exclusive_pref_bit，则设置了首选路径位的路径将始终位于其自己的路径组中。</p>
</li>
<li><p>sysfs 如果设置了 exclusive_pref_bit，则设置了首选路径位的路径将始终位于其自己的路径组中。</p>
</li>
<li><p>datacore </p>
<ul>
<li>preferredsds （强制）首选的“SDS 名称”。</li>
<li>timeout  （可选）查询的超时时间，以毫秒为单位。</li>
</ul>
</li>
<li><p>iet </p>
<ul>
<li>preferredip=…  （强制）iSCSI 目标的首选 IP 地址（采用点分十进制表示法）。</li>
</ul>
</li>
</ul>
<p>默认值： 未设置</p>
</li>
</ul>
</li>
<li><p><strong>features</strong>  指定要使用的任何设备映射器功能。 语法为 num list，其中 num 是列表中功能的数量（介于 0 到 8 之间）。 功能列表的可能值为：</p>
<ul>
<li><p>queue_if_no_path  （已弃用，由 no_path_retry 取代）如果没有活动路径，则对 I/O 进行队列。 与队列值的 no_path_retry 相同。 如果同时设置了此功能和 no_path_retry，则后一个值优先。 请参阅已知问题。</p>
</li>
<li><p>pg_init_retries  &lt;times&gt;   (自内核2.6.24起) 重试pg_init的次数，必须在1到50之间。</p>
</li>
<li><p>pg_init_delay_msecs   (自内核 2.6.38 起) pg_init 重试之前的毫秒数，必须在 0 到 60000 之间。</p>
</li>
<li><p>queue_mode &lt;mode&gt;  （自内核 4.8 起）选择每个多路径设备的排队模式。 &lt;mode&gt;可以是bio、rq或mq，分别对应基于bio、基于请求和基于块多队列（blk-mq）请求。 默认值取决于内核参数 dm_mod.use_blk_mq。 如果设置了后者则为 mq，否则为 rq。</p>
<p>默认值：未设置</p>
</li>
</ul>
</li>
<li><p><strong>path_checker</strong>  用于确定路径状态的默认方法。 可能的值为：</p>
<ul>
<li><p>readsector0  （已弃用）读取设备的第一个扇区。 此检查器已被弃用，请使用 tur 代替。</p>
</li>
<li><p>tur  向设备发出 TEST UNIT READY 命令。</p>
</li>
<li><p>emc_clariion  （取决于硬件）查询 DGC/EMC 特定 EVPD 页 0xC0 以确定 CLARiiON CX/AX 以及 EMC VNX 和 Unity 阵列系列的路径状态。</p>
</li>
<li><p>hp_sw  （取决于硬件）仅在活动/备用模式下检查 HP/COMPAQ/DEC HSG80 和 MSA/HSV 阵列的路径状态。</p>
</li>
<li><p>rdac  （取决于硬件）检查 LSI/Engenio/NetApp RDAC 类（如 NetApp SANtricity E/EF 系列）以及来自 IBM DELL SGI STK 和 SUN 的 OEM 阵列的路径状态。</p>
</li>
<li><p>directio （已弃用）使用直接 I/O 读取第一个扇区。 此检查器已被弃用，它可能会在高负载下导致虚假路径故障。 请使用 tur 代替。</p>
</li>
<li><p>cciss_tur  （取决于硬件）检查 HP/COMPAQ 智能阵列 (CCISS) 控制器的路径状态。</p>
</li>
<li><p>none  不检查设备，回退使用从 sysfs 检索的值。</p>
<p>默认值：tur</p>
</li>
</ul>
</li>
<li><p><strong>alias_prefix</strong>  user_friend_names 前缀。</p>
<p>默认值：mpath</p>
</li>
<li><p><strong>failback</strong>  告诉 multipathd 如何管理路径组故障恢复。 要选择立即数或值，设备必须支持工作优先级排序器。</p>
<ul>
<li>immediate  立即故障回复到包含活动路径的最高优先级路径组。</li>
<li>manual  不执行自动故障恢复。</li>
<li>followover  用于处理多台计算机访问相同的主动/被动存储设备。 仅当路径组的第一条路径变为活动状态时才执行自动故障恢复。 当另一个节点请求故障转移时，这可以防止集群节点自动故障恢复。</li>
<li>value &gt; 0 延迟故障回复（延迟时间以秒为单位）。</li>
</ul>
<p>默认值：manual</p>
</li>
<li><p><strong>rr_min_io</strong>  在切换到同一路径组中的下一个路径之前路由到路径的 I/O 请求数。 这仅适用于基于块 I/O(BIO) 的多路径，并且仅适用于循环路径选择器。</p>
<p>默认值：1000</p>
</li>
<li><p><strong>rr_min_io_rq</strong>  在切换到同一路径组中的下一个路径之前路由到路径的 I/O 请求数。 这仅适用于基于请求的多路径，并且仅适用于循环路径选择器。</p>
<p>默认值：1</p>
</li>
<li><p><strong>max_fds</strong>  指定 multipath 和 multipathd 可以打开的文件描述符的最大数量。 这相当于 ulimit -n。 max 值会将其设置为 /proc/sys/fs/nr_open 的系统限制。 如果未设置，则从调用进程中获取打开的 fd 的最大数量。 通常为 1024。为了安全起见，如果该数字大于 1024，则应将其设置为最大路径数加 32。</p>
<p>默认值：max</p>
</li>
<li><p><strong>rr_weight</strong>  如果设置为优先级，多路径配置器会将路径权重分配为“path prio * rr_min_io”。 可能的值是priority 或uniform。 仅适用于循环路径选择器。</p>
<p>默认值：uniform</p>
</li>
<li><p><strong>no_path_retry</strong>  指定当所有路径均已关闭时要执行的操作。 可能的值为：</p>
<ul>
<li>value &gt; 0  禁用 I/O 队列之前的重试次数。</li>
<li>fail  立即失败（无 I/O 排队）。</li>
<li>queue  用于永不停止 I/O 队列，类似于queue_if_no_path。 请参阅已知问题。</li>
</ul>
<p>默认值：fail</p>
</li>
<li><p><strong>queue_without_daemon</strong>   如果设置为 no ，当 multipathd 停止时，所有设备的排队将被关闭。 这对于设置 no_path_retry 的设备很有用。 如果在设备的所有路径都关闭时关闭计算机，则可能会在 multipathd 停止后挂起，等待 I/O 从设备返回。 如果不运行 multipathd，则无法恢复对路径的访问，并且无法告知内核停止排队 I/O。 将queue_without_daemon设置为no可以避免这个问题。</p>
<p>默认值：no</p>
</li>
<li><p><strong>checker_timeout</strong>   指定用于发出具有显式超时的 SCSI 命令的路径检查器和优先级排序器的超时（以秒为单位）。</p>
<p>默认值：在/sys/block/sd&lt;x&gt;/device/timeout</p>
</li>
<li><p><strong>flush_on_last_del</strong>  如果设置为 yes ，当设备的最后一个路径被删除时，multipathd 将禁用排队。</p>
<p>默认值：no</p>
</li>
<li><p><strong>user_friendly_names</strong>  如果设置为 yes ，则使用绑定文件 /etc/multipath/bindings 为多路径分配持久且唯一的别名，格式为 mpath&lt;n&gt;。 如果设置为 no，则使用 WWID 作为别名。 无论哪种情况，这都将被多路径部分中的任何特定别名覆盖。</p>
<p>默认值：no</p>
</li>
<li><p><strong>fast_io_fail_tmo</strong>  指定在 FC 远程端口上检测到问题后，SCSI 层在对该远程端口上的设备进行 I/O 失败之前将等待的秒数。 这应该小于 dev_loss_tmo。 将其设置为关闭将禁用超时。</p>
<p>默认值：5</p>
</li>
<li><p><strong>dev_loss_tmo</strong>  指定在 FC 远程端口上检测到问题后将其从系统中删除之前 SCSI 层将等待的秒数。 可以将其设置为“无穷大”，将其设置为最大值 2147483647 秒，即 68 年。 如果通过 no_path_retry 给出重试次数并且总体重试间隔长于指定的 dev_loss_tmo 值，则会自动调整为总体重试间隔 no_path_retry * polling_interval。 如果未设置 fast_io_fail_tmo，Linux 内核会将此值限制为 600。 请参阅已知问题。</p>
<p>默认值：600</p>
</li>
<li><p><strong>bindings_file</strong>  设置 user_Friendly_names 选项时要使用的绑定文件的完整路径名。</p>
<p>默认值：/etc/multipath/bindings</p>
</li>
<li><p><strong>wwids_file</strong>  WWID 文件的完整路径名，多路径使用该文件来跟踪它过去在其上创建的多路径设备的 LUN 的 WWID。</p>
<p>默认值：/etc/multipath/wwids</p>
</li>
<li><p><strong>prkeys_file</strong>  prkeys 文件的完整路径名，当reservation_key 设置为file 时，multipathd 使用该文件来跟踪用于特定WWID 的持久保留密钥。</p>
<p>默认值：/etc/multipath/prkeys</p>
</li>
<li><p><strong>log_checker_err</strong>  如果设置为 Once ，multipathd 将在日志记录级别 2 记录第一个路径检查器错误。任何后续错误都将在级别 3 记录，直到设备恢复为止。 如果设置为 always ，multipathd 始终以日志记录级别 2 记录路径检查器错误。</p>
<p>默认值：always</p>
</li>
<li><p><strong>reservation_key</strong>  这是 mpathpersist 使用的服务操作保留密钥。 必须为所有使用持久保留的多路径设备设置它，并且它必须与 PERSISTENT RESERVE OUT 参数列表的 RESERVATION KEY 字段相同，该字段包含应用程序客户端向设备服务器提供的 8 字节值，用于标识 I_T 关系。 如果在使用 mpathpersist 注册密钥时使用 –param-aptpl 选项，则必须将 :aptpl 附加到保留密钥的末尾。</p>
</li>
<li><p><strong>all_tg_pt</strong>  使用 mpathpersist 注册密钥时设置“所有目标端口”标志。 某些阵列会自动设置和清除主机所有目标端口上的注册密钥，而不是每个主机的每个目标端口。 必须设置 ALL_TG_PT 标志才能在这些阵列上成功使用 mpathpersist。 设置此选项与使用 –param-alltgpt 调用 mpathpersist 相同。</p>
<p>默认值：no</p>
</li>
<li><p><strong>retain_attached_hw_handler</strong>  （对于 &gt;= 4.3 的内核已过时）如果设置为 yes 并且 SCSI 层已将 hardware_handler 附加到设备，则多路径不会强制设备使用 mutipath.conf 指定的 hardware_handler。 如果 SCSI 层未附加硬件处理程序，多路径将继续使用其配置的硬件处理程序。</p>
<p>默认值：no</p>
</li>
<li><p><strong>detect_prio</strong>  如果设置为 yes ，多路径将尝试检测设备是否支持 SCSI-3 ALUA。 如果是这样，如果支持所需的 sysf 属性 access_state 和 Preferred_path，设备将自动使用 sysfs 优先级排序器，如果不支持，则设备将自动使用 alua 优先级排序器。 如果设置为 no ，将照常选择优先级。</p>
<p>默认值：yes</p>
</li>
<li><p><strong>detect_checker</strong>  如果设置为 yes ，multipath将尝试检测设备是否支持 SCSI-3 ALUA。 如果是这样，设备将自动使用 tur 检查器。 如果设置为 no ，将照常选择检查器。</p>
<p>默认值：yes</p>
</li>
<li><p><strong>force_sync</strong>   如果设置为 yes ，multipathd 将仅在同步模式下调用路径检查器。这意味着一次只会运行一个检查器。 这在许多并行运行的多路径检查器导致 CPU 压力很大的情况下非常有用。</p>
<p>默认值：no</p>
</li>
<li><p><strong>strict_timing</strong>  如果设置为 yes ，multipathd 将在一秒后启动新的路径检查器循环，以便每次路径检查将恰好在 polling_interval 秒内发生。在繁忙的系统上，路径检查可能需要超过一秒的时间； 此处，缺失的刻度将在下一轮中计算在内。 如果路径检查花费的时间超过 polling_interval 秒，则会打印警告。</p>
<p>默认值：no</p>
</li>
<li><p><strong>deferred_remove</strong>    如果设置为 yes ，当删除最后一个路径设备时，multipathd 将执行延迟删除而不是常规删除。这意味着，如果多路径设备仍在使用中，则当最后一个用户关闭它时，它将被释放。如果在最后一个用户关闭多路径设备之前将路径添加到多路径设备，则延迟删除将被取消。</p>
<p>默认值：no</p>
</li>
<li><p><strong>partition_delimiter</strong>  如果重命名多路径映射（例如，如果添加或更改映射别名），此参数控制多路径如何选择多路径映射的分区设备名称。 如果此参数设置为“/UNSET/”以外的字符串（甚至是空字符串），则多路径会在设备名称和分区号之间插入该字符串以构造分区设备名称。 否则（即，如果此参数未设置或值为“/UNSET/”），则行为取决于映射名称：如果以数字结尾，则在名称和分区号之间插入“p”； 否则，只需附加分区号。 发行版可以为此选项使用非空默认值； 在这种情况下，用户必须将其设置为“/UNSET/”以获得原始的&lt;unset&gt;行为。 使用 multipath -T 检查当前设置。</p>
<p>默认值：未设置</p>
</li>
<li><p><strong>config_dir</strong>   如果设置为“”以外的任何值，multipath 将按字母顺序搜索此目录中以“.conf”结尾的文件，并从中读取配置信息，就像在 /etc/multipath.conf 中一样。 config_dir 必须是“”或完全限定的目录名。</p>
<p>默认值：/etc/multipath/conf.d/</p>
</li>
<li><p><strong>san_path_err_threshold</strong>  如果设置为大于 0 的值，multipathd 将监视路径并检查路径因错误而失败的次数。如果特定路径上的失败次数大于 san_path_err_threshold，则该路径将在 san_path_err_recovery_time 之前不会恢复 。这些路径故障应该发生在 san_path_err_forget_rate 检查中，如果没有，我们将认为该路径足够好以恢复。请参阅下面的“不稳定路径检测”。</p>
<p>默认值：no</p>
</li>
<li><p><strong>san_path_err_forget_rate</strong>   如果设置为大于 0 的值，multipathd 将在多次检查中检查路径故障是否超过 san_path_err_threshold，即 san_path_err_forget_rate 。 如果是这样，我们将不会恢复路径，直到 san_path_err_recovery_time。请参阅下面的“不稳定路径检测”。</p>
<p>默认值：no</p>
</li>
<li><p><strong>san_path_err_recovery_time</strong>  如果设置为大于 0 的值，multipathd 将确保当路径故障超过 san_path_err_forget_rate 内的 san_path_err_threshold 时，路径将在 san_path_err_recovery_time 持续时间内处于故障状态。一旦 san_path_err_recovery_time 超时，我们将恢复故障路径。 san_path_err_recovery_time 值应以秒为单位。 请参阅下面的“不稳定路径检测”。</p>
<p>默认值：no</p>
</li>
<li><p><strong>marginal_path_double_failed_time</strong>  支持基于统计IO错误（例如间歇性错误）进行路径检查的四个参数之一。 当由于 IO 错误而在 margin_path_double_failed_time 秒内发生两次路径失败事件并且设置了所有其他三个参数时，multipathd 将使该路径失败并将该路径排入一个队列，该队列的成员将被发送几个连续的直接读取异步 IO 10HZ 的固定采样率启动 IO 错误核算过程。 请参阅下面的“不稳定路径检测”。</p>
<p>默认值：no</p>
</li>
<li><p><strong>marginal_path_err_sample_time</strong>  支持基于统计IO错误（例如间歇性错误）进行路径检查的四个参数之一。 如果设置为不小于120的值，则当由于IO错误而在marginal_path_double_failed_time秒内发生两次路径失败事件时，multipathd将使该路径失败，并将该路径加入到一个队列中，该队列的成员会被连续发送几次直接 以 10HZ 的固定采样率读取异步 IO 以启动路径的 IO 统计过程将持续 margin_path_err_sample_time。 如果特定路径上的 IO 错误率大于 margin_path_err_rate_threshold，则该路径将不会在 margin_path_err_recheck_gap_time 秒内恢复，除非只有一个活动路径。 margin_path_err_recheck_gap_time到期后，该路径将被重新排队以进行重新检查。 如果检查结果足够好，该路径将被恢复。 请参阅下面的“不稳定路径检测”。</p>
<p>默认值：no</p>
</li>
<li><p><strong>marginal_path_err_rate_threshold</strong>  错误率阈值以百分比 (1/1000) 表示。 支持基于统计IO错误（例如间歇性错误）进行路径检查的四个参数之一。 请参阅marginal_path_err_sample_time。 如果特定路径上的 IO 错误率大于此参数，则除非只有一个活动路径，否则该路径将在 margin_path_err_recheck_gap_time 秒内不会恢复。 请参阅下面的“不稳定路径检测”。</p>
<p>默认值：no</p>
</li>
<li><p><strong>marginal_path_err_recheck_gap_time</strong>  支持基于统计IO错误（例如间歇性错误）进行路径检查的四个参数之一。 请参阅marginal_path_err_sample_time。 如果该参数设置为正值，则IO错误率大于marginal_path_err_rate_threshold的失败路径将在marginal_path_err_recheck_gap_time秒内保持失败状态。 当 margin_path_err_recheck_gap_time 秒到期时，该路径将被重新排队进行检查。 如果检查结果足够好，则该路径将被恢复，否则将保持失败。 请参阅下面的“不稳定路径检测”。</p>
<p>默认值：no</p>
</li>
<li><p><strong>delay_watch_checks</strong>  此选项已弃用，并映射到 san_path_err_forget_rate。 如果将此值设置为大于 0 的值并且未设置 san_path_err 选项，则 san_path_err_forget_rate 将设置为delay_watch_checks 的值，并且 san_path_err_threshold 将设置为 1。有关详细信息，请参阅 san_path_err_forget_rate 和 san_path_err_threshold 选项以及下面的“不稳定路径检测” 信息。</p>
<p>默认值：no</p>
</li>
<li><p><strong>delay_wait_checks</strong>  此选项已弃用，并映射到 san_path_err_recovery_time。 如果将此值设置为大于 0 的值并且未设置 san_path_err 选项，则 san_path_err_recovery_time 将设置为 delay_wait_checks 乘以 max_polling_interval 的值。 这将提供与之前的delay_wait_checks 大致相同的等待时间。 此外，san_path_err_threshold 将设置为 1。有关详细信息，请参阅 san_path_err_recovery_time 和 san_path_err_threshold 选项以及下面的“不稳定路径检测”。</p>
</li>
<li><p><strong>marginal_pathgroups</strong>  如果设置为 no，delay_*<em>checks、marginal_path</em>* 和 san_path_err_* 选项将阻止边缘或“不稳定”路径恢复，直到它们被监视一段时间。 这可能会导致所有非边缘路径都关闭的情况，并且在 multipathd 检测到此情况并恢复边缘路径之前没有路径可用。 如果在这种情况下多路径设备未配置为对 IO 进行排队，则即使存在可用的边际路径，也可能会导致发生 IO 错误。 但是，如果此选项设置为 yes，当其中一种边缘路径检测方法确定路径是边缘路径时，它将恢复并放置在单独的路径组中，只有在尝试了所有非边缘路径组后才会使用该路径组 第一的。 这可以防止边缘路径仍然可用时发生 IO 错误的可能性。 在路径经过配置的时间监控并被声明为健康后，它将返回到其正常路径组。 有关详细信息，请参阅下面的“不稳定路径检测”。</p>
<p>默认值：no</p>
</li>
<li><p><strong>find_multipaths</strong>  此选项控制 multipath 和 multipathd 是否尝试在它们遇到的非黑名单设备上创建多路径映射。这很重要 a)当在 udev 规则处理期间 multipath -u 遇到设备时（设备被更高层阻止进一步处理 - 例如 LVM - 当且仅当它被认为是有效的多路径设备路径时）。以及 b)当 multipathd 检测到新设备时。以下值是可能的：</p>
<ul>
<li><p>strict  multipath 和 multipathd 都只将此类设备视为多路径设备，这些设备先前已成为多路径映射的一部分，因此列在 wwids_file 中。 用户可以使用 multipathd add map 命令手动设置多路径映射。 手动设置后，地图将被记录在 wwids 文件中，并在将来自动设置。</p>
</li>
<li><p>no  multipath的行为类似struct模式。 multipathd的行为类似greedy模式。</p>
</li>
<li><p>yes  如果满足 strict 条件，或者检测到至少两个具有相同 WWID 的非黑名单路径，multipathd 和 multipath 都会将设备视为多路径设备。</p>
</li>
<li><p>greedy  multipathd 和 multipath 都将每个非黑名单设备视为多路径设备路径。</p>
</li>
<li><p>smart  这与 find_multipaths yes 的不同之处仅在于它处理仅检测到一条路径的新设备的方式。 当此类设备首次出现在 udev 规则中时，它将被视为多路径设备。 multipathd 等待是否出现具有相同 WWID 的其他路径。 如果发生这种情况，它会设置一个多路径映射。 如果直到超时才发生，或者设置地图失败，则会为设备触发一个新的 uevent； 在 udev 规则中第二次遇到时，该设备将被视为非多路径并传递给<br>上层。 注意：如果存在未列入黑名单的单路径设备，这可能会导致设备检测期间出现延迟。</p>
<p>默认值：strict</p>
</li>
</ul>
</li>
<li><p><strong>find_multipaths_timeout</strong>  如果设置了 find_multipaths“smart”（见上文），则在检测到第一个路径后等待其他路径的超时（以秒为单位）。 如果该值为正数，则此超时将用于遇到的所有未知的非黑名单设备。 如果该值为负数（推荐），则它仅适用于在多路径硬件表（内置表或设备部分）中具有条目的“已知”设备； 其他（“未知”）设备将使用仅 1 秒的超时以避免启动延迟。 值 0 表示“使用内置默认值”。 如果 find_multipath 的值不是 smart，则此选项无效。</p>
<p>默认值：-10（已知硬件为 10 秒，未知硬件为 1 秒）</p>
</li>
<li><p><strong>uxsock_timeout</strong>  CLI 接收超时（以毫秒为单位）。 对于较大的系统，在释放 multipathd 锁定并且可以处理 CLI 命令之前，CLI 命令可能会超时。 这将导致 CLI 命令返回“超时接收数据包”等错误。 在这些情况下，建议增加 CLI 超时以避免这些问题。</p>
<p>默认值：1000</p>
</li>
<li><p><strong>retrigger_tries</strong>  设置 multipathd 尝试重新触发 uevent 以获取 WWID 的次数。</p>
<p>默认值：3</p>
</li>
<li><p><strong>retrigger_delay</strong> 设置重新触发之间等待的时间（以秒为单位）。</p>
<p>默认值：10</p>
</li>
<li><p><strong>missing_uev_wait_timeskip_kpartxout</strong>  控制在创建新的多路径设备后，在自动启用设备重新加载之前，multipathd 将等待多少秒以从 udev 接收设备的更改事件。 通常，multipathd 会延迟设备上的重新加载，直到收到来自初始表加载的更改 uevent。</p>
<p>默认值：30</p>
</li>
<li><p><strong>skip_kpartx</strong>  如果设置为 yes ，kpartx 将不会自动在设备上创建分区。</p>
<p>默认值：no</p>
</li>
<li><p><strong>disable_changed_wwids</strong>  此选项已被弃用并被忽略。 如果路径的 WWID 突然更改，multipathd 会像删除然后再次添加一样处理它。</p>
</li>
<li><p><strong>remove_retries</strong>  这设置多路径重试删除正在使用的设备的次数。 在每次尝试之间，多路径将休眠 1 秒。</p>
<p>默认值：0</p>
</li>
<li><p><strong>max_sectors_kb</strong>  将所有路径设备和多路径设备上的 max_sectors_kb 设备参数设置为指定值。</p>
<p>默认值：依赖于对应的设备</p>
</li>
<li><p><strong>ghost_delay</strong>  设置在创建仅包含幽灵路径的设备之后多路径在将其标记为可在 systemd 中使用之前等待的秒数。这使得在多路径运行硬件处理程序将幽灵路径切换到活动路径之前，活动路径有时间出现。将其设置为 0 或打开会使多路径立即将仅具有幽灵路径的设备标记为就绪。</p>
<p>默认值：no</p>
</li>
<li><p><strong>enable_foreign</strong>  启用或禁用外部库（请参阅下面的“外部多路径支持”部分）。 该值是一个正则表达式； 如果外部库的名称（例如“nvme”）与表达式匹配，则加载外部库。 默认情况下，启用所有外部库。</p>
<p>默认值：””</p>
</li>
</ul>
<h4 id="blacklist-and-blacklist-exceptions"><a href="#blacklist-and-blacklist-exceptions" class="headerlink" title="blacklist and blacklist_exceptions"></a>blacklist and blacklist_exceptions</h4><p>blacklist 部分用于从多路径拓扑中排除特定设备。 它最常用于排除多路径工具处理本地磁盘或非磁盘设备（例如存储阵列控制器的 LUN）。</p>
<p>blacklist_exceptions 部分用于恢复黑名单部分的操作。 这允许人们有选择地包括（“白名单”）通常通过黑名单部分排除的设备。 常见用法是使用包罗万象的正则表达式将“所有内容”列入黑名单，并为应由多路径工具处理的那些设备创建特定的 blacklist_exceptions 条目。</p>
<p>两个部分均识别以下关键字。 除非明确说明，否则默认值为空。</p>
<ul>
<li><p><strong>devnode</strong>  与要排除/包含的设备节点匹配的正则表达式。</p>
<p>默认黑名单由正则表达式“^(ram|zram|raw|loop|fd|md|dm-|sr|scd|st|dcssblk)[0-9]”和“^(td|hd|vd)”组成 [a-z]”。 默认情况下，这会导致虚拟设备、非磁盘设备和某些其他设备类型被排除在多路径处理之外。</p>
</li>
<li><p><strong>wwid</strong>  要排除/包含的设备的全球标识符的正则表达式。</p>
</li>
<li><p><strong>device</strong>  设备描述子节。 本小节识别供应商和产品关键字。 两者都是正则表达式。 有关这些关键字的完整说明，请参阅设备部分说明。</p>
</li>
<li><p><strong>property</strong>  udev 属性的正则表达式。 所有具有匹配 udev 属性的设备都将被排除/包含。 property 关键字的处理是特殊的，因为如果设置了属性 blacklist_exception，则设备必须至少有一个列入白名单的 udev 属性； 否则，它们将被视为黑名单，并在日志中显示消息“黑名单，udev 属性丢失”。 例如，将属性 blacklist_exception 设置为 (SCSI_IDENT_|ID_WWN) 将导致包含正常运行的 SCSI 设备和提供 WWN（全球号码）的设备，并排除所有其他设备。 这可以排除大多数非多路径设备。</p>
<p>注意: 与以前的版本相比，multipath-tools 0.8.2 中此选项的行为发生了变化。 按缺失属性列入黑名单仅适用于确实设置了 uid_attribute（例如 ID_SERIAL）指定的属性的设备。 以前，它应用于所有设备，可能会导致设备因临时 I/O 错误情况而被列入黑名单。</p>
</li>
<li><p><strong>protocol</strong>  要排除/包含的设备协议的正则表达式。</p>
<p>多路径识别的协议字符串为 scsi:fcp、scsi:spi、scsi:ssa、scsi:sbp、scsi:srp、scsi:iscsi、scsi:sas、scsi:adt、scsi:ata、scsi:unspec、ccw、cciss 、nvme 和 undef。 可以通过运行 multipathd show paths format “%d %P” 查看路径正在使用的协议。</p>
</li>
</ul>
<p>对于每个设备，这 5 个黑名单标准按照“property、devnode、device、protocol、wwid”的顺序进行评估。 如果设备被任何标准列入黑名单，则它将被排除在 multipathd 处理之外，并且不再评估后面的标准。 对于每个标准，如果设备同时匹配白名单和黑名单，则白名单优先于黑名单。</p>
<p>注意：除了黑名单和白名单之外，其他配置选项（例如 find_multipaths）也会影响给定设备是否由多路径工具处理。</p>
<h4 id="multipath"><a href="#multipath" class="headerlink" title="multipath"></a>multipath</h4><p>多路径部分允许设置多路径映射的属性。 通过多路径部分设置的属性（请参见下面的列表）优先于所有其他配置设置，包括来自覆盖部分的属性。</p>
<p>多路径部分唯一可识别的属性是多路径子部分。 如果存在与给定 WWID 匹配的多个多路径子部分，则这些部分的内容将被合并，并且后面条目中的设置优先。</p>
<p>多路径子节识别以下属性：</p>
<ul>
<li><strong>wwid</strong>  （强制）全球标识符。 检测到的多路径映射与此属性进行匹配。 请注意，与黑名单部分中的 wwid 属性不同，这不是正则表达式或子字符串； WWID 必须在多路径部分内完全匹配。</li>
<li><strong>alias</strong>  多路径映射的符号名称。 这优先于绑定文件中相同 WWID 的条目。</li>
</ul>
<p>以下属性是可选的； 如果未设置，默认值将从overrides、devices或defaults部分获取：</p>
<ul>
<li>path_grouping_policy</li>
<li>path_selector</li>
<li>prio</li>
<li>prio_args</li>
<li>failback</li>
<li>rr_weight</li>
<li>no_path_retry</li>
<li>rr_min_io</li>
<li>rr_min_io_rq</li>
<li>flush_on_last_del</li>
<li>features</li>
<li>reservation_key</li>
<li>user_friendly_names</li>
<li>deferred_remove</li>
<li>san_path_err_threshold</li>
<li>san_path_err_forget_rate</li>
<li>san_path_err_recovery_time</li>
<li>marginal_path_err_sample_time</li>
<li>marginal_path_err_rate_threshold</li>
<li>marginal_path_err_recheck_gap_time</li>
<li>marginal_path_double_failed_time</li>
<li>delay_watch_checks</li>
<li>delay_wait_checks</li>
<li>skip_kpartx</li>
<li>max_sectors_kb</li>
<li>ghost_delay</li>
</ul>
<h4 id="devices"><a href="#devices" class="headerlink" title="devices"></a>devices</h4><p>multipath-tools 有一个内置设备表，其中包含 100 多个已知的支持多路径的存储设备的合理默认值。 设备部分可用于覆盖这些设置。 如果给定设备有多个匹配项，则所有匹配条目的属性都将应用于该设备。 如果在多个匹配的设备小节中指定了某个属性，则后面的条目优先。 因此，config_dir 下的文件中的条目（按相反的字母顺序）具有最高优先级，其次是 multipath.conf 中的条目； 内置硬件表的优先级最低。 在配置文件中，后面的条目比前面的条目具有更高的优先级。</p>
<p>devices 部分唯一可识别的属性是 device 子部分。 系统中检测到的设备使用供应商、产品和修订字段与设备条目进行匹配，这些字段都是 POSIX 扩展正则表达式（请参阅 regex(7)）。</p>
<p>multipath 或multipathd检测系统中设备的供应商（vendor）、产品（product）和版本（revision）字段取决于设备类型。 对于 SCSI 设备，它们对应于 SCSI INQUIRY 页的相应字段。 一般来说，命令“multipathd show paths format “%d %s””可用于查看系统中所有设备的检测到的属性。</p>
<p>设备部分识别以下属性：</p>
<ul>
<li><p><strong>vendor</strong>  （强制）匹配供应商名称的正则表达式。</p>
</li>
<li><p><strong>product</strong>  （强制）匹配产品名称的正则表达式。</p>
</li>
<li><p><strong>revision</strong>   匹配产品版本的正则表达式。 如果未指定，则任何修订版都会匹配。</p>
</li>
<li><p><strong>product_blacklist</strong>  给定供应商与此字符串匹配的产品将被列入黑名单。 这相当于黑名单部分中的设备条目，其供应商属性设置为该条目的供应商，产品属性设置为product_blacklist 的值。</p>
</li>
<li><p><strong>alias_prefix</strong>  用于此设备类型的 user_Friendly_names 前缀，而不是默认的“mpath”。</p>
</li>
<li><p><strong>vpd_vendor</strong>  供应商特定的 vpd 页面信息，使用 vpd 页面缩写。 vpd 页面缩写可以通过运行 sg_vpd -e 找到。 multipathd 将使用此信息来收集设备特定信息，这些信息可以通过 multipathd show paths format 和 multipathd show paths format 命令的 %g 通配符显示。 目前仅支持 hp3par vpd 页面。</p>
</li>
<li><p><strong>hardware_handler</strong>  用于此设备类型的硬件处理程序。 实现了以下硬件处理程序：</p>
<ul>
<li>1 emc  （取决于硬件）DGC 类阵列（如 CLARiiON CX/AX 和 EMC VNX 以及 Unity 系列）的硬件处理程序。</li>
<li>1 rdac （依赖于硬件）LSI/Engenio/NetApp RDAC 类（如 NetApp SANtricity E/EF 系列）以及来自 IBM DELL SGI STK 和 SUN 的 OEM 阵列的硬件处理程序。</li>
<li>1 hp_sw  （取决于硬件）专用于具有活动/备用模式的 HP/COMPAQ/DEC HSG80 和 MSA/HSV 阵列的硬件处理程序。</li>
<li>1 alua （取决于硬件）SCSI-3 ALUA 兼容阵列的硬件处理程序。</li>
<li>1 ana  （取决于硬件）NVMe ANA 兼容阵列的硬件处理程序。</li>
</ul>
<p>重要提示：Linux 内核 4.3 及更高版本会自动将设备处理程序附加到已知设备（包括所有支持 SCSI-3 ALUA 的设备），并且之后不允许更改处理程序。 在这些内核上为此类设备设置 hardware_handler 没有任何效果。</p>
</li>
</ul>
<p>以下属性是可选的； 如果未设置，则默认值将从defaults部分获取：</p>
<ul>
<li>path_grouping_policy</li>
<li>uid_attribute</li>
<li>getuid_callout</li>
<li>path_selector</li>
<li>path_checker</li>
<li>prio</li>
<li>prio_args</li>
<li>features</li>
<li>failback</li>
<li>rr_weight</li>
<li>no_path_retry</li>
<li>rr_min_io</li>
<li>rr_min_io_rq</li>
<li>fast_io_fail_tmo</li>
<li>dev_loss_tmo</li>
<li>flush_on_last_del</li>
<li>user_friendly_names</li>
<li>retain_attached_hw_handler</li>
<li>detect_prio</li>
<li>detect_checker</li>
<li>deferred_remove</li>
<li>san_path_err_threshold</li>
<li>san_path_err_forget_rate</li>
<li>san_path_err_recovery_time</li>
<li>marginal_path_err_sample_time</li>
<li>marginal_path_err_rate_threshold</li>
<li>marginal_path_err_recheck_gap_time</li>
<li>marginal_path_double_failed_time</li>
<li>delay_watch_checks</li>
<li>delay_wait_checks</li>
<li>skip_kpartx</li>
<li>max_sectors_kb</li>
<li>ghost_delay</li>
<li>all_tg_pt</li>
</ul>
<h4 id="overrides"><a href="#overrides" class="headerlink" title="overrides"></a>overrides</h4><p>overrides 部分识别以下可选属性； 如果未设置，则从设备或defaults部分获取值：</p>
<ul>
<li>path_grouping_policy</li>
<li>uid_attribute</li>
<li>getuid_callout</li>
<li>path_selector</li>
<li>path_checker</li>
<li>alias_prefix</li>
<li>features</li>
<li>prio</li>
<li>prio_args</li>
<li>failback</li>
<li>rr_weight</li>
<li>no_path_retry</li>
<li>rr_min_io</li>
<li>rr_min_io_rq</li>
<li>flush_on_last_del</li>
<li>fast_io_fail_tmo</li>
<li>dev_loss_tmo</li>
<li>user_friendly_names</li>
<li>retain_attached_hw_handler</li>
<li>detect_prio</li>
<li>detect_checker</li>
<li>deferred_remove</li>
<li>san_path_err_threshold</li>
<li>san_path_err_forget_rate</li>
<li>san_path_err_recovery_time</li>
<li>marginal_path_err_sample_time</li>
<li>marginal_path_err_rate_threshold</li>
<li>marginal_path_err_recheck_gap_time</li>
<li>marginal_path_double_failed_time</li>
<li>delay_watch_checks</li>
<li>delay_wait_checks</li>
<li>skip_kpartx</li>
<li>max_sectors_kb</li>
<li>ghost_delay</li>
<li>all_tg_pt</li>
</ul>
<h4 id="WWID-生成"><a href="#WWID-生成" class="headerlink" title="WWID 生成"></a>WWID 生成</h4><p>多路径使用全球标识 (WWID) 来确定哪些路径属于同一设备。 假设呈现相同 WWID 的每条路径都指向同一设备。</p>
<p>WWID 由四种方法生成（按优先顺序排列）：</p>
<ul>
<li><strong>uid_attrs</strong>   WWID是通过匹配设备节点名称从udev属性派生而来的； 参见上面的 uid_attrs。</li>
<li><strong>getuid_callout</strong>  使用指定的外部程序； 参见上面的 getuid_callout。 使用此方法时应注意； 外部程序需要从磁盘加载来执行，这可能会导致全路径下场景中的死锁情况。</li>
<li><strong>uid_attribute</strong>  使用指定的udev属性的值； 参见上面的 uid_attribute。 此方法优于 getuid_callout，因为 multipath 不需要在此处调用任何外部程序。 但是，在某些情况下，udev 可能无法生成所请求的变量。</li>
<li><strong>sysfs</strong>  尝试从 sysfs 属性确定 WWID。 对于 SCSI 设备，这意味着读取重要产品数据 (VPD) 页“设备标识”(0x83)。</li>
</ul>
<p>默认设置（使用从内置硬件表配置的 udev 和 uid_attribute）在大多数情况下应该可以正常工作。 想要启用uevent合并的用户必须设置uid_attrs。</p>
<h4 id="不稳定路径检测"><a href="#不稳定路径检测" class="headerlink" title="不稳定路径检测"></a>不稳定路径检测</h4><p>SAN 设置中的一个常见问题是出现间歇性错误：路径无法访问，然后短时间内再次可达，再次消失，等等。 这种情况通常发生在不稳定的互连上。 在如此频繁、不可靠的事件上不必要地切换路径组是不合需要的。 multipathd 支持三种不同的方法来检测和处理这种情况。 所有方法共享相同的基本操作模式：如果发现路径“不稳定”或“翻转”，并且看起来处于健康状态，则不会立即恢复（重新使用）。 相反，它被置于“延迟”状态并观察一段时间，只有在健康状态看起来稳定时才恢复。 如果设置了 margin_pathgroups 选项，路径将立即恢复，但会放置在边缘路径的特殊路径组中。 在尝试完所有其他路径组之前，不会使用边缘路径组。 当路径正常恢复时，它将返回到其正常路径组。 确定“不稳定”状况的逻辑以及何时恢复的逻辑在三种方法之间是不同的。</p>
<ul>
<li><p>“<strong>delay_checks</strong>” 失败跟踪。此方法已弃用并映射到“san_path_err”方法。 有关更多信息，请参阅上面的delay_watch_checks 和delay_wait_checks 选项。</p>
</li>
<li><p>“<strong>marginal_path</strong>” 失败跟踪。如果在故障发生后的 margin_path_double_failed_time 秒内发生第二次故障事件（好-&gt;坏转换），则会对受影响的路径启动高频监控：以每秒 10 个的速率发送 I/O。 这是在 margin_path_err_sample_time 秒内完成的。 在此期间，路径不会恢复。 如果在监控期间错误率保持低于marginal_path_err_rate_threshold，则路径将恢复。 否则，将保持失败状态marginal_path_err_recheck_gap_time，之后再次进行监控。 对于此方法，时间间隔以秒为单位测量。</p>
</li>
<li><p>“<strong>san_path_err</strong>” 失败跟踪。multipathd 对每条路径的路径故障进行计数。 一旦失败次数超过 san_path_err_threshold 给定的值，路径在 san_path_err_recovery_time 秒内不会恢复。 在计算失败次数时，multipathd 每“san_path_err_forget_rate”一次就会“忘记”一次过去的失败； 因此，如果在遗忘率间隔内错误发生的频率不高于一次，则失败计数不会增加，并且永远不会达到阈值。 时间间隔是 multipathd 路径检查之间的时间，它是可变的，由 polling_interval 和 max_polling_interval 参数控制。</p>
<p>此方法已被弃用，取而代之的是“marginal_path”故障跟踪方法，并且仅提供向后兼容性。</p>
</li>
</ul>
<p>有关详细信息，请参阅上面各个选项的文档。 强烈建议不要对任何给定的多路径映射使用多个这些方法，因为这两种并发方法可能会以不可预测的方式交互。 如果“marginal_path”方法处于活动状态，则“san_path_err”参数将隐式设置为 0。</p>
<h4 id="外部多路径支持"><a href="#外部多路径支持" class="headerlink" title="外部多路径支持"></a>外部多路径支持</h4><p>multipath 和 multipathd 可以加载 “外部” 库，以添加对 Linux 设备映射器之外的其他多路径技术的支持。 目前，此支持仅限于打印检测到的有关多路径设置的信息。 在拓扑输出中，外部映射的名称以方括号中的外部库名称为前缀，如本例中所示：</p>
<pre><code>   # multipath -ll
   uuid.fedcba98-3579-4567-8765-123456789abc [nvme]:nvme4n9 NVMe,Some NVMe controller,FFFFFFFF
   size=167772160 features=&#39;n/a&#39; hwhandler=&#39;ANA&#39; wp=rw
   |-+- policy=&#39;n/a&#39; prio=50 status=optimized
   | `- 4:38:1    nvme4c38n1 0:0     n/a   optimized    live
   `-+- policy=&#39;n/a&#39; prio=50 status=optimized
     `- 4:39:1    nvme4c39n1 0:0     n/a   optimized    live
</code></pre>
<p>“nvme” 外部库为内核中的 NVMe 本机多路径提供支持。 它是标准多路径包的一部分。</p>
<h4 id="已知的问题"><a href="#已知的问题" class="headerlink" title="已知的问题"></a>已知的问题</h4><p>在 LUN 的所有路径都脱机的情况下，使用queue_if_no_path 选项可能会导致 D 状态进程挂起且不可终止。 建议改用 no_path_retry 选项。</p>
<p>如果 dev_loss_tmo 设置导致设备在 I/O 仍在排队时被删除，则使用queue_if_no_path 或 no_path_retry 可能会导致死锁。 多路径守护进程将相应地更新 dev_loss_tmo 设置以避免这种死锁。 因此，如果指定了两个值，则优先顺序为 no_path_retry、queue_if_no_path、dev_loss_tmo。</p>
<h4 id="也可以看看"><a href="#也可以看看" class="headerlink" title="也可以看看"></a>也可以看看</h4><p>udev(8), dmsetup(8), multipath(8), multipathd(8).</p>
<h4 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h4><p>multipath-tools 由 Christophe Varoqui、<a href="mailto:&#99;&#x68;&#114;&#x69;&#115;&#116;&#111;&#112;&#x68;&#101;&#x2e;&#x76;&#97;&#x72;&#111;&#x71;&#117;&#x69;&#64;&#x6f;&#112;&#x65;&#x6e;&#x73;&#118;&#x63;&#46;&#99;&#x6f;&#x6d;">&#99;&#x68;&#114;&#x69;&#115;&#116;&#111;&#112;&#x68;&#101;&#x2e;&#x76;&#97;&#x72;&#111;&#x71;&#117;&#x69;&#64;&#x6f;&#112;&#x65;&#x6e;&#x73;&#118;&#x63;&#46;&#99;&#x6f;&#x6d;</a> 等人开发。</p>
<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p>[1] <a href="https://github.com/opensvc/multipath-tools">https://github.com/opensvc/multipath-tools</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>多路径</tag>
      </tags>
  </entry>
  <entry>
    <title>ALUA多路径技术</title>
    <url>/2023/12/08/d1909d72.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>存储阵列系统提供了各种的配置项和功能特性，取决于他的类别和设计。根据阵列如何处理提供给主机的设备的I/O,他们可以分类如下：</p>
<ul>
<li><p>Active/Active。I/O(输入/输出)可以通过任意的存储处理器（Storage Processor）和端口发送到逻辑单元号（LUNs）。这些阵列中，大多数都是具有比较大的缓存，并且I/O是在LUN的缓冲区完成的，随后异步的刷新写入物理磁盘中。</p>
</li>
<li><p>Active/Passive。I/O只能发送到存储处理器拥有”LUN”的任意端口（也称主动SP）。如果尝试通过”非所有者”处理器（也称为被动SP）上的端口在LUN上执行IO操作，则会向启动器（initiator）返回一个错误，简单的表示 “禁止进入” 或者 “不，你不能这样做”。</p>
</li>
<li><p>Pseudo-active/Active(also known as asymmertric active-active)。IO可以发送到任意存储处理器（SP）上的端口。但是，由于I/O从每个存储处理器（SP）到达设备的路径，发送到所有者存储处理器（SP）的IO比发送到非所有者控制器的IO要快。通过非所有者SP需要通过某些后端的通道发送IO，而通过所有者SP则有一条直接的路径。</p>
</li>
</ul>
<p>后两者类型的阵列称为 “非对称逻辑单元访问（ALUA）” 的SCSI-3规范。它允许通过两个SP访问阵列设备，但是向启动器（initiators）清楚地表示哪些目标（targets）位于所有者SP上，哪些目标（targets）位于非所有者SP上。</p>
<a id="more"></a>

<h2 id="ALUA定义"><a href="#ALUA定义" class="headerlink" title="ALUA定义"></a>ALUA定义</h2><p>标准的官方释义如下：</p>
<blockquote>
<p>Asymmetric logical unit access occurs when the access characteristics of one port may differ from those of another port.</p>
</blockquote>
<p>翻译过来就是：当一个端口的访问特征可能与另一个端口的访问特征不同时，就会发生非对称逻辑单元（ALUA）访问。</p>
<p>简单来说，ALUA指定了一种存储设备类型，该设备能够在两个不同的存储处理器（SP）上以不均匀的方式给定LUN提供服务。</p>
<p>正如上面所提到的那样，使用ALUA时，可以将给定的LUN的I/O发送到存储阵列中任何存储处理器（SP）的可用端口上。这样就更加接近于非对称 active/active（主动/主动）阵列的行为，而不是active/passive(主动/被动)的行为。允许LUN进行I/O，但是所有者存储处理器（SP）的性能会优于非存储处理器（SP）所有。为了使（initiators）启动器能够确定哪些目标（targets），将提供最佳的IO，每个存储处理器（SP）上的端口都分组到目标端口组中。每个目标端口组都有一个独特的”状态”（非对称访问状态[AAS]），表示一个存储处理器（SP）上的端口与另一个控制器上的端口相比的优化。（列如，主动优化和主动-非优化）。</p>
<h2 id="ALUA目标端口组"><a href="#ALUA目标端口组" class="headerlink" title="ALUA目标端口组"></a>ALUA目标端口组</h2><p>根据SPC-3，目标端口组（TPG）描述如下：</p>
<blockquote>
<p>A target port group is defined as a set of target ports that are in the same target port asymmetric access state at all times. A target port group asymmetric access state is defined as the target port asymmetric access state common to the set of target ports in a target port group. The grouping of target ports is vendor specific.</p>
</blockquote>
<p>翻译过来就是：目标端口组定义为始终处于同一目标端口非对称访问状态的一组目标端口。目标端口组非对称访问状态定义为目标端口组中目标端口集共有的目标端口非对称访问状态。目标端口的分组是特定于供应商的。</p>
<p>这仅仅意味着，在具有两个SP（SPA和SPB）的给定的存储阵列中，SPA上的端口组合在一起，而SPB上的端口则分组到一个单独的组中。假设此存储阵列向E主机中的启动器提供两个LUN—-LUN1和LUN2，并且LUN1归属于SPA，LUN2归属于SPB。对于主机，最好通过SPA访问LUN1，并且通过SPB访问LUN2。相对于LUN1，SPA上的端口位于主动优化（AO）TPG中，SPB上的端口位于主动非优化（ANO）TPG中。在此示例中，LUN2的情况正好相反，其中SPA上的TPG是ANO，SPB上的TPG是AO。</p>
<p>下图显示了非对称active/active阵列上的示例。ID=1的TPG（SPA上的左侧矩形）是AO（由连接到LUN1的实线表示）。同样的TPG是LUN2的ANO（由连接TPG1和LUN2的中断线路表示）。</p>
<p>TPG的图示。</p>
<img src="/images/image-20231212002417949.png" alt="image-20231212002417949" style="zoom:67%;" />

<p>对于ID=2的TPG，情况正好相反。也就是说，LUN2是ANO，LUN1是ANO。</p>
<p>在某些支持ALUA的主动/被动（active/passive）阵列上，你可能会在非所有者SP上看到端口组具备有”备用”AAS，而不是”ANO”。</p>
<h2 id="非对称访问状态"><a href="#非对称访问状态" class="headerlink" title="非对称访问状态"></a>非对称访问状态</h2><p>对于给定的LUN，ALUA TPG中的端口可以始终处于同一AAS中。TPG的AAS将报告给发起方，以相应REPORT TPGS命令。TPG描述符在该想你的字节1中报告。</p>
<p>可能的状态如下：</p>
<ul>
<li><p><strong>主动优化</strong>（Active-optimized ，AO）。端口位于非所有者SP上，与AO AAS相比，LUN的I/O不太理想。</p>
</li>
<li><p><strong>正在转换</strong>（Transitioning）。TPG AAS 正在从一种状态切换到另一种状态。例如，如果 AO TPG 的 SP 正在重新启动或脱机，或者如果 SAN（存储区域网络）管理员手动转移 LUN 所有权（在 EMC CLARiiON 上，这称为<em>主动变更</em>），则备用 SP 上 TPG 的 AAS 将更改为 AO。虽然这一过程正在进行中，但 TPG AAS 正在过渡。</p>
<p>当 TPG 处于此状态时，接收来自启动器的请求将返回 BUSY 或 CHECK CONDITION，并带有检测键 NOT  READY 和 ASC（附加检测代码）LOGICAL UNIT NOT ACCESSIBLE 或非对称访问状态转换（ASYMMETRIC ACCESS STATE TRANSITION）。</p>
</li>
<li><p>备用（Standby）。此状态类似于非 ALUA 配置和某些支持 ALUA 的阵列中的被动 SP。它返回一个带有感应键 <code>NOT READY</code> 的 <code>CHECK CONDITION</code>.</p>
<p>当 TPG 位于此 AAS 中时，它支持在 AO AAS 中时接受的命令子集：</p>
</li>
<li><p>不可用（Unavaliable）。当 TPG 对 LUN 的访问由于硬件错误或其他 SCSI 设备限制而受到限制时，通常会出现此 AAS。处于此状态的 TPG 无法转换为 AO 或 ANO，直到错误消退。</p>
</li>
</ul>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://www.pearsonitcertification.com/articles/article.aspx?p=2819032">https://www.pearsonitcertification.com/articles/article.aspx?p=2819032</a></p>
<p>[2] <a href="https://www.360blogs.top/alua/">https://www.360blogs.top/alua/</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>多路径</tag>
      </tags>
  </entry>
  <entry>
    <title>atomic原子操作</title>
    <url>/2023/11/20/c4860674.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在没有实现无锁化编程之前，我们对共享数据（变量）的操作需要用到锁。多线程并发访问数据的时候，锁的维护非常的麻烦，并且锁的申请和释放、多线程竞争锁的过程中会存在资源的消耗。同时，锁的引入也会引起线程阻塞、锁竞争、死锁等问题。</p>
<p>CAS (compare and swap, CAS) 比较并交换，是原子操作的一种，可用于在多线程编程环境中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及终端的不可预知性产生的数据不一致的问题。该操作通过将内存中的值与指定的数据进行交换，当数值一样时将内存中的数据替换为新的值。</p>
<p>一个CAS操作等价于以下C代码的原子实现如下:</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cas</span><span class="params">(<span class="keyword">long</span> *addr, <span class="keyword">long</span> old, <span class="keyword">long</span> <span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Executes atomically. */</span></span><br><span class="line">    <span class="keyword">if</span>( *addr != old ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *addr = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用上，通常会记录下某块内存中的旧值，通过对旧值进行一系列的操作后得到新值，然后通过CAS操作将新值与旧值进行交换，如果这块内存的值在这期间内没有被修改过，则旧值会与内存中的数据相同，这是CAS操作将会成功执行使得内存中的数据变为新值。如果内存中的值在这期间内被修改过，则一般来说旧值会与内存中的数据不同，这时，CAS操作将会失败，新值将不会被写入内存中。</p>
<p>GCC 编译器内置了一些内建的原子操作函数，我们不需要使用其他的库就可以简单的进行一些原子操作。</p>
<p>英特尔文档中给出的定义只允许使用 int、long、long long 以及它们的无符号对应类型。GCC 允许使用任何长度为 1、2、4 或 8 字节的积分标量或指针类型。</p>
<blockquote>
<p>Note: 需要注意的是，随着C++11标准的引入，C++提供了更加高级和可移植的原子操作接口，如<code>std::atomic</code>。在新的代码中，建议使用这些标准库提供的原子操作接口，而不是依赖于特定编译器的内置函数。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这些内置函数执行名称建议的操作，并返回先前在内存中的值。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将指针 ptr 指向的变量的值加上 value，并返回原来的值。</span></span><br><span class="line">type __sync_fetch_and_add (type *ptr, type value, ...)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将指针 ptr 指向的变量的值减去 value，并返回原来的值。</span></span><br><span class="line">type __sync_fetch_and_sub (type *ptr, type value, ...)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将指针 ptr 指向的变量的值按位或上 value，并返回原来的值。</span></span><br><span class="line">type __sync_fetch_and_or (type *ptr, type value, ...)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将指针 ptr 指向的变量的值相与上 value，并返回原来的值。</span></span><br><span class="line">type __sync_fetch_and_and (type *ptr, type value, ...)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将指针 ptr 指向的变量的值异或上 value，并返回原来的值。</span></span><br><span class="line">type __sync_fetch_and_xor (type *ptr, type value, ...)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将指针 ptr 指向的变量的值取反后与 value值相与，并返回原来的值。</span></span><br><span class="line">type __sync_fetch_and_nand (type *ptr, type value, ...)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这些内置函数执行名称建议的操作，并返回新值。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将指针 ptr 指向的变量的值加上 value 的值，并返回新的值。</span></span><br><span class="line">type __sync_add_and_fetch (type *ptr, type value, ...)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将指针 ptr 指向的变量的值减去 value 的值，并返回新的值。</span></span><br><span class="line">type __sync_sub_and_fetch (type *ptr, type value, ...)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将指针 ptr 指向的变量的值与 value 的值相或，并返回新的值。</span></span><br><span class="line">type __sync_or_and_fetch (type *ptr, type value, ...)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将指针 ptr 指向的变量的值与 value 的值相与，并返回新的值。</span></span><br><span class="line">type __sync_and_and_fetch (type *ptr, type value, ...)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将指针 ptr 指向的变量的值与 value 的值相异或，并返回新的值。</span></span><br><span class="line">type __sync_xor_and_fetch (type *ptr, type value, ...)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将指针 ptr 指向的变量的值取反并与 value 的值相与，并返回新的值。</span></span><br><span class="line">type __sync_nand_and_fetch (type *ptr, type value, ...)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这些内置函数执行原子比较和交换。</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 将指针 *ptr 指向的变量的值等于 oldval 值，则将newval写入*ptr，并且返回<span class="literal">true</span>。</span></span><br><span class="line">bool __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将指针 *ptr 指向的变量的值等于 oldval 值，则将newval写入*ptr，并且返回 *ptr 之前的值。</span></span><br><span class="line">type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 该内置函数产生完整的内存屏障。</span></span><br><span class="line">__sync_synchronize (...)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 value 值写入到指针 *ptr 变量中，并且返回操作之前的值。</span></span><br><span class="line">type __sync_lock_test_and_set (type *ptr, type value, ...)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将0写入到 *ptr 变量中，并对其解锁。</span></span><br><span class="line">void __sync_lock_release (type *ptr, ...)</span><br><span class="line"><span class="meta">#</span><span class="bash"> __sync_lock_release 是GCC内置的原子操作函数之一，用于释放一个锁。这个函数通常与 __sync_lock_test_and_set 配合使用，用于实现基本的自旋锁。自旋锁是一种同步机制，它会一直尝试获取锁，如果锁已经被占用，则一直忙等待（自旋）直到获取到锁为止。</span></span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ATOMIC_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ATOMIC_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The atomic counter structure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">int32_t</span> cnt; <span class="comment">/**&lt; An internal counter value. */</span></span><br><span class="line">&#125; <span class="keyword">atomic32_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically read a 32-bit value from a counter.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> *   A pointer to the atomic counter.</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *   The value of the counter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int32_t</span></span><br><span class="line">atomic32_read(<span class="keyword">const</span> <span class="keyword">atomic32_t</span> *v)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> v-&gt;cnt;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically set a counter to a 32-bit value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> *   A pointer to the atomic counter.</span></span><br><span class="line"><span class="comment"> * @param new_value</span></span><br><span class="line"><span class="comment"> *   The new value for the counter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">atomic32_set(<span class="keyword">rte_atomic32_t</span> *v, <span class="keyword">int32_t</span> new_value)</span><br><span class="line">&#123;</span><br><span class="line">	v-&gt;cnt = new_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically add a 32-bit value to an atomic counter.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> *   A pointer to the atomic counter.</span></span><br><span class="line"><span class="comment"> * @param inc</span></span><br><span class="line"><span class="comment"> *   The value to be added to the counter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">atomic32_add(<span class="keyword">atomic32_t</span> *v, <span class="keyword">int32_t</span> inc)</span><br><span class="line">&#123;</span><br><span class="line">	__sync_fetch_and_add(&amp;v-&gt;cnt, inc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically subtract a 32-bit value from an atomic counter.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> *   A pointer to the atomic counter.</span></span><br><span class="line"><span class="comment"> * @param dec</span></span><br><span class="line"><span class="comment"> *   The value to be subtracted from the counter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">atomic32_sub(<span class="keyword">atomic32_t</span> *v, <span class="keyword">int32_t</span> dec)</span><br><span class="line">&#123;</span><br><span class="line">	__sync_fetch_and_sub(&amp;v-&gt;cnt, dec);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically add a 32-bit value to a counter and return the result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Atomically adds the 32-bits value (inc) to the atomic counter (v) and</span></span><br><span class="line"><span class="comment"> * returns the value of v after addition.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> *   A pointer to the atomic counter.</span></span><br><span class="line"><span class="comment"> * @param inc</span></span><br><span class="line"><span class="comment"> *   The value to be added to the counter.</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *   The value of v after the addition.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int32_t</span></span><br><span class="line">atomic32_add_return(<span class="keyword">atomic32_t</span> *v, <span class="keyword">int32_t</span> inc)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __sync_add_and_fetch(&amp;v-&gt;cnt, inc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically subtract a 32-bit value from a counter and return</span></span><br><span class="line"><span class="comment"> * the result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Atomically subtracts the 32-bit value (inc) from the atomic counter</span></span><br><span class="line"><span class="comment"> * (v) and returns the value of v after the subtraction.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> *   A pointer to the atomic counter.</span></span><br><span class="line"><span class="comment"> * @param dec</span></span><br><span class="line"><span class="comment"> *   The value to be subtracted from the counter.</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *   The value of v after the subtraction.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int32_t</span></span><br><span class="line">atomic32_sub_return(<span class="keyword">atomic32_t</span> *v, <span class="keyword">int32_t</span> dec)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __sync_sub_and_fetch(&amp;v-&gt;cnt, dec);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">atomic32_inc_and_test</span><span class="params">(<span class="keyword">atomic32_t</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (__sync_add_and_fetch(&amp;v-&gt;cnt, <span class="number">1</span>) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically subtract a 32-bit value from a counter and return</span></span><br><span class="line"><span class="comment"> * the result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Atomically subtracts the 32-bit value (inc) from the atomic counter</span></span><br><span class="line"><span class="comment"> * (v) and returns the value of v after the subtraction.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> *   A pointer to the atomic counter.</span></span><br><span class="line"><span class="comment"> * @param dec</span></span><br><span class="line"><span class="comment"> *   The value to be subtracted from the counter.</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *   The value of v after the subtraction.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int32_t</span></span><br><span class="line">atomic32_sub_return(<span class="keyword">atomic32_t</span> *v, <span class="keyword">int32_t</span> dec)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __sync_sub_and_fetch(&amp;v-&gt;cnt, dec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic_t                atomic32_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic_read(v)          atomic32_read(v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic_set(v, i)        rte_atomic32_set(v, i)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic_inc(v)           rte_atomic32_add(v, 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic_dec(v)           rte_atomic32_sub(v, 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic_inc_and_test(v)  rte_atomic32_inc_and_test(v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic_dec_and_test(v)  rte_atomic32_dec_and_test(v)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic_inc_return(v)    rte_atomic32_add_return(v, 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic_dec_return(v)    rte_atomic32_sub_return(v, 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic_sub_and_test(i, v) (rte_atomic32_sub_return(v, i) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __cpluscplus*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p>[1] <a href="https://gcc.gnu.org/onlinedocs/gcc-4.8.5/gcc/_005f_005fsync-Builtins.html#_005f_005fsync-Builtins">https://gcc.gnu.org/onlinedocs/gcc-4.8.5/gcc/_005f_005fsync-Builtins.html#_005f_005fsync-Builtins</a></p>
]]></content>
  </entry>
  <entry>
    <title>伙伴系统（Buddy System）</title>
    <url>/2023/07/19/74c46917.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>linux 伙伴系统是内存管理的子系统会将物理内存分成一个个页（page），4KB，大页内存2MB，1G等。</p>
<p>伙伴系统（Buddy  System）将我们物理页划分成不同大小的内存块。大小相等的内存块使用链表将其连接起来，如下图所示：</p>
<a id="more"></a>![image-20230719004629519](image-20230719004629519.png)]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2023/07/16/2633a26.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>位运算是一组在二进制位级别上操作数据的运算操作，直接对二进制位进行操作。常见的位运算操作如下：</p>
<ul>
<li><p>按位与&amp;：将两个操作数对应的位进行逻辑与操作，都为1时为1，否则为0。</p>
</li>
<li><p>按位或|：将两个操作数对应的位进行逻辑或操作，有一个为1时为1，否则为0。</p>
</li>
<li><p>按位异或^：将两个操作数对应的位进行异或操作，对应位不同时为1，相同时为0。</p>
</li>
<li><p>按位取反~：将两个操作数对应的位进行取反操作，0变为1，1变为0。</p>
</li>
<li><p>左移&lt;&lt;：将操作数的所有位向左移动指定的位数，左移会在右侧补0，相当于原数进行乘以2的幂数操作。‘</p>
</li>
<li><p>右移&gt;&gt;：将操作数的所有位向右移动指定的位数。右移操作 可以分为算术右移和逻辑右移，算术右移在左侧补符号位，</p>
<p>逻辑右移则是在左侧补0。</p>
</li>
</ul>
<a id="more"></a>

<h2 id="实现一个函数，一个Byte的8bit，两两一组，调用一次自增，最大3。"><a href="#实现一个函数，一个Byte的8bit，两两一组，调用一次自增，最大3。" class="headerlink" title="实现一个函数，一个Byte的8bit，两两一组，调用一次自增，最大3。"></a>实现一个函数，一个Byte的8bit，两两一组，调用一次自增，最大3。</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBinary</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> value, <span class="keyword">int</span> bitlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = bitlen<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (value &gt;&gt; i) &amp; <span class="number">0x1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// shi bu shi chang sha wan shi bu shi </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increamentValue</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> group)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shift = group * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> mask = <span class="number">0x3</span> &lt;&lt; shift;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> groupValue = (*value &amp; mask) &gt;&gt; shift;</span><br><span class="line">    <span class="keyword">if</span> (groupValue &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        groupValue++;</span><br><span class="line">        *value = (*value &amp; ~mask) | (groupValue &lt;&lt; shift);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> value = <span class="number">0x0</span>;</span><br><span class="line">    printBinary(value, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    increamentValue(&amp;value, <span class="number">0</span>);</span><br><span class="line">    increamentValue(&amp;value, <span class="number">0</span>);</span><br><span class="line">    increamentValue(&amp;value, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    increamentValue(&amp;value, <span class="number">2</span>);</span><br><span class="line">    increamentValue(&amp;value, <span class="number">2</span>);</span><br><span class="line">    increamentValue(&amp;value, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    increamentValue(&amp;value, <span class="number">1</span>);</span><br><span class="line">    increamentValue(&amp;value, <span class="number">1</span>);</span><br><span class="line">    increamentValue(&amp;value, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;%u\n&quot;, ~value);</span></span><br><span class="line">    printBinary(value, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>DPDK编程指南-译</title>
    <url>/2023/07/07/e0ed22e3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章-介绍"><a href="#第一章-介绍" class="headerlink" title="第一章 介绍"></a>第一章 介绍</h1><p>本文档提供软件架构、开发环境和优化指南相关信息。</p>
<p>有关编译和运行示例程序的说明介绍，详见 <em><strong>DPDK示例程序用户指南</strong></em>。</p>
<p>有关编译和运行应用程序的一般信息，详见 <em><strong>DPDK入门指南</strong></em>。</p>
<h2 id="文档路线图"><a href="#文档路线图" class="headerlink" title="文档路线图"></a>文档路线图</h2><p>以下是在阅读DPDK相关文档的时候的阅读顺序建议：</p>
<ul>
<li><p><strong>发布说明（此文档）：</strong> 提供发布相关的信息，包括支持的功能、限制、修复的问题和已知问题等。除此之外，还以FAQ（Frequently Asked Questions）的方式提供了常见问题及解答。</p>
</li>
<li><p><strong>入门指南：</strong> 描述讲解如何安装和配置DPDK软件，旨在帮助用户能快速上手使用软件。</p>
</li>
<li><p><strong>FreeBSD* 入门指南：</strong> DPDK1.6.0 版本中新增了一份讲述在FreeBSD上使用DPDK的文档。参考这份文档，在FreeBSD平台上安装和配置DPDK。</p>
</li>
<li><p><strong>程序员指南（本文档）：</strong> 描述：</p>
<ul>
<li>软件架构及如何使用（通过示例程序），特别是在Linux环境中的应用程序。</li>
<li>DPDK的主要内容，构建系统（包括能在DPDK目录下使用Makefile编译构建开发套件和应用程序的命令）以及应用程序的的移植指南。</li>
<li>软件中使用的优化以及新开发时候应该考虑的优化。</li>
</ul>
<p>同时也提供了术语表。</p>
</li>
<li><p><strong>API 参考：</strong> 提供了详细的有关DPDK函数、数据结构以及其他编程结构的信息。</p>
</li>
<li><p><strong>示例应用程序用户指南：</strong> 描述一组示例程序。每个章节描述一个示例应用程序，展示特定的功能，同时也提供有关如何编译运行和使用的示例说明。</p>
</li>
</ul>
<h2 id="相关刊物"><a href="#相关刊物" class="headerlink" title="相关刊物"></a>相关刊物</h2><p>以下文档提供了与使用DPDK开发应用程序相关的信息：</p>
<ul>
<li>英特尔® 64和IA-32架构软件开发者手册第3A卷：系统编程指南。</li>
</ul>
<h1 id="第二章-概述"><a href="#第二章-概述" class="headerlink" title="第二章 概述"></a>第二章 概述</h1><p>本节概述了数据平面开发套件（DPDK）的架构。DPDK的主要目标是为数据平面应用程序提供一个简单、完整的快速数据包处理框架。用户可以使用该代码来理解一些采用的技术，用于原型设计或添加自己的协议栈。还提供了使用DPDK的备选生态系统选项。</p>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2>]]></content>
      <categories>
        <category>DPDK</category>
      </categories>
  </entry>
  <entry>
    <title>dpdk-testpmd</title>
    <url>/2023/07/02/1ea610e1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>简介</strong></p>
<p>数据面开发工具包（DPDK）testpmd应用程序可用于测试数据包转发模式下的dpdk，也可以用于访问NIC网卡硬件功能。可以在网络接口之间转发数据包，同时可以测试一些不通驱动的一些功能，比如RSS，过滤器以及流量控制器等等。</p>
<a id="more"></a>

<p><strong>实验配置</strong></p>
<p>// TODO</p>
<p><strong>数据转发模式</strong></p>
<p>testpmd有几种数据转发模式</p>
<ul>
<li><strong>输入/输出模式（Input/Output mode）</strong> 也成为IO模式，最常用的转发模式，启动的默认模式。在此模式下，CPU内核从一个端口接收数据包（RX）,并将其发送到另一个端口（TX），</li>
</ul>
<p>当然也可以一个端口进行接收和发送。</p>
<ul>
<li><strong>仅收包模式（Rx-only mode）</strong> 应用程序只会轮询接收Rx端口的数据包，然后直接释放而不进行发送。</li>
<li><strong>仅发包模式（Tx-only mode）</strong> 应用程序生成64Byte的IP数据包，并从Tx端口发送出去。不接收数据包，仅作为数据包源。</li>
</ul>
<img src="/images/image-20230702154337433.png" alt="image-20230702154337433" style="zoom:67%;" />

<ul>
<li>运行testpmd测试dpdk轮询驱动</li>
</ul>
<p><code>./testpmd -l 0-3 -n 1 -- -i</code></p>
<p><img src="/images/image-20230702154625314.png" alt="image-20230702154625314"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看转发配置</span></span><br><span class="line">show config fwd</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置只接收</span></span><br><span class="line">set fwd rxonly</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打开混杂模式，可以收取所有的数据包</span></span><br><span class="line">set promisc all on</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有端口的收发包情况</span></span><br><span class="line">show port stats all</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清除统计信息</span></span><br><span class="line">clear port stats all</span><br></pre></td></tr></table></figure>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://doc.dpdk.org/guides/testpmd_app_ug/intro.html#">https://doc.dpdk.org/guides/testpmd_app_ug/intro.html#</a></p>
]]></content>
      <categories>
        <category>DPDK</category>
      </categories>
  </entry>
  <entry>
    <title>ChatGPT Propmt</title>
    <url>/2023/07/02/ef4f0767.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>自从OpenAI公司的推出以来大家立即被他强大的功能所吸引了。它具有非常大的潜力，它也辅助我解决了非常多的问题，提升了非常多的效率。当然，使用的过程中我们也发现，如果使用的不好，对他不熟悉，有时候他也会胡说八道，这对于不知道分辨内容的正确性的人来说，确实有点不友好，会被它带偏的情况。这其中，当然有他本身还不够成熟的原因，但是还有其他的一些原因，比如我们没有调教好它，给他足够的信息提示。</p>
<p>在于ChatGPT对话的过程中，如果我们有一个高质量的提示，那么我们也会得到一个高效的结果，不需要反复的进行对话调试。</p>
<p>在于ChatGPT交流的提示词中，我们需要记住几个关键原则：</p>
<ul>
<li><strong>清晰</strong>  使用清晰简洁的提示词、确定边界范围避免使用模棱两可，模糊，容易搞混的提示词</li>
<li><strong>重点</strong> 哪一部分是重点需要突出出来，有助于寻找关键的信息。</li>
<li><strong>关联</strong> 确保提示与用户的对话相关，一个问题内容使用一个会话，避免信息的混合。</li>
</ul>
<p>下面是整理的一些自己平时使用的提示词</p>
<a id="more"></a>

<ul>
<li>联网查询信息提示词</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I will give you a question or an instruction. Your objective is to answer my question or fulfill my instruction.</span><br><span class="line"></span><br><span class="line">My question or instruction is: &#123;query&#125;</span><br><span class="line"></span><br><span class="line">For your reference, today&#39;s date is &#123;current_date&#125;.</span><br><span class="line"></span><br><span class="line">It&#39;s possible that the question or instruction, or just a portion of it, requires relevant information from the internet to give a satisfactory answer or complete the task. Therefore, provided below is the necessary information obtained from the internet, which sets the context for addressing the question or fulfilling the instruction. You will write a comprehensive reply to the given question or instruction. Make sure to cite results using [[NUMBER](URL)] notation after the reference. If the provided information from the internet results refers to multiple subjects with the same name, write separate answers for each subject:</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">&#123;web_results&#125;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Reply in 中文</span><br></pre></td></tr></table></figure>
<ul>
<li>中文回答</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I will give you a question or an instruction. Your objective is to answer my question or fulfill my instruction.</span><br><span class="line"></span><br><span class="line">My question or instruction is: &#123;query&#125;</span><br><span class="line"></span><br><span class="line">Reply in 中文</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>chatgpt</tag>
      </tags>
  </entry>
  <entry>
    <title>SpaceVim搭建开发环境</title>
    <url>/2023/06/30/0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="离线安装SpaceVim，配置开发环境"><a href="#离线安装SpaceVim，配置开发环境" class="headerlink" title="离线安装SpaceVim，配置开发环境"></a>离线安装SpaceVim，配置开发环境</h1><p>vim和Chrome一样，没有插件是没有灵魂的。曾几何时我也是痴迷各种vim配置，经常捣鼓各种。使用Vim插件就需要用到插件管理工具，用的比较多的插件有vim-plug、vundle等等。</p>
<p>配置好的vim可以是自己非常好的IDE，记录一下自己的vim配置。</p>
<p>有时间在内网网络隔离的时候配置我们开发环境就比较麻烦，记录一下离线安装的过程。</p>
<a id="more"></a>

<p>spacevim 是一个非常好用的插件管理工具，我们可以在对应的<a href="https://spacevim.org/">SpaceVim官网</a>上获取到对应的使用帮助，同时GitHub上获取<a href="https://github.com/Gabirel/Hack-SpaceVim">SpaceVim</a>进行安装。</p>
<p>离线安装</p>
<p>1、下载<a href="https://github.com/Gabirel/Hack-SpaceVim/releases">发行版</a>SpaceVim。</p>
<p>2、直接解压文件。</p>
<p>3、将解压出来的文件拷贝到<code>~</code>目录下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~&#x2F;.SpaceVim&#x2F;</span><br><span class="line">~&#x2F;.cache&#x2F;vimfiles&#x2F;</span><br><span class="line">~&#x2F;.SpaceVim.d&#x2F;</span><br><span class="line">~&#x2F;.cache&#x2F;SpaceVim&#x2F;</span><br></pre></td></tr></table></figure>
<p>4、在<code>~</code>目录下创建<code>.vim</code>目录，并创建对应的软链接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir .vim</span><br><span class="line">ln -svf ~&#x2F;.SpaceVim&#x2F;* ~&#x2F;.vim&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="SpaceVim常见问题"><a href="#SpaceVim常见问题" class="headerlink" title="SpaceVim常见问题"></a>SpaceVim常见问题</h2><h3 id="颜色和主题不一致"><a href="#颜色和主题不一致" class="headerlink" title="颜色和主题不一致"></a>颜色和主题不一致</h3><p>在 SpaceVim 中，默认情况下启用了终端真色，因此你需要确保你的终端支持真色。 但是并不是每种终端都支持真色。因此，当你的终端不支持真色时，我们的vim打开文件可能就是一片灰的，所以需要修改配置文件<code>/root/.SpaceVim.d/init.toml</code>禁用掉该选项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[options]</span><br><span class="line">    enable_guicolors &#x3D; false</span><br></pre></td></tr></table></figure>
<h3 id="增加自定义快捷键"><a href="#增加自定义快捷键" class="headerlink" title="增加自定义快捷键"></a>增加自定义快捷键</h3><p>我需要加入这样一个快捷键，使用 <code>&lt;Leader&gt; w</code> 来保存当前文件。那么， 我需要修改配置文件，并指定一个载入时需要调用的方法：</p>
<p>在<code>~/.SpaceVim.d/init.toml</code>的[options]片断中加入 <code>bootstrap_before</code> 选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[options]</span><br><span class="line">    bootstrap_before &#x3D; &quot;myspacevim#init&quot;</span><br></pre></td></tr></table></figure>
<p>添加文件 <code>~/.SpaceVim.d/autoload/myspacevim.vim</code>, 并加入如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function! myspacevim#init() abort</span><br><span class="line">    nnoremap &lt;Leader&gt;w :w&lt;cr&gt;</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
<h3 id="Ctrl-s屏幕卡死问题"><a href="#Ctrl-s屏幕卡死问题" class="headerlink" title="Ctrl-s屏幕卡死问题"></a>Ctrl-s屏幕卡死问题</h3><p>这是终端模拟器的特性，在终端模拟器内，有一套快捷键，可以暂停终端输出和恢复输出，默认情况下， 按下 <code>Ctrl-s</code> 终端会停止输出，表现为 Vim 卡住，按任何按键都无响应。此时可以按 <code>Ctrl-q</code> 恢复终端。 当然，如果你希望禁用这一特性，可以在的终端配置文件 <code>~/.bashrc</code> 或者 <code>~/.bash_profile</code> 中加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stty -ixon</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Centos8磁盘扩容</title>
    <url>/2022/11/02/1f64a8c5.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>（1）使用传统的物理卷情况下，我们对其分好区，需要对其进行扩容或者缩小分区的情况下，需要把里面的数据拷贝走然后重新分区，但是一般我们的生产环境上的数据动辄几百G，所以操作起来是非常非常困难的。</p>
<p>（2）有时候数据量很大的时候，我们的单块硬盘承载不了我们的数据，我们就需要多块磁盘来存储我们的数据，这时候如果是传统非物理卷处理起来也比较麻烦。</p>
<ul>
<li>物理卷（Physical Volume,PV）：指的是物理磁盘分区，如果想要使用LVM来管理这个分区，可以使用fdisk将其ID改为LVM可以识别的值，即8e。</li>
<li>卷组（Volume Group,VG）：PV的集合</li>
<li>逻辑卷（Logic Volume,LV）：VG中画出来的一块逻辑磁盘，在我们传统的硬盘底层之上再叠一层，模拟一个虚拟的磁盘，在使用上更加灵活。</li>
</ul>
<a id="more"></a>

<img src="/images/image-20221105073424367.png" alt="image-20221105073424367" style="zoom:67%;" />

<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>创建逻辑卷的过程：</p>
<ul>
<li>创建物理卷</li>
<li>创建卷组</li>
<li>创建逻辑卷</li>
<li>初始化文件系统</li>
<li>创建挂载点</li>
<li>挂载文件系统</li>
<li>设置开机自动挂载</li>
</ul>
<h3 id="创建逻辑卷"><a href="#创建逻辑卷" class="headerlink" title="创建逻辑卷"></a>创建逻辑卷</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看所有的物理卷吧</span></span><br><span class="line">fdisk -l</span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<img src="/images/image-20221105081314533.png" alt="image-20221105081314533" style="zoom:67%;" />

<img src="/images/image-20221105081616419.png" alt="image-20221105081616419" style="zoom:67%;" />

<img src="/images/image-20221105085920430.png" alt="image-20221105085920430" style="zoom:67%;" />

<p><img src="/images/image-20221105090423893.png" alt="image-20221105090423893"></p>
<ul>
<li>重新读取分区</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重新读取分区</span></span><br><span class="line">partprobe    重读分区表</span><br><span class="line">fdisk -l     查看分区信息</span><br></pre></td></tr></table></figure>
<img src="/images/image-20221105090704545.png" alt="image-20221105090704545" style="zoom:67%;" />

<ul>
<li>格式化新建的分区</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 建立文件系统，格式化分区</span></span><br><span class="line">mkfs.xfs /dev/sda3</span><br></pre></td></tr></table></figure>
<img src="/images/image-20221105090753514.png" alt="image-20221105090753514" style="zoom:67%;" />

<ul>
<li>进行扩容</li>
</ul>
<p>查看物理卷</p>
<img src="/images/image-20221105091019965.png" alt="image-20221105091019965" style="zoom:67%;" />

<p>查看逻辑卷</p>
<img src="/images/image-20221105090932401.png" alt="image-20221105090932401" style="zoom:67%;" />

<p>创建物理卷</p>
<img src="/images/image-20221105091131720.png" alt="image-20221105091131720" style="zoom:67%;" />

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pvcreate /dev/sda3       #初始化分区sda3</span><br><span class="line">vgextend cl /dev/sda3    #将分区sda3加入到虚拟卷组cl</span><br><span class="line">lvextend -l +100%FREE /dev/mapper/cl-root    #扩展文件系统容量</span><br><span class="line">pvdisplay      #查看卷组</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>扩容逻辑卷的过程：</p>
<ul>
<li>扩容卷组，将空闲的卷组扩容到卷组中</li>
<li>扩容逻辑卷组</li>
<li>扩容文件系统</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看物理卷命令</span></span><br><span class="line">pvdisplay</span><br><span class="line">pvs</span><br><span class="line">pvscan</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看逻辑卷</span></span><br><span class="line">vgdisplay</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Kubernetes集群搭建</title>
    <url>/2022/07/04/e13f38b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="K8S学习"><a href="#K8S学习" class="headerlink" title="K8S学习"></a>K8S学习</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MESOS apache   分布式资源框架  2019-5 twitter 宣布导向k8s</p>
<p>docker swarm 2019-07  阿里云宣布，Docker swarm 剔除。</p>
<p>k8s    Google    10年容器化的基础架构。 borg。</p>
<p>特点：</p>
<p>​    轻量级：消耗小</p>
<p>​    开源：</p>
<p>​    弹性伸缩：</p>
<p>​    负载均衡：最新的版本是用IPVS框架。</p>
<a id="more"></a>

<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="Brog"><a href="#Brog" class="headerlink" title="Brog"></a>Brog</h3><img src="/images/image-20220703110445888.png" style="zoom: 33%;" />

<h3 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h3><img src="/images/image-20220703111204773.png" style="zoom: 33%;" />

<h3 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h3><img src="/images/image-20220703110843441.png" style="zoom:33%;" />

<p>api server ：所有服务访问的路口，充当网关的角色。</p>
<p>controllerManager：维持副本的期望数。</p>
<p>scheduler：调度器，负责接收任务，分配节点。</p>
<p>etcd：存储，持久化。</p>
<p>kubelet：直接跟容器引擎交互，实现容器的生命周期管理。</p>
<p>kubeproxy：负责写入规则到iptables、ipvs、firewalld等，实现服务映射。</p>
<p>coreDNS：为集群中的service提供域名解析。</p>
<p>DASHBOARD：提供B/S结构访问平台。</p>
<h2 id="构建k8s集群"><a href="#构建k8s集群" class="headerlink" title="构建k8s集群"></a>构建k8s集群</h2><h3 id="集群节点设置"><a href="#集群节点设置" class="headerlink" title="集群节点设置"></a>集群节点设置</h3><p>安装环境</p>
<p>1、关闭防火墙</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line"><span class="comment"># 关闭开机防火墙自启动</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure>
<p>2、关闭selinux</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 临时关闭</span></span><br><span class="line">setenforce 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 永久关闭</span></span><br><span class="line">sed -i &#x27;s/=enforcing/=disabled/&#x27; &#x27;/etc/selinux/config&#x27;</span><br></pre></td></tr></table></figure>
<p>3、关闭swap分区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 临时关闭</span></span><br><span class="line">swapoff -a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 永久关闭</span></span><br><span class="line">sed -ri &#x27;s/.*swap.*/#&amp;/&#x27;  /etc/fstab</span><br></pre></td></tr></table></figure>
<p>4、规划主机名设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname &lt;hostname&gt;</span><br></pre></td></tr></table></figure>
<p>5、在master中，设置相关的hosts</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt;&gt; /etc/hosts &lt;&lt; EOF</span><br><span class="line">192.168.44.146 k8smaster</span><br><span class="line">192.168.44.145 k8snode1</span><br><span class="line">192.168.44.144 k8snode2</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>6、将桥接的IPv4流量全部转发到iptables的链中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt;&gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行命令立即生效</span></span><br><span class="line">sysctl --system</span><br></pre></td></tr></table></figure>
<p>7、同步时间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install ntpdate</span><br><span class="line">ntpdate time.windows.com</span><br></pre></td></tr></table></figure>
<h3 id="在所有节点安装Docker-kubeadm-kubelet"><a href="#在所有节点安装Docker-kubeadm-kubelet" class="headerlink" title="在所有节点安装Docker/kubeadm/kubelet"></a>在所有节点安装Docker/kubeadm/kubelet</h3><h4 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h4><p>k8s默认的CRI（容器运行时）是Docker，所以我们需要先安装Docker。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取aliyundocker-ce源文件</span></span><br><span class="line">wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装docker</span></span><br><span class="line">yum -y install docker-ce-18.06.1.ce-3.el7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看docker是否安装成功</span></span><br><span class="line">docker --version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置docker镜像源</span></span><br><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [&quot;https://b9pmyelo.mirror.aliyuns.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启docker</span> </span><br><span class="line">systemctl restart docker.service</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看修改结果（查看docker相关信息）</span></span><br><span class="line">docker info</span><br></pre></td></tr></table></figure>
<h4 id="添加aliyun的yum软件源"><a href="#添加aliyun的yum软件源" class="headerlink" title="添加aliyun的yum软件源"></a>添加aliyun的yum软件源</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<h4 id="安装kubeadm，kubelet和kubectl"><a href="#安装kubeadm，kubelet和kubectl" class="headerlink" title="安装kubeadm，kubelet和kubectl"></a>安装kubeadm，kubelet和kubectl</h4><p>版本之间可能会存在兼容性问题，所以我们指定版本安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum 安装kubelet和kubeadm以及kubectl</span></span><br><span class="line">yum install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置开机自启动</span></span><br><span class="line">systemctl enable kubelet</span><br></pre></td></tr></table></figure>
<h4 id="部署Kubernetes-master节点"><a href="#部署Kubernetes-master节点" class="headerlink" title="部署Kubernetes master节点"></a>部署Kubernetes master节点</h4><p>在master节点上执行，这里是192.168.44.146。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=192.168.44.146 \</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">--kubernetes-version v1.18.0 \</span><br><span class="line">--service-cidr=10.96.0.0/12 \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure>
<p>由于国内无法直接访问默认镜像仓库k8s.gcr.io，所以这里指定了aliyun的镜像仓库地址。</p>
<p>使用kubectl工具，需要配置一些项，如下图：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure>
<img src="/images/image-20220704000914605.png"  />

<h4 id="部署Kubernetes-Node节点"><a href="#部署Kubernetes-Node节点" class="headerlink" title="部署Kubernetes Node节点"></a>部署Kubernetes Node节点</h4><p>在子节点node中执行以下命令，将节点加入master主节点，这里是192.168.44.145和192.168.44.144两个node节点。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join 192.168.44.146:6443 --token 1jpl8j.dvxt8xtrhvp5kjyh \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:741496f9f466bdc96b5ac4a0c76dbaf941a67192496c9c9bf396cabdc2a8df30</span><br></pre></td></tr></table></figure>
<p>默认生成的token有效期为24小时，所以当我们的token失效的时候，需要重新在master节点上重新创建token，具体创建的指令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建token命令</span></span><br><span class="line">kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure>
<img src="/images/image-20220704002615907.png"  />

<p>将子节点加入集群之后可以在master节点上执行命令<code>kubectl get nodes</code>查看。</p>
<img src="/images/image-20220704002654928.png"  />

<h4 id="部署CNI网络组件"><a href="#部署CNI网络组件" class="headerlink" title="部署CNI网络组件"></a>部署CNI网络组件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载yml源</span></span><br><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者直kubectl直接应用</span></span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看各组件的运行情况，是否已经启动完成（RUNNING状态）</span></span><br><span class="line">kubectl get pods -n kube-system</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看各节点的情况</span></span><br><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod的状态</span></span><br><span class="line">kubectl describe pod kube-flannel-ds-x56s9 --namespace=kube-system</span><br></pre></td></tr></table></figure>
<img src="/images/image-20220704004256640.png"  />

<p>拉取镜像的时候出错了，如上图所示，<code>Init:ImagePullBackOff</code>。原因：网络不好，拉取的时候超时了。</p>
<p>执行命令<code>kubectl describe pod kube-flannel-ds-x56s9 --namespace=kube-system</code>查看错误原因，可以看到是pull的时候报错了，如下图所示。</p>
<img src="/images/image-20220704013349614.png"  />

<p>解决方案：</p>
<p>1、等待k8s重试。</p>
<p>2、手动拉取镜像</p>
<img src="/images/image-20220704012118396.png"/>

<p>查看了node节点状态，发现node2时候的，所以执行命令<code>docker images</code>命令对比了两者的镜像差异，发现异常节点少了两个镜像。</p>
<p>异常节点k8snode1镜像如下：</p>
<img src="/images/image-20220704012356245.png"/>

<p>正常节点k8snode2镜像如下：</p>
<img src="/images/image-20220704012458981.png"/>

<p>对比发现，少了个异常节点镜像，所以执行命令<code>docker save -o cni.tar.gz rancher/mirrored-flannelcni-flannel-cni-plugin:v1.1.0</code>打包缺少的镜像。</p>
<p>在异常节点k8snode1上执行命令<code>docker load -i &lt; cni.tar.gz</code>手动加载镜像。</p>
<p>3、重启docker服务。</p>
<p>重启k8snode1节点docker<code>systemctl restart docker.service</code>，之后Kubernetes会自动创建pods。</p>
<p>在master节点上执行命令<code>kubectl get nodes</code>查看节点的状态，如下图：</p>
<img src="/images/image-20220704012942340.png"/>

<h4 id="测试Kubernetes集群"><a href="#测试Kubernetes集群" class="headerlink" title="测试Kubernetes集群"></a>测试Kubernetes集群</h4><p>在Kubernetes集群中创建一个pod，验证是否正常。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 拉去一个Nginx镜像</span></span><br><span class="line">kubectl create deployment nginx --image=nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对外放开端口</span></span><br><span class="line">kubectl expose deployment nginx --port=80 --type=NodePort</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看端口</span></span><br><span class="line">kubectl get pod,svc</span><br></pre></td></tr></table></figure>
<p>正在拉取中：</p>
<img src="/images/image-20220704014050616.png"/>

<p>拉取并创建完成：</p>
<img src="/images/image-20220704014809361.png"/>

<p>查看暴露的服务端口：</p>
<img src="/images/image-20220704014851980.png" />

<p>在本机电脑中使用k8snode1<code>http://192.168.44.145:31259</code>或者在k8snode2<code>http://192.168.44.122:31259</code>或者在master节点上，就可以正常访问Nginx服务器了。</p>
<img src="/images/image-20220704015121985.png" />
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
  </entry>
  <entry>
    <title>Java操作数据库</title>
    <url>/2022/07/01/73a1e6d5.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java 数据库连接 (JDBC) API 提供来自 Java 编程语言的通用数据访问。使用 JDBC API，几乎可以访问任何数据源，从关系数据库到电子表格和平面文件。JDBC 技术还提供了一个通用基础，可以在此基础上构建工具和替代接口。所以很多数据库的连接我们都可以通过自己编写代码从而对数据库进行增删改查。</p>
<p>刚好手上有一个postgresql数据库，就用它进行试验。</p>
<p>JDBC只是定义了一些接口规范，我们实际使用的时候，还需要用到对应的数据库驱动的<strong>jar</strong>包。</p>
<p>下载地址<a href="https://jdbc.postgresql.org/download.html">postgres-jdbc-driver</a></p>
<a id="more"></a>

<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostgreSQLJDBC</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">      Connection c = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         Class.forName(<span class="string">&quot;org.postgresql.Driver&quot;</span>);</span><br><span class="line">         c = DriverManager</span><br><span class="line">            .getConnection(<span class="string">&quot;jdbc:postgresql://localhost:5432/pgdb&quot;</span>,</span><br><span class="line">            <span class="string">&quot;postgres&quot;</span>, <span class="string">&quot;passwd&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">         System.err.println(e.getClass().getName()+<span class="string">&quot;: &quot;</span>+e.getMessage());</span><br><span class="line">         System.exit(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;Opened database successfully&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建表操作"><a href="#创建表操作" class="headerlink" title="创建表操作"></a>创建表操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostgreSQLJDBC</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">       Connection c = <span class="keyword">null</span>;</span><br><span class="line">       Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         Class.forName(<span class="string">&quot;org.postgresql.Driver&quot;</span>);</span><br><span class="line">         c = DriverManager</span><br><span class="line">            .getConnection(<span class="string">&quot;jdbc:postgresql://localhost:5432/testdb&quot;</span>,</span><br><span class="line">            <span class="string">&quot;manisha&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">         System.out.println(<span class="string">&quot;Opened database successfully&quot;</span>);</span><br><span class="line"></span><br><span class="line">         stmt = c.createStatement();</span><br><span class="line">         String sql = <span class="string">&quot;CREATE TABLE COMPANY &quot;</span> +</span><br><span class="line">                      <span class="string">&quot;(ID INT PRIMARY KEY     NOT NULL,&quot;</span> +</span><br><span class="line">                      <span class="string">&quot; NAME           TEXT    NOT NULL, &quot;</span> +</span><br><span class="line">                      <span class="string">&quot; AGE            INT     NOT NULL, &quot;</span> +</span><br><span class="line">                      <span class="string">&quot; ADDRESS        CHAR(50), &quot;</span> +</span><br><span class="line">                      <span class="string">&quot; SALARY         REAL)&quot;</span>;</span><br><span class="line">         stmt.executeUpdate(sql);</span><br><span class="line">         stmt.close();</span><br><span class="line">         c.close();</span><br><span class="line">       &#125; <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">         System.err.println( e.getClass().getName()+<span class="string">&quot;: &quot;</span>+ e.getMessage() );</span><br><span class="line">         System.exit(<span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;Table created successfully&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入数据操作"><a href="#插入数据操作" class="headerlink" title="插入数据操作"></a>插入数据操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostgreSQLJDBC</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">      Connection c = <span class="keyword">null</span>;</span><br><span class="line">      Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         Class.forName(<span class="string">&quot;org.postgresql.Driver&quot;</span>);</span><br><span class="line">         c = DriverManager</span><br><span class="line">            .getConnection(<span class="string">&quot;jdbc:postgresql://localhost:5432/testdb&quot;</span>,</span><br><span class="line">            <span class="string">&quot;manisha&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">         c.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">         System.out.println(<span class="string">&quot;Opened database successfully&quot;</span>);</span><br><span class="line"></span><br><span class="line">         stmt = c.createStatement();</span><br><span class="line">         String sql = <span class="string">&quot;INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) &quot;</span></span><br><span class="line">               + <span class="string">&quot;VALUES (1, &#x27;Paul&#x27;, 32, &#x27;California&#x27;, 20000.00 );&quot;</span>;</span><br><span class="line">         stmt.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line">         sql = <span class="string">&quot;INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) &quot;</span></span><br><span class="line">               + <span class="string">&quot;VALUES (2, &#x27;Allen&#x27;, 25, &#x27;Texas&#x27;, 15000.00 );&quot;</span>;</span><br><span class="line">         stmt.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line">         sql = <span class="string">&quot;INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) &quot;</span></span><br><span class="line">               + <span class="string">&quot;VALUES (3, &#x27;Teddy&#x27;, 23, &#x27;Norway&#x27;, 20000.00 );&quot;</span>;</span><br><span class="line">         stmt.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line">         sql = <span class="string">&quot;INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) &quot;</span></span><br><span class="line">               + <span class="string">&quot;VALUES (4, &#x27;Mark&#x27;, 25, &#x27;Rich-Mond &#x27;, 65000.00 );&quot;</span>;</span><br><span class="line">         stmt.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line">         stmt.close();</span><br><span class="line">         c.commit();</span><br><span class="line">         c.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         System.err.println( e.getClass().getName()+<span class="string">&quot;: &quot;</span>+ e.getMessage() );</span><br><span class="line">         System.exit(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;Records created successfully&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h1><p>通过javac命令将代码编译成class文件，再执行。</p>
<img src="/images/image-20220701014306439.png" />

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编译成class文件</span></span><br><span class="line">javac -cp $CLASSPATH:postgresql-42.4.0.jar  PostgreSQLJDBC.java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行代码</span></span><br><span class="line">java -cp $CLASSPATH:postgresql-42.4.0.jar  PostgreSQLJDBC</span><br></pre></td></tr></table></figure>
<p>如果编译报错，则尝试检查下对应的环境变量。</p>
<img src="/images/image-20220701014121860.png" />

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://jdbc.postgresql.org/download.html">https://jdbc.postgresql.org/download.html</a></p>
<p>[2] <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/">https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/</a></p>
<p>[3] <a href="https://www.yiibai.com/postgresql/postgresql_java.html">https://www.yiibai.com/postgresql/postgresql_java.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>gitlab-runner服务报错起不来</title>
    <url>/2022/04/24/838752d2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>项目需要配置流水线，安装runner的时候，服务一直起不来。执行命令<code>systemctl restart gitlab-runner.service</code>一直提示有报错。</p>
<p>环境：</p>
<p>Centos8.2</p>
<p>下载地址：<a href="https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64">gitliab-runner</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">● gitlab-runner.service - GitLab Runner</span><br><span class="line">   Loaded: loaded (&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;gitlab-runner.service; enabled; vendor preset: enabled)</span><br><span class="line">  Drop-In: &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;gitlab-runner.service.d</span><br><span class="line">           └─exec_start.conf, kill.conf, limits.conf</span><br><span class="line">   Active: activating (auto-restart) (Result: exit-code) since Mon 2020-07-13 07:19:20 UTC; 1min 40s ago</span><br><span class="line">  Process: 9712 ExecStart&#x3D;&#x2F;usr&#x2F;lib&#x2F;gitlab-runner&#x2F;gitlab-runner --log-format json run --working-directory &#x2F;home&#x2F;gitlab-runner --config &#x2F;etc&#x2F;gitlab</span><br><span class="line"> Main PID: 9712 (code&#x3D;exited, status&#x3D;203&#x2F;EXEC)</span><br><span class="line"></span><br><span class="line">Jul 13 07:19:20 private-runners-manager-3 systemd[1]: gitlab-runner.service: Unit entered failed state.</span><br><span class="line">Jul 13 07:19:20 private-runners-manager-3 systemd[1]: gitlab-runner.service: Failed with result &#39;exit-code&#39;.</span><br></pre></td></tr></table></figure>
<p>查了好久都没有找到问题，用服务就是起不来，执行命令<code>systemctl restart gitlab-runner.service</code>也没有报错，但是<code>ps</code>没有查到对应的gitlab-runner进程。晚上查了些资料，但是大多数同样的报错原因都是说路径不对或者是没有权限。但是我执行运行gitlab-runner是没问题的，但是使用<code>gitlab-runner install</code>安装的服务就不行，就是起不来。</p>
<p>最终，禁用掉SElinux服务就可以正常起来了，真是个大坑啊！！！！</p>
<p>（1）临时关闭，执行命令<code>setenforce 0</code>。</p>
<p>（2）永久关闭，修改/etc/selinux/config配置文件，将SELINUX值改成disable，关闭，重启设备后生效。</p>
<p>在根目录下新建隐藏文件<code>autorelabel</code>，实例重启后，SELinux会自动重新标记所有系统文件，<code>touch /.autorelabel</code>。</p>
<img src="/images/image-20230702193149815.png" alt="image-20230702193149815" style="zoom:67%;" />]]></content>
      <categories>
        <category>CICD</category>
      </categories>
  </entry>
  <entry>
    <title>Centos8重置密码</title>
    <url>/2022/04/18/abc7caa5.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天自己的机器密码忘记了，然按照网上的方法对密码进行了重置，但是好使出现了一些问题，因此写点笔记记录以下。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql开启SSL加密连接</title>
    <url>/2022/02/20/51c531d0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>版本：MySQL8.0</p>
<p>MySQL为了数据的安装性，是支持SSL加密连接的。我们可以配置服务器从而使用ssl加密功能。如果采用的非加密的方式进行通信，那么久很有可能被不法分子窃取敏感信息从而导致泄漏。</p>
<p>1、登录MySQL服务器，查看是否开启ssl功能，含有以下则是开启了。</p>
<a id="more"></a>

<img src="/images/image-20220220015754378.png" alt="image-20220220015754378" style="zoom: 33%;" />

<p>2、查看用户是否使用了SSL连接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select ssl_type from user where user &#x3D; &#39;root&#39; ;</span><br><span class="line">+----------+</span><br><span class="line">| ssl_type |</span><br><span class="line">+----------+</span><br><span class="line">|          |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.05 sec)</span><br><span class="line"></span><br><span class="line"># 强制root用户使用ssl验证</span><br><span class="line">alter user &#39;root&#39;@&#39;%&#39; require ssl;</span><br><span class="line"># 取消ssl验证:</span><br><span class="line">alter user &#39;root&#39;@&#39;%&#39; require none;</span><br><span class="line"></span><br><span class="line"># 若是有ANY字样则是开启了SSL验证</span><br><span class="line">mysql&gt; select ssl_type from user where user &#x3D; &#39;root&#39; ;</span><br><span class="line">+----------+</span><br><span class="line">| ssl_type |</span><br><span class="line">+----------+</span><br><span class="line">| ANY      |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>3、查看user用户表是否对用户远程访问做了限制，若有限制则更改对应权限。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># </span><br><span class="line">mysql&gt; select host,user from user;</span><br><span class="line">+-----------+------------------+</span><br><span class="line">| host      | user             |</span><br><span class="line">+-----------+------------------+</span><br><span class="line">| %         | root             |</span><br><span class="line">| localhost | mysql.infoschema |</span><br><span class="line">| localhost | mysql.session    |</span><br><span class="line">| localhost | mysql.sys        |</span><br><span class="line">| localhost | root             |</span><br><span class="line">+-----------+------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line">表第一行可以看出，root用户值host字段为&#39;%&#39;说明允许所有的主机进行访问。</span><br><span class="line">若是没有如此，则是需要执行以下命令添加相应的权限。</span><br><span class="line"># 创建用户添加远程访问权限(mysql8.0 命令，其他版本可能不一样)</span><br><span class="line"># CREATE USER &#39;root&#39;@&#39;172.24.1.100&#39; IDENTIFIED BY &#39;你的密码&#39;; </span><br><span class="line">CREATE USER &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;你的密码&#39;; </span><br><span class="line">GRANT ALL ON *.* TO &#39;root&#39;@&#39;%&#39;; </span><br><span class="line">ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;你的密码&#39;;</span><br><span class="line"></span><br><span class="line"># 更新权限</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<p>4、更改配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 更改对应的MySQL配置文件&#x2F;etc&#x2F;mysql&#x2F;my.cnf</span><br><span class="line"># 强制ssl验证</span><br><span class="line"># 在[mysqld]下添加如下代码：</span><br><span class="line">require_secure_transport &#x3D; ON</span><br><span class="line"># 指定服务端密钥和证书路径</span><br><span class="line"># 在[mysqld]下添加如下代码：</span><br><span class="line">ssl-ca &#x3D; &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;ca.pem</span><br><span class="line">ssl-cert &#x3D; &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;server-cert.pem</span><br><span class="line">ssl-key &#x3D; &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;server-key.pem</span><br></pre></td></tr></table></figure>
<p>5、重启MySQL服务</p>
<p>6、有时候需要重新生成证书秘钥等，可以执行以下命令重新生成，但是要注意生成目录下不能存在原密钥，否则不会重新生成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成相关证书秘钥等</span></span><br><span class="line">mysql_ssl_rsa_setup --datadir=/usr/<span class="built_in">local</span>/mysql5.7/data/  --uid=root</span><br><span class="line">[root@linux-node <span class="built_in">local</span>]<span class="comment"># ll /usr/local/mysql5.7/data/*.pem                             </span></span><br><span class="line">ca-key.pem        <span class="comment">#CA私钥</span></span><br><span class="line">ca.pem            <span class="comment">#自签CA证书，客户端连接也需要提供    </span></span><br><span class="line">client-cert.pem   <span class="comment">#客户端连接服务器端需要提供的证书文件</span></span><br><span class="line">client-key.pem    <span class="comment">#客户端连接服务器端需要提供的私钥文件</span></span><br><span class="line">private_key.pem   <span class="comment">#私钥/公钥对的私有成员</span></span><br><span class="line">public_key.pem    <span class="comment">#私钥/公钥对的共有成员</span></span><br><span class="line">server-cert.pem   <span class="comment">#服务器端证书文件</span></span><br><span class="line">server-key.pem    <span class="comment">#服务器端私钥文件</span></span><br></pre></td></tr></table></figure>
<p>通过抓包我们可以看点，MySQL的连接已经开启了加密。</p>
<img src="/images/image-20220220023314279.png" alt="image-20220220023314279" style="zoom: 67%;" />
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库 加密</tag>
      </tags>
  </entry>
  <entry>
    <title>linux扩容分区</title>
    <url>/2022/01/06/721ad297.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>网上搜索磁盘分区相关的资料一搜一大把，自己又重新整了一遍主要为了自己再复习一遍，同时整理成自己的东西。</p>
<p>以前一直都是写写应用层代码开发，做一些应用层相关的工作，对于操作系统底层相关的 东西没有太多的接触，最近做了一个升级dpdk的工作跟底层接触比较多，诸如网卡、pci地址，总线相关、cpu相关，大页内存等等，以及后期制作镜像等等，一人分饰几个角色，接触的东西比较多，特意去研究了下相关的技术栈。</p>
<h2 id="MBR与GPT区别"><a href="#MBR与GPT区别" class="headerlink" title="MBR与GPT区别"></a>MBR与GPT区别</h2><ul>
<li>MBR是Master Boot Record的简写，</li>
</ul>
<a id="more"></a>

<img src="/images/image-20220123090236532.png" alt="image-20220123090236532" style="zoom:50%;" />

<p><strong>传统的MBR分区</strong></p>
<p>要了解MBR分区我们需要先对MBR分区的分区结构有一个基本的了解。</p>
<p>​                                                                    Structure of a classical generic MBR</p>
<p>MBR分区的结构在0柱面0扇区，第一个扇区512字节(bytes)是MBR的引导分区。</p>
<p>主引导程序(boot loader)占用446字节，可以安装引导加载程序。</p>
<p>主分区表(partition table): 64 bytes，记录整块磁盘的分区状态，每一个分区使用16字节标识，所以MBR最多是只有4个主分区。如果需要超过4个分区，就需要使用扩展分区。</p>
<img src="/images/image-20220214222307182.png" alt="image-20220214222307182" style="zoom:50%;" />

<p>16字节的分区结构表中，其中总扇区数是4字节</p>
<p>2^32=4294967296</p>
<p>标准扇区大小为512字节</p>
<p>能表示最大的容量为：4294967296*512=2.1990233+12字节</p>
<p>所以MBR最大只能表示2T。</p>
<p>剩下的两个字节是结束标志：0x55AA ，标识MBR分区有效。</p>
<h2 id="GPT分区"><a href="#GPT分区" class="headerlink" title="GPT分区"></a>GPT分区</h2><p>GPT支持多达128个分区，每个分区大小为128字节，分区大小采用8字节的长度存储，所以理论上可支持2^64*512大小。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出块设备的信息</span></span><br><span class="line">lsblk</span><br><span class="line"><span class="comment"># </span></span><br></pre></td></tr></table></figure>




<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p>[1] <a href="https://en.wikipedia.org/wiki/Master_boot_record#Sector_layout">https://en.wikipedia.org/wiki/Master_boot_record#Sector_layout</a></p>
<p>[2] <a href="https://www.mustbegeek.com/difference-between-mbr-and-gpt/">https://www.mustbegeek.com/difference-between-mbr-and-gpt/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>分区</tag>
      </tags>
  </entry>
  <entry>
    <title>代码统计工具</title>
    <url>/2021/12/12/f700c4c8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当我们需要了解统计我们项目或者了解一个项目的代码量的时候，我们往往需要借助一些工具。我比较常使用的就是cloc和loc。</p>
<h2 id="cloc"><a href="#cloc" class="headerlink" title="cloc"></a>cloc</h2><p>cloc 是一个非常好用的代码统计工具，他能计算在多种编程语言中源代码的空白行、注释行和实际行数。下面就介绍基本的安装与使用的方法。</p>
<p>从GitHub下载cloc源码安装，<a href="https://github.com/AlDanial/cloc">下载地址</a>。</p>
<p><img src="/images/image-20211212055328655.png" alt="image-20211212055328655"></p>
<p>执行命令<code>cp cloc /usr/bin</code>将cloc加入到系统可执行程序目录</p>
<p>统计一下，go语言项目的源代码，可以如下执行。<code>cloc src/</code></p>
<a id="more"></a>

<img src="/images/image-20211212055923553.png" alt="image-20211212055923553" style="zoom:67%;" />

<h2 id="loc"><a href="#loc" class="headerlink" title="loc"></a>loc</h2><p>cloc在对代码量比较大的项目的统计速度是比较慢的，所以对于大项目或者统计比较久的项目，我们可以直接安装使用loc。例如，上面统计go语言项目，cloc统计大概需要36秒左右，而loc则是可以达到秒级。</p>
<p>安装方法：<code>cargo install loc</code>，或者直接<a href="https://github.com/cgag/loc/releases">下载地址</a>下载对应版本的二进制文件。</p>
<p>loc的统计结果。</p>
<img src="/images/image-20211212061805321.png" alt="image-20211212061805321" style="zoom:67%;" />

]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>googletest自动化测试框架</title>
    <url>/2021/12/11/7969778.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Googletest 是Google的测试技术 团队开发的一个C++测试框架。它支持任何类型的测试，而不仅仅是单元测试。</p>
<p>一个好的测试框架应该有以下特点。</p>
<ul>
<li>测试应该是独立且可重复的。也就是可以再不同的对象上进行隔离测试，当遇到测试失败的时候，可以单独快速的对其进行调试。</li>
<li>测试应该组织良好，并且能反应所测试的代码的结构。</li>
<li>测试应该是轻量级的和可以重复使用的。</li>
<li>当测试失败时，能提供有关问题尽可能多的错误信息。</li>
<li>测试框架应当将编写测试代码的开发人员从繁琐的事情从解放出来，从而专注于测试的内容。</li>
<li>测试应该很快速。</li>
</ul>
<a id="more"></a>

<p>下面介绍Googletest中的几个宏函数。</p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>Googletest中的断言类似于函数调用宏。通过类或者函数的行为做出断言，失败的时候会打印出对应的源文件和行号的位置。</p>
<p>ASSERT_*版本的宏遇到一个失败的测试案例的时候会产生一个致命的错误，从而终止当前的测试函数。</p>
<p>EXPECT_*版本的宏则遇到一个失败的测试案例的时候则会产生一个不是那么致命的错误，当然也不会终止当前的测试函数。</p>
<p><strong>自定义错误消息：</strong>Googletest是可以自定义错误消息，也很简单，直接使用运算符<code>&lt;&lt;</code>将错误消息重定向到宏中就可以了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ASSERT_EQ(x.size(), y.size()) &lt;&lt; <span class="string">&quot;Vector x and y are of unequal length&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; x.size(); i++)&#123;</span><br><span class="line">  EXPECT_EQ(x.[i], y.[i]) &lt;&lt; <span class="string">&quot;Vector x and y differ at index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用Googletest提供的断言来验证程序的各种行为，完整的断言列表可以参看<a href="https://google.github.io/googletest/reference/assertions.html">断言列表</a>。</p>
<p>常用的以下几个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPECT_EQ(a, b)</span><br><span class="line">ASSERT_EQ(a, b)</span><br><span class="line">EXPECT_TRUE(condition)</span><br><span class="line">EXPECT_FALSE(condition)</span><br></pre></td></tr></table></figure>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>首先在官网下载对应版本的googletest代码，<a href="https://github.com/google/googletest">下载地址</a></p>
<ul>
<li>进入源码目录编译googletest代码<code>cmake CMakeLists.txt</code>。</li>
</ul>
<p><img src="/images/image-20211212042902052.png" alt="image-20211212042902052"></p>
<ul>
<li>执行<code>make</code>对应的Makefile进行编译安装。</li>
<li>将头文件和依赖库加入系统头文件和库路径（或者将对应路径加入环境变量）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp googletest/include/gtest /usr/include</span><br><span class="line">cp lib/* /usr/lib64/</span><br></pre></td></tr></table></figure>
<h3 id="编译测试代码"><a href="#编译测试代码" class="headerlink" title="编译测试代码"></a>编译测试代码</h3><p>sample.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sample.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> false 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">    result *= i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flase return 0, true return 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (n% <span class="number">2</span> == <span class="number">2</span>) <span class="keyword">return</span> n == <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; ; i += <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; n/i) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sample.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __GTEST_SAMPLE_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __GTEST_SAMPLE_H__</span></span><br><span class="line"><span class="comment">// return n!(the factorial of n). for negative n</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>samlpe_test.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sample.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">TEST(FactorialTest, dasd) &#123;</span><br><span class="line">  EXPECT_EQ(<span class="number">1</span>, Factorial(<span class="number">-5</span>)) &lt;&lt; <span class="string">&quot;dasdaddasdasdadasdadad&quot;</span>;</span><br><span class="line">  EXPECT_EQ(<span class="number">1</span>, Factorial(<span class="number">-1</span>));</span><br><span class="line">  EXPECT_GT(Factorial(<span class="number">-10</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEST(FactorialTest1, dasd) &#123;</span><br><span class="line">  EXPECT_EQ(<span class="number">1</span>, Factorial(<span class="number">-5</span>)) &lt;&lt; <span class="string">&quot;dasdaddasdasdadasdadad&quot;</span>;</span><br><span class="line">  EXPECT_EQ(<span class="number">1</span>, Factorial(<span class="number">-1</span>));</span><br><span class="line">  EXPECT_GT(Factorial(<span class="number">-10</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  ::testing::InitGoogleTest(&amp;argc, argv);</span><br><span class="line">  <span class="keyword">return</span> RUN_ALL_TESTS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译命令：<code>g++ sample.c sample_test.c -lgtest -lpthread</code></p>
<p>如果不编译main函数可以使用googletest提供的统一的main函数入口，使用如下编译。</p>
<p><code>g++ sample.c sample_test.c -lgtest -lpthread -lgtest_main</code></p>
<img src="/images/image-20211212045454979.png" alt="image-20211212045454979" style="zoom:67%;" />

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://google.github.io/googletest/reference/assertions.html">https://google.github.io/googletest/reference/assertions.html</a></p>
<p>[2] <a href="https://google.github.io/googletest/primer.html">https://google.github.io/googletest/primer.html</a></p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>单测</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言学习笔记</title>
    <url>/2021/11/18/d44b617d.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Go是Google开发的一种应用型强，编译型，并发型，具有垃圾回收功能的语言，记录学习go语言过程中的一些知识点。</p>
<a id="more"></a>

<h2 id="go-time-包的常用方法"><a href="#go-time-包的常用方法" class="headerlink" title="go time 包的常用方法"></a>go time 包的常用方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">time.Now()	<span class="comment">// 获取当前的时间</span></span><br><span class="line">time.Now().Unix()	<span class="comment">//返回当前的时间戳</span></span><br><span class="line">time.Now().Format(<span class="string">&quot;2021-11-18 00:47:30&quot;</span>)	<span class="comment">//格式化时间</span></span><br><span class="line">time.Now().Add(n).UnixNano()	<span class="comment">//当前时间增加n</span></span><br><span class="line">time.Now().Add(time.Second)	<span class="comment">//当前时间增加一秒</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>位数的时间戳是以秒为单位</span><br><span class="line"><span class="number">13</span>位数的时间戳是以毫秒为单位</span><br><span class="line"><span class="number">19</span>位数的时间戳是以纳秒为单位</span><br></pre></td></tr></table></figure>
<h2 id="获取变量值类型的方法"><a href="#获取变量值类型的方法" class="headerlink" title="获取变量值类型的方法"></a>获取变量值类型的方法</h2><ul>
<li>fmt打印出来</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;type:%T\n&quot;</span>, v)</span><br></pre></td></tr></table></figure>
<ul>
<li>通过反射</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typeof</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> reflect.TypeOf(v).String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过类型断言</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typeof</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> v.(<span class="keyword">type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>常用工具集合</title>
    <url>/2021/10/17/56e0053c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录分享平时工作生活用品用到的一些好用的工具，有个人电脑windows、mac的也有一些手机或者平板上的优秀软件。</p>
<a id="more"></a>

<table>
<thead>
<tr>
<th>工具名</th>
<th>类别</th>
<th>平台</th>
<th>介绍</th>
<th>下载</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>draw.io</td>
<td>画图</td>
<td>window、mac</td>
<td>开源的免费的画图工具，能满足我个人所有的画图需求</td>
<td><a href="https://github.com/jgraph/drawio-desktop/releases">Download</a></td>
<td></td>
</tr>
<tr>
<td>Trpora</td>
<td>编辑器</td>
<td>window、mac</td>
<td>实时预览的Markdown 文本编辑器</td>
<td><a href="https://typora.io/">Download</a></td>
<td></td>
</tr>
<tr>
<td>Margin Note 3</td>
<td>阅读、笔记📒</td>
<td>mac、iPad</td>
<td>超级好用的阅读和笔记工具，可以很好的将笔记只是形成脑图，方便记忆复习等。</td>
<td>App Store</td>
<td></td>
</tr>
<tr>
<td>XMind</td>
<td>思维导图</td>
<td>window、mac</td>
<td>一个全功能的思维导图和头脑风暴软件，为激发灵感和创意而生。</td>
<td><a href="https://www.xmind.cn/download/">Download</a></td>
<td></td>
</tr>
<tr>
<td>glogg</td>
<td>编辑器</td>
<td>window</td>
<td>查看大文件工具，能快速打开很大的日志文件</td>
<td></td>
<td></td>
</tr>
<tr>
<td>印象笔记</td>
<td>笔记本</td>
<td>window</td>
<td>云笔记</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ScreeToGif</td>
<td>录屏</td>
<td>window</td>
<td>录屏小工具</td>
<td><a href="https://www.screentogif.com/">Download</a></td>
<td></td>
</tr>
<tr>
<td>纽约时报</td>
<td>新闻</td>
<td>iphone</td>
<td>新闻时事，财经、科技、政治等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>SFTP Net Drive Free</td>
<td>远程同步工具</td>
<td>window</td>
<td>sftp 同步工具，远程开发可以同步远端文件到本地</td>
<td><a href="https://www.majorgeeks.com/files/details/sftp_net_drive.html">Download</a></td>
<td></td>
</tr>
<tr>
<td>Snipaste</td>
<td>截图工具</td>
<td>window</td>
<td>截图工具</td>
<td><a href="https://www.snipaste.com/">Download</a></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>Go并发编程</title>
    <url>/2021/10/17/2dea6533.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Go语言引入goroutine概念，使得在Go语言并发编程变得非常简单。</p>
<p>通过使用goroutine而不是裸用操作系统的并发机制，且应该使用消息传递来共享内存，而不是使用共享内存来进行通信，所以Go语言让并发编程变得更加的轻盈和安全。</p>
<p>goroutine本质是协程，比线程更加轻盈、更省资源。</p>
<a id="more"></a>

<p>下面是一个简单的例子演示goroutine和channel的使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(values []<span class="keyword">int</span>, resultChan <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">        sum := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _, value := <span class="keyword">range</span> values &#123;</span><br><span class="line">                sum += value</span><br><span class="line">        &#125;</span><br><span class="line">        resultChan &lt;- sum       <span class="comment">// 将计算结果发送到channel中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        values := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;</span><br><span class="line">        resultChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">go</span> sum(values[:<span class="built_in">len</span>(values)/<span class="number">2</span>], resultChan)</span><br><span class="line">        <span class="keyword">go</span> sum(values[<span class="built_in">len</span>(values)/<span class="number">2</span>:], resultChan)</span><br><span class="line">        sum1, sum2 := &lt;- resultChan, &lt;- resultChan</span><br><span class="line"></span><br><span class="line">        fmt.Println(<span class="string">&quot;Result:&quot;</span>, sum1, sum2, sum1+sum2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>vim宝典</title>
    <url>/2021/08/27/aaa6ef00.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp;vim是Linux系统上一款优秀的编辑器，学会使用vim能极大的提升我们在linux系统上对文本的编辑。一般vim打开文件有三种模式，分别是”一般指令模式“，”编辑模式“，”命令行模式“。</p>
<a id="more"></a>

<p><strong>常用的一些操作：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多窗口功能</span></span><br><span class="line">:vsp	       <span class="comment"># 分屏打开，垂直方向。</span></span><br><span class="line">:sp	         <span class="comment"># 水平方向打开</span></span><br><span class="line">Ctrl+ww      <span class="comment"># 切换窗口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键字补全功能</span></span><br><span class="line">Ctrl + n 向下寻找关键字补全。</span><br><span class="line">ctrl + p 向上查找关键字补全。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制粘贴</span></span><br><span class="line">命令模式输入v自由选取模式，选择需要剪切的文字后，按下d就可以进行剪切了。</span><br><span class="line">yy      复制当前行</span><br><span class="line">nyy     n表示大于1的数字，复制n行</span><br><span class="line">dd      剪切当前行</span><br><span class="line">ndd     n表示大于1的数字，剪切n行</span><br><span class="line">fn+--&gt; 按下a </span><br><span class="line"></span><br><span class="line"><span class="built_in">fc</span>: 把光标移到同一行的下一个c字符处</span><br><span class="line">Fc: 把光标移到同一行的上一个c字符处</span><br><span class="line">tc: 把光标移到同一行的下一个c字符前</span><br><span class="line">Tc: 把光标移到同一行的上一个c字符后</span><br><span class="line"></span><br><span class="line">w往右移动一个单词</span><br><span class="line"></span><br><span class="line">b往左移动一个单词</span><br><span class="line"></span><br><span class="line">f行内搜索 </span><br><span class="line"></span><br><span class="line">；行内搜索下一个搜索结果</span><br><span class="line"></span><br><span class="line">比如说有这么个字符串 <span class="string">&quot;testdfat&quot;</span>，假设光标停留在第一个 **t** 位置。</span><br><span class="line"></span><br><span class="line">di<span class="string">&quot;：delete all content inside **&quot;</span>**，结果字符串为<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">dta：delete all content **to** **a**，结果字符串为<span class="string">&quot;at&quot;</span></span><br><span class="line"></span><br><span class="line">dfa：delete all content from current location, until **a** is **found**，结果字符串为<span class="string">&quot;t&quot;</span></span><br><span class="line"></span><br><span class="line">d$: 删除当前到行结尾</span><br><span class="line"></span><br><span class="line">整页翻页 ctrl-f ctrl-b</span><br><span class="line">f就是forword b就是backward</span><br><span class="line"></span><br><span class="line">翻半页</span><br><span class="line">ctrl-d ctlr-u</span><br><span class="line">d=down u=up</span><br><span class="line"></span><br><span class="line">滚一行</span><br><span class="line">ctrl-e ctrl-y</span><br><span class="line"></span><br><span class="line">zz 让光标所在的行居屏幕中央</span><br><span class="line">zt 让光标所在的行居屏幕最上一行 t=top</span><br><span class="line">zb 让光标所在的行居屏幕最下一行 b=bottom </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看编码格式</span></span><br><span class="line">:<span class="built_in">set</span> fileencoding</span><br><span class="line"><span class="comment"># 设置编码格式</span></span><br><span class="line">:<span class="built_in">set</span> fileencoding=utf-8</span><br><span class="line"><span class="comment"># 查看文件格式</span></span><br><span class="line">:<span class="built_in">set</span> fileformat</span><br><span class="line"><span class="comment"># 文件格式转换</span></span><br><span class="line">:<span class="built_in">set</span> fileformat=unix</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除倒数第二个花括号内的所有内容并进入插入模式，对应的‘ci&#123;’</span></span><br><span class="line">c2i&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置每次回车的缩进为 4 个空格</span></span><br><span class="line"><span class="built_in">set</span> shiftwidth=4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 tab 键的宽度为4个空格</span></span><br><span class="line"><span class="built_in">set</span> tabstop=4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置/禁止 tab 键被转换为空格</span></span><br><span class="line"><span class="built_in">set</span> expandtab</span><br><span class="line"><span class="built_in">set</span> noexpandtab</span><br></pre></td></tr></table></figure>
<p><strong>Mac笔记本📒下vim配置</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot; plug</span></span><br><span class="line"><span class="string">call plug#begin()</span></span><br><span class="line"><span class="string">Plug &#x27;joshdick/onedark.vim&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;itchyny/lightline.vim&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;majutsushi/Tagbar&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;preservim/nerdtree&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;fatih/vim-go&#x27;, &#123; &#x27;do&#x27;: &#x27;:GoUpdateBinaries&#x27; &#125;</span></span><br><span class="line"><span class="string">call plug#end()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936</span></span><br><span class="line"><span class="string">set termencoding=utf-8</span></span><br><span class="line"><span class="string">set encoding=utf-8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 自动提示</span><br><span class="line"><span class="built_in">set</span> completeopt=menu</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 语法高亮</span></span><br><span class="line"><span class="string">syntax on</span></span><br><span class="line"><span class="string">&quot;</span> 侦测文件类型</span><br><span class="line">filetype on</span><br><span class="line"><span class="string">&quot; 载入文件类型插件</span></span><br><span class="line"><span class="string">filetype plugin on</span></span><br><span class="line"><span class="string">&quot;</span> 为特定文件类型载入相关缩进文件</span><br><span class="line">filetype indent on</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; show print margin</span></span><br><span class="line"><span class="string">set colorcolumn=79</span></span><br><span class="line"><span class="string">&quot;</span> 设置背景</span><br><span class="line"><span class="string">&quot; set background=dark</span></span><br><span class="line"><span class="string">&quot;</span> 配色方案</span><br><span class="line"><span class="string">&quot;let g:molokai_original = 1</span></span><br><span class="line"><span class="string">&quot;</span><span class="built_in">let</span> g:rehash256 = 1</span><br><span class="line"><span class="string">&quot;Tomorrow-Night-Blue</span></span><br><span class="line"><span class="string">&quot;</span>Tomorrow-Night-Bright</span><br><span class="line"><span class="string">&quot;Tomorrow-Night-Eighties</span></span><br><span class="line"><span class="string">&quot;</span>Tomorrow-Night</span><br><span class="line"><span class="string">&quot;Tomorrow</span></span><br><span class="line"><span class="string">&quot;</span>molokai</span><br><span class="line"><span class="string">&quot;solarized</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">colorscheme onedark</span></span><br><span class="line"><span class="string">let g:lightline = &#123;</span></span><br><span class="line"><span class="string">  \ &#x27;colorscheme&#x27;: &#x27;onedark&#x27;,</span></span><br><span class="line"><span class="string">  \ &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 去掉输入错误的提示声音</span><br><span class="line"><span class="built_in">set</span> noeb</span><br><span class="line"><span class="string">&quot; 启动的时候不显示那个援助索马里儿童的提示</span></span><br><span class="line"><span class="string">set shortmess=atI</span></span><br><span class="line"><span class="string">&quot;</span> 关闭菜单的ALT</span><br><span class="line"><span class="built_in">set</span> winaltkeys=no</span><br><span class="line"><span class="string">&quot; 设定默认解码</span></span><br><span class="line"><span class="string">set fenc=utf-8</span></span><br><span class="line"><span class="string">set fencs=utf-8,usc-bom,euc-jp,gb18030,gbk,gb2312,cp936</span></span><br><span class="line"><span class="string">&quot;</span> 不要使用vi的键盘模式，而是vim自己的</span><br><span class="line"><span class="built_in">set</span> nocompatible</span><br><span class="line"><span class="string">&quot; history文件中需要记录的行数</span></span><br><span class="line"><span class="string">set history=100</span></span><br><span class="line"><span class="string">&quot;</span> 与windows共享剪贴板</span><br><span class="line"><span class="built_in">set</span> clipboard+=unnamed</span><br><span class="line"><span class="string">&quot; 状态行颜色</span></span><br><span class="line"><span class="string">&quot;</span>highlight StatusLine guifg=SlateBlue guibg=Yellow</span><br><span class="line"><span class="string">&quot;highlight StatusLineNC guifg=Gray guibg=White</span></span><br><span class="line"><span class="string">&quot;</span> 取消自动注释</span><br><span class="line"><span class="built_in">set</span> formatoptions=ql</span><br><span class="line"><span class="built_in">set</span> paste</span><br><span class="line"><span class="string">&quot; 不要备份文件（根据自己需要取舍）</span></span><br><span class="line"><span class="string">set backup</span></span><br><span class="line"><span class="string">set backupdir=~/.vimbak</span></span><br><span class="line"><span class="string">&quot;</span> 不要生成swap文件，当buffer被丢弃的时候隐藏它</span><br><span class="line">setlocal noswapfile</span><br><span class="line"><span class="built_in">set</span> bufhidden=hide</span><br><span class="line"><span class="string">&quot; 字符间插入的像素行数目</span></span><br><span class="line"><span class="string">set linespace=0</span></span><br><span class="line"><span class="string">&quot;</span> 增强模式中的命令行自动完成操作</span><br><span class="line"><span class="built_in">set</span> wildmenu</span><br><span class="line"><span class="string">&quot; 在状态行上显示光标所在位置的行号和列号</span></span><br><span class="line"><span class="string">set ruler</span></span><br><span class="line"><span class="string">set rulerformat=%20(%2*%&lt;%f%=\ %m%r\ %3l\ %c\ %p%%%)</span></span><br><span class="line"><span class="string">&quot;</span> 命令行（在状态行下）的高度，默认为1，这里是2</span><br><span class="line"><span class="built_in">set</span> cmdheight=2</span><br><span class="line"><span class="string">&quot; 使回格键（backspace）正常处理indent, eol, start等</span></span><br><span class="line"><span class="string">set backspace=2</span></span><br><span class="line"><span class="string">&quot;</span> 允许backspace和光标键跨越行边界</span><br><span class="line"><span class="built_in">set</span> whichwrap+=&lt;,&gt;,h,l</span><br><span class="line"><span class="string">&quot; 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位）</span></span><br><span class="line"><span class="string">set mouse=a</span></span><br><span class="line"><span class="string">set selection=exclusive</span></span><br><span class="line"><span class="string">set selectmode=mouse,key</span></span><br><span class="line"><span class="string">&quot;</span> 通过使用: commands命令，告诉我们文件的哪一行被改变过</span><br><span class="line"><span class="built_in">set</span> report=0</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 不让vim发出讨厌的滴滴声</span></span><br><span class="line"><span class="string">set noerrorbells</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 在被分割的窗口间显示空白，便于阅读</span><br><span class="line"><span class="built_in">set</span> fillchars=vert:\ ,stl:\ ,stlnc:\</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span> Search</span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span> 高亮显示匹配的括号</span><br><span class="line"><span class="built_in">set</span> showmatch</span><br><span class="line"><span class="string">&quot; 匹配括号高亮的时间（单位是十分之一秒）</span></span><br><span class="line"><span class="string">set matchtime=5</span></span><br><span class="line"><span class="string">&quot;</span> 在搜索的时候忽略大小写</span><br><span class="line"><span class="built_in">set</span> ignorecase</span><br><span class="line"><span class="string">&quot; highligth the search word</span></span><br><span class="line"><span class="string">set hlsearch</span></span><br><span class="line"><span class="string">&quot;</span> 在搜索时，输入的词句的逐字符高亮（类似firefox的搜索）</span><br><span class="line"><span class="built_in">set</span> incsearch</span><br><span class="line"><span class="string">&quot; 输入:set list命令是应该显示些啥？</span></span><br><span class="line"><span class="string">set listchars=tab:\|\ ,trail:.,extends:&gt;,precedes:&lt;,eol:$</span></span><br><span class="line"><span class="string">&quot;</span> 光标移动到buffer的顶部和底部时保持3行距离</span><br><span class="line"><span class="built_in">set</span> scrolloff=3</span><br><span class="line"><span class="string">&quot; 不要闪烁</span></span><br><span class="line"><span class="string">set novisualbell</span></span><br><span class="line"><span class="string">&quot;</span> 我的状态行显示的内容（包括文件类型和解码）</span><br><span class="line"><span class="built_in">set</span> statusline=%F%m%r%h%w\ [FORMAT=%&#123;&amp;ff&#125;]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %&#123;strftime(\&quot;%d/%m/%y\ -\ %H:%M\&quot;)&#125;</span><br><span class="line"><span class="string">&quot; 总是显示状态行</span></span><br><span class="line"><span class="string">set laststatus=2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="string">&quot; Text</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="string">&quot; 自动格式化</span></span><br><span class="line"><span class="string">set formatoptions=tcrqn</span></span><br><span class="line"><span class="string">&quot;</span> 继承前一行的缩进方式，特别适用于多行注释</span><br><span class="line"><span class="built_in">set</span> noautoindent</span><br><span class="line"><span class="string">&quot; 为C程序提供自动缩进</span></span><br><span class="line"><span class="string">set nosmartindent</span></span><br><span class="line"><span class="string">&quot;</span> 使用C样式的缩进</span><br><span class="line"><span class="built_in">set</span> cindent</span><br><span class="line"><span class="string">&quot; 制表符为4</span></span><br><span class="line"><span class="string">set tabstop=4</span></span><br><span class="line"><span class="string">&quot;</span> 统一缩进为4</span><br><span class="line"><span class="built_in">set</span> softtabstop=4</span><br><span class="line"><span class="built_in">set</span> shiftwidth=4</span><br><span class="line"><span class="string">&quot; 不要用空格代替制表符</span></span><br><span class="line"><span class="string">set expandtab</span></span><br><span class="line"><span class="string">&quot;</span> 换行</span><br><span class="line"><span class="built_in">set</span> wrap</span><br><span class="line"><span class="string">&quot; 在行和段开始处使用制表符</span></span><br><span class="line"><span class="string">set smarttab</span></span><br><span class="line"><span class="string">&quot;</span> 用空格键来开关折叠</span><br><span class="line"><span class="built_in">set</span> foldenable</span><br><span class="line"><span class="string">&quot;set foldmethod=marker</span></span><br><span class="line"><span class="string">&quot;</span> show line number</span><br><span class="line"><span class="built_in">set</span> number</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; quickfix</span></span><br><span class="line"><span class="string">&quot;</span> <span class="built_in">set</span> switchbuf=newtab</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span> Session</span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">set sessionoptions=blank,buffers,sesdir,folds,help,options,tabpages,winsize</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="string">&quot; NERDTree</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">noremap &lt;F7&gt; :NERDTreeToggle&lt;CR&gt;</span><br><span class="line"><span class="string">&quot; autocmd BufReadPost *.go NERDTree</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> ============================================================================</span><br><span class="line"><span class="string">&quot; Go</span></span><br><span class="line"><span class="string">&quot;</span> ============================================================================</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; quickfix</span></span><br><span class="line"><span class="string">let g:go_list_type = &quot;</span>locationlist<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> highlight</span><br><span class="line"><span class="built_in">let</span> g:go_highlight_types = 1</span><br><span class="line"><span class="built_in">let</span> g:go_highlight_functions = 1</span><br><span class="line"><span class="built_in">let</span> g:go_highlight_methods = 1</span><br><span class="line"><span class="built_in">let</span> g:go_highlight_structs = 1</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; let g:go_highlight_fields = 1</span></span><br><span class="line"><span class="string">let g:go_highlight_operators = 1</span></span><br><span class="line"><span class="string">let g:go_highlight_extra_types = 1 </span></span><br><span class="line"><span class="string">let g:go_highlight_build_constraints = 1</span></span><br><span class="line"><span class="string">let g:go_highlight_generate_tags = 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="string">&quot; gotags</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">let</span> g:tagbar_width = 45</span><br><span class="line"><span class="built_in">let</span> g:tagbar_autoclose = 0</span><br><span class="line"><span class="built_in">let</span> g:tagbar_autofocus = 0</span><br><span class="line"><span class="built_in">let</span> g:tagbar_show_linenumbers = 0</span><br><span class="line"><span class="built_in">let</span> g:tagbar_show_visibility = 1</span><br><span class="line"><span class="built_in">let</span> g:tagbar_autoshowtag = 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> g:tagbar_type_go = &#123;</span><br><span class="line">            \ <span class="string">&#x27;ctagstype&#x27;</span> : <span class="string">&#x27;go&#x27;</span>,</span><br><span class="line">            \ <span class="string">&#x27;kinds&#x27;</span>     : [</span><br><span class="line">            \ <span class="string">&#x27;p:package&#x27;</span>,</span><br><span class="line">            \ <span class="string">&#x27;i:imports:1&#x27;</span>,</span><br><span class="line">            \ <span class="string">&#x27;c:constants&#x27;</span>,</span><br><span class="line">            \ <span class="string">&#x27;v:variables&#x27;</span>,</span><br><span class="line">            \ <span class="string">&#x27;t:types&#x27;</span>,</span><br><span class="line">            \ <span class="string">&#x27;n:interfaces&#x27;</span>,</span><br><span class="line">            \ <span class="string">&#x27;w:fields&#x27;</span>,</span><br><span class="line">            \ <span class="string">&#x27;e:embedded&#x27;</span>,</span><br><span class="line">            \ <span class="string">&#x27;m:methods&#x27;</span>,</span><br><span class="line">            \ <span class="string">&#x27;r:constructor&#x27;</span>,</span><br><span class="line">            \ <span class="string">&#x27;f:functions&#x27;</span></span><br><span class="line">            \ ],</span><br><span class="line">            \ <span class="string">&#x27;sro&#x27;</span> : <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">            \ <span class="string">&#x27;kind2scope&#x27;</span> : &#123;</span><br><span class="line">            \ <span class="string">&#x27;t&#x27;</span> : <span class="string">&#x27;ctype&#x27;</span>,</span><br><span class="line">            \ <span class="string">&#x27;n&#x27;</span> : <span class="string">&#x27;ntype&#x27;</span></span><br><span class="line">            \ &#125;,</span><br><span class="line">            \ <span class="string">&#x27;scope2kind&#x27;</span> : &#123;</span><br><span class="line">            \ <span class="string">&#x27;ctype&#x27;</span> : <span class="string">&#x27;t&#x27;</span>,</span><br><span class="line">            \ <span class="string">&#x27;ntype&#x27;</span> : <span class="string">&#x27;n&#x27;</span></span><br><span class="line">            \ &#125;,</span><br><span class="line">            \ <span class="string">&#x27;ctagsbin&#x27;</span>  : <span class="string">&#x27;/Users/terrysmao/go/bin/gotags&#x27;</span>,</span><br><span class="line">            \ <span class="string">&#x27;ctagsargs&#x27;</span> : <span class="string">&#x27;-sort -silent&#x27;</span></span><br><span class="line">            \ &#125;</span><br><span class="line"></span><br><span class="line">noremap &lt;F8&gt; :TagbarToggle&lt;CR&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="string">&quot; godef</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string"> let g:go_def_mode = &#x27;godef&#x27;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> &quot;</span> open the definition <span class="keyword">in</span> a new tab</span><br><span class="line"> <span class="built_in">let</span> g:godef_split=0</span><br><span class="line"> </span><br><span class="line"> <span class="string">&quot; want jumps to the same file to move your current cursor instead of splitting</span></span><br><span class="line"><span class="string"> let g:godef_same_file_in_same_window=1</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> &quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"> <span class="string">&quot; lint</span></span><br><span class="line"><span class="string"> &quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"> <span class="built_in">let</span> g:go_metalinter_enabled = [<span class="string">&#x27;vet&#x27;</span>, <span class="string">&#x27;golint&#x27;</span>, <span class="string">&#x27;errcheck&#x27;</span>]</span><br><span class="line"> <span class="built_in">let</span> g:go_metalinter_autosave = 1</span><br><span class="line"> <span class="built_in">let</span> g:go_metalinter_autosave_enabled = [<span class="string">&#x27;vet&#x27;</span>, <span class="string">&#x27;golint&#x27;</span>]</span><br><span class="line"> <span class="built_in">let</span> g:go_metalinter_deadline = <span class="string">&quot;5s&quot;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string"> &quot;</span> goimports</span><br><span class="line"> <span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string"> let g:go_fmt_command = &quot;</span>goimports<span class="string">&quot;</span></span><br><span class="line"><span class="string"> let g:go_fmt_autosave = 1</span></span><br><span class="line"><span class="string"> let g:go_fmt_fail_silently = 1</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> &quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"> <span class="string">&quot; identifier</span></span><br><span class="line"><span class="string"> &quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"> <span class="string">&quot; let g:go_auto_type_info = 1</span></span><br><span class="line"><span class="string"> &quot;</span> <span class="built_in">let</span> g:go_auto_sameids = 1</span><br><span class="line"> <span class="string">&quot; set updatetime=100</span></span><br><span class="line"><span class="string"> &quot;</span> autocmd FileType go nmap &lt;Leader&gt;i &lt;Plug&gt;(go-info)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>不积跬步无以至千里</title>
    <url>/2021/08/22/a4afd44d.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>荀子在《劝学》中有道，”不积跬步，无以至千里，不积小流无以成江海“，我们需要不断的积累自己遇到的解决过的一些问题，这样久而久之我们才能会掌握的越来越丰富的东西。</p>
<ul>
<li>东西比较咋还不成系统，暂时先记录下来。</li>
<li>方便再次遇到同样的问题方便查找。</li>
</ul>
<h1 id="2021-08-22"><a href="#2021-08-22" class="headerlink" title="2021.08.22"></a>2021.08.22</h1><p><code>__attribute__((unused))</code> 变量属性（variable attribute）</p>
<p>&ensp;&ensp;&ensp;&ensp;通常，如果变量被声明但是从未被引用的话，C编译器则是会报出警告⚠️（warnning）。这个属性就是通知编译器你希望某个变量未使用，并且告诉它未使用的时候不要发出警告。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>此变量属性是 ARM 编译器支持的 GNU 编译器扩展。</p>
<p>This variable attribute is a GNU compiler extension that the ARM compiler supports.</p>
</blockquote>
<p><strong>示例1：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Variable_Attribute_unused_0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> aStatic = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> aUnesed __attribute__((unused));</span><br><span class="line">    <span class="comment">// __attribute__((unused)) int aUnesed;</span></span><br><span class="line">    <span class="keyword">int</span> bUnused;</span><br><span class="line">    aStatic++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此示例中，编译器警告<code>bUnused</code>已声明但从未引用过的 ，但不会警告<code>aUnused</code>.</p>
<p>参考：<a href="https://www.keil.com/support/man/docs/armcc/armcc_chr1359124982981.htm">https://www.keil.com/support/man/docs/armcc/armcc_chr1359124982981.htm</a></p>
<a id="more"></a>

<h1 id="2021-11-04"><a href="#2021-11-04" class="headerlink" title="2021.11.04"></a>2021.11.04</h1><ul>
<li>tcudmp过滤条件抓vlan数据包问题。</li>
</ul>
<p>以前在处理现场项目的时候发现，客户的环境带有vlan数据头的数据包在使用tcpdump加上某个过滤条件之后（比如端口，或者IP）就会出现抓取不到数据包的情况，但是全抓不加过滤条件则是可以正常抓取，当时没在意就过去了。前两天又遇到了，同样的情况决定探一番究竟，在国内翻滚了一圈CSDN全是你抄我我抄你清一色的回答，最终无奈只能查阅<a href="https://www.tcpdump.org/manpages/pcap-filter.7.html">官方文档</a>中找到了答案。</p>
<p>vlan [vlan_id]<br>True if the packet is an IEEE 802.1Q VLAN packet. If the optional vlan_id is specified, only true if the packet has the specified vlan_id. Note that the first vlan keyword encountered in an expression changes the decoding offsets for the remainder of the expression on the assumption that the packet is a VLAN packet. The <code>vlan [vlan_id]</code> keyword may be used more than once, to filter on VLAN hierarchies. Each use of that keyword increments the filter offsets by 4.<br>For example:<br>vlan 100 &amp;&amp; vlan 200<br>filters on VLAN 200 encapsulated within VLAN 100, and<br>vlan &amp;&amp; vlan 300 &amp;&amp; ip<br>filters IPv4 protocol encapsulated in VLAN 300 encapsulated within any higher order VLAN.</p>
<ul>
<li>在过滤vlan报文的过程中，需要加上vlan关键字配合过滤，如果是多层vlan则需要多个vlan关键字配合，例如<code>tcpdump -ieth0 vlan &amp;&amp; port 3306 </code>。</li>
<li>对指定的vlan ID的数据包进行过滤则是可以<code>tcpdump -ieth0 vlan 200 &amp;&amp; port 3306</code>。</li>
</ul>
<h2 id="2021-11-13"><a href="#2021-11-13" class="headerlink" title="2021.11.13"></a>2021.11.13</h2><ul>
<li>Gcc编译native选项问题</li>
</ul>
<p>编译dpdk的时候，有编译不过的地方，按照网上文章指导开启了native选项，然后换了个环境的时候，竟然报错起不来了报SSE4_1指令集不支持，网上查了相关的资料原来才明白其中的原委，官方解释有如下。</p>
<p>‘native’</p>
<p>This selects the CPU to generate code for at compilation time by determining the processor type of the compiling machine. Using -march=native enables all instruction subsets supported by the local machine (hence the result might not run on different machines). Using -mtune=native produces code optimized for the local machine under the constraints of the selected instruction set.</p>
<p>大致意思就是说编译的时候会根据编译环境所支持的CPU指令集进行编译优化，所以如果我们开启了native选项，但是如果在和我们编译环境不一致的运行环境上可能会出现cpu指令集不支持从而导致起不来的现象。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] <a href="https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html">https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html</a></p>
<p>[2] <a href="https://gcc.gnu.org/onlinedocs/">https://gcc.gnu.org/onlinedocs/</a></p>
<p>[3] <a href="https://www.cxyzjd.com/article/zangchang/80084257">https://www.cxyzjd.com/article/zangchang/80084257</a></p>
]]></content>
  </entry>
  <entry>
    <title>对称RSS</title>
    <url>/2021/08/19/88d0fd78.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp;今天遇到一个很有趣的问题，dpdk网卡绑定了两个core，同一个会话（TCP连接）的数据包，不同方向的两边报文被分配到了两个不同的core上处理，导致绑定在core上下文中的信息直接是获取不到，查找了相关的资料，才找到了相关的原因和解决方法。</p>
<a id="more"></a>

<p>&ensp;&ensp;&ensp;&ensp;负载均衡是多队列网卡中最常见的应用，其含义就是讲负载均衡分摊到多个执行单元上。首先需要先了解什么事RSS。RSS（Receive-Side-Scaling，接收方扩展)，他是和硬件相关联的，必须要有网卡硬件进行支持，RSS把数据包分配到不同的队列中，其中的哈希值的计算公式直接是在硬件中完成的，也是可以定制修改的。RSS就是一种网卡驱动的技术，  通过RSS我们可以将多核处理系统中跨越多个处理器（core）的网络收包能力高效的分配。</p>
<p>&ensp;&ensp;&ensp;&ensp;DPDK由于天然的支持队列网卡，也可以很简便的将接收与发送的队列指定给某一应用，同时，DPDK的轮询模式的驱动也提供了配置RSS的接口。</p>
<p>RSS算法通常使用<code>Toeplitz哈希函数</code>，此函数需要两个输入：<strong>静态哈希密钥和从数据包中提取的元组</strong>。问题在于，DPDK中使用的默认哈希密钥（也是Microsoft推荐的密钥）不会将对称流分配给同一CPU。</p>
<p>{srcip=1.1.1.1   distip=2.2.2.2   srcport=1111  distport=2222 }</p>
<p>{srcip=2.2.2.2   distip=1.1.1.1   srcport=2222  distport=1111 }<br>上面的数据包处于同一个TCP连接，但是经过hash之后不一定得到一样的hash结果，对于这种情况我们可以通过更改hash键来实现对称</p>
<p>RSS。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static uint8_t hash_key [RSS_HASH_KEY_LENGTH] &#x3D; &#123;</span><br><span class="line">    0x6D，0x5A，0x6D，0x5A，0x6D，0x5A，0x6D，</span><br><span class="line">    0x5A，0x6D，0x5A，0x6D，0x5A，0x6D，0x5A，</span><br><span class="line">    0x6，0x6，0x6，0x6A 0x5A，0x6D，0x5A，0x6D，</span><br><span class="line">    0x5A，0x6D，0x5A，0x6D，0x5A，0x6D，0x5A，</span><br><span class="line">    0x6D，0x5A，0x6D，0x5A，0x6D，0x5A，0x6D，0x5A，</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DPDK</category>
      </categories>
  </entry>
  <entry>
    <title>问题记录</title>
    <url>/2021/08/18/1ddb9d4e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp;记录一些问题。</p>
<a id="more"></a>

<h1 id="github报错remote-Support-for-password-authentication-was-removed-on-August-13-2021-Please-use-a-personal-access-token-instead"><a href="#github报错remote-Support-for-password-authentication-was-removed-on-August-13-2021-Please-use-a-personal-access-token-instead" class="headerlink" title="github报错remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead."></a>github报错remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.</h1><p>解决方法：将token直接加入到连接中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote set-url origin https://&lt;your_token&gt;@github.com/&lt;USERNAME&gt;/&lt;REPO&gt;.git</span><br><span class="line">git remote set-url origin https://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@github.com/HDMLOVE/libpcap_demo.git/</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>GDB调试</title>
    <url>/2021/07/17/349ba270.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp;GDB是GUN（GUN is not unix）开源组织发布的，Unix/Linux操作系统下的一款基于命令行方式交互的调试工具。GDB支持调试多种语言，比如C/C++、Go、Objective-C、Pascal等等，但是最强大的、用的最多的是调试C/C++程序，作为一个C/C++程序员，要是你不会使用GDB，那可能都没脸出门了。</p>
<p>说明：参数 &lt;program&gt; 不包括符号“&lt;&gt;”。</p>
<a id="more"></a>

<ul>
<li><p>启动调试程序</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 可以直接从一个可执行的程序和core文件开始。</span><br><span class="line">gdb &lt;program&gt; &lt;corefile&gt;</span><br><span class="line"></span><br><span class="line"># 如果需要调试正在运行的进程。</span><br><span class="line">gdb program &lt;processId&gt;</span><br><span class="line">gdb -p &lt;processId&gt;</span><br><span class="line">gdb attach -p &lt;processId&gt;</span><br><span class="line"></span><br><span class="line">gdb -q                          # 关闭启动信息</span><br><span class="line">set confirm off                 # 关闭退出时确认退出提示信息</span><br></pre></td></tr></table></figure></li>
<li><p>设置启动参数，例如<code>&#39;-c 1 -t 100&#39;</code>。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 启动时直接指定参数&#x27;-c 1 -t 100&#x27;。</span><br><span class="line">gdb  -args &lt;program&gt; -c 1 -t 100 </span><br><span class="line"></span><br><span class="line"># 通过交互方式设置参数。</span><br><span class="line">(gdb) set args -c 1 -t 100</span><br><span class="line">(gdb)</span><br><span class="line">(gdb) show args </span><br><span class="line">Argument list to give program being debugged when it is started is &quot;-c 1 -t 100&quot;.</span><br><span class="line"></span><br><span class="line"># 运行时指定。</span><br><span class="line">gdb) run -c 1 -t 100</span><br><span class="line">Starting program: /root/lpyuan/Hera_tool/webbench -c 1 -t 100</span><br><span class="line">webbench: Missing URL.</span><br><span class="line">(gdb) show args</span><br><span class="line">Argument list to give program being debugged when it is started is &quot;-c 1 -t 100&quot;.</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure></li>
<li><p>运行信息</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">start                    # 指令执行到main()函数起始的位置，类似于在main函数设置一个断点。</span><br><span class="line">r (run)                  # 运行程序，程序会在第一个断点处停止，否则则是一直执行到结束🔚。</span><br><span class="line">c (continue)             # 继续执行，直到下一个断点处（或者直接到运行结束）</span><br><span class="line">n (next)                 # 单步调试，下一步，遇到函数调用不会进入该函数，默认走一步，也可指定步数，如3步：n 3。</span><br><span class="line">s (step)                 # 单步调试，与next类似，区别在于遇到函数调用会直接跳入，也可以执行步数，如3步：s 3。</span><br><span class="line">until                    # 不想在循环里面单步调试，可以使用该指令直接运行程序直到退出循环体。</span><br><span class="line">until+行号                # 直接运行到指定行，不仅仅可以跳出循环。</span><br><span class="line">finish                   # 运行程序，接收当前函数调用并完成返回🔙，并且打印出函数返回时候的对战地址和返回值、参数等信息。</span><br><span class="line">call func(args)          # 调用函数中的可见函数，并传递参数，函数调用也可以使用print。</span><br><span class="line">where/bt                 # 显示当前函数调用栈信息。</span><br><span class="line">up/down                  # 改边调用栈的深度，可以选择哪一帧（frame）。</span><br><span class="line">info functions           # 显示当前进程的函数符号</span><br><span class="line">info program             # 查看当前进程所处的状态，是否在运行，进程号，被中断暂停的原因等</span><br><span class="line">infi signals             # 查看程序对应的中断信号处理方式。</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong><em>Note</em>:</strong> 程序在执行的过程中如果使用run（r）或者start指令，则表示重启启动程序。</p>
</blockquote>
</li>
<li><p>断点调试</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">b n (break num)           # 在第n行设置断点，也可以指定某个文件，如：b test.c:666</span><br><span class="line">b func                    # 在某个函数入口设置断点，如：b benchcore</span><br><span class="line">info b (info breakpoints) # 显示当前程序的断点设置情况。</span><br><span class="line">b func if a&gt;b             # 条件断点设置，如果a&gt;b成立，则是触发断点。</span><br><span class="line">disable n                 # 暂定第n个断点。</span><br><span class="line">enable n                  # 启用第n个断点。</span><br><span class="line">delete n                  # 删除第n个断点。</span><br><span class="line">delete breakpoints        # 清除程序目前设置的所有的断点。</span><br><span class="line">tb test.c:15 (tbreak)     # 临时断点，断点只生效一次，触发后会自动删除，查看断点列表触发后不存在。</span><br><span class="line">ignore bnum count         # 忽略断点，接下来的count次经过该断点都不会触发，直到count+1次时候会触发次断点。</span><br></pre></td></tr></table></figure></li>
<li><p>窗口相关</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">layout                    # 分割窗口，如果有代码的话可以一遍看代码一遍跟踪。</span><br><span class="line">layout src (layout source)# 显示源代码窗口。</span><br><span class="line">layout asm                # 显示反汇编的窗口</span><br><span class="line">layout regs               # 显示源代码、反汇编、和CPU寄存器的窗口。</span><br><span class="line">layout split              # 显示源代码和反汇编的窗口。</span><br><span class="line">Ctrl+L                    # 刷新窗口，类似于clear、cls等清屏操作。</span><br></pre></td></tr></table></figure></li>
<li><p>打印相关</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">print 表达式              # print 后面可以加任何有效的表达式，可以是一个数字、变量、甚至函数调用。</span><br><span class="line">print 5                  # 打印值5。</span><br><span class="line">print a=5                # 给a赋值5，然后打印出a的值。</span><br><span class="line">print ++a                # 将a变量的值自增，并打印出来。</span><br><span class="line">print func(66)           # 调用函数func，并传递参数值66。</span><br><span class="line">print func(a)            # 将变量a的值作为参数，传递给func函数。</span><br><span class="line">i locals (info locals)   # 查询当前堆栈页中所有的变量。</span><br><span class="line">whatis                   # 查询变量或者函数。</span><br></pre></td></tr></table></figure></li>
<li><p>查看源代码</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">l (list)                 # 显示程序源代码，默认显示10行</span><br><span class="line">l n (list num)           # 显示当前文件以n行前后10行代码，如：l 10</span><br><span class="line">l func                   # 列出函数名所在函数的代码，如：l benchcore</span><br><span class="line">list                     # 重复执行上一个list命令，输出下边的内容。</span><br></pre></td></tr></table></figure></li>
<li><p>gdb配置文件</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 在使用gdb的时候，如果我们每次进去之后都要重新配置启动参数、断点等繁琐的信息，那么效率就很低。</span><br><span class="line"># 我们可以通过配置文件，可以将这些一次性配置好，避免重复性工作。</span><br><span class="line"># 当gdb启动时，会读取HOME和当前目录下的配置文件，然后直接一次性执行里面的指令，这个文件通常为&#x27;.gdbinit&#x27;。</span><br><span class="line"># 如果需要在当前目录下配置.gdbinit文件，则还需要在HOME（~）目录下配置.gitinit文件，并输入以下指令，否则gdb路径保护会报错。</span><br><span class="line">set auto-load safe-path /</span><br><span class="line"># 当然我们也可以自己写一个配置文件，但是gdb不会自动读取，需要我们通过&#x27;source 自定义脚本&#x27;手动导入。</span><br><span class="line">[root@localhost Hera_tool]# gdb webbench</span><br><span class="line">GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-115.el7</span><br><span class="line">Copyright (C) 2013 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;...</span><br><span class="line">Reading symbols from /root/lpyuan/Hera_tool/webbench...(no debugging symbols found)...done.</span><br><span class="line">(gdb) source lpyuanGdb </span><br><span class="line">Breakpoint 1 at 0x400f7f</span><br><span class="line">(gdb) show args</span><br><span class="line">Argument list to give program being debugged when it is started is &quot;-c 1 -t 100 http://lpyuan.club&quot;.</span><br><span class="line">(gdb) show b</span><br><span class="line">Ambiguous show command &quot;b&quot;: backtrace, basenames-may-differ, breakpoint, build-id-core-loads, build-id-verbose.</span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000400f7f &lt;Socket&gt;</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印STL容器中的内容</span></span><br><span class="line">python</span><br><span class="line">import sys</span><br><span class="line">sys.path.insert(0, <span class="string">&quot;/home/xmj/project/gcc-trunk/libstdc++-v3/python&quot;</span>)</span><br><span class="line">from libstdcxx.v6.printers import register_libstdcxx_printers</span><br><span class="line">register_libstdcxx_printers (None)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存历史命令</span></span><br><span class="line"><span class="built_in">set</span> <span class="built_in">history</span> filename ~/.gdb_history</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">history</span> save on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录执行gdb的过程</span></span><br><span class="line"><span class="built_in">set</span> logging file ./.gdblog.txt</span><br><span class="line"><span class="built_in">set</span> logging on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出时不显示提示信息</span></span><br><span class="line"><span class="built_in">set</span> confirm off</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照派生类型打印对象</span></span><br><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> object on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印数组的索引下标</span></span><br><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> array-indexes on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每行打印一个结构体成员</span></span><br><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> pretty on</span><br><span class="line"></span><br><span class="line"><span class="comment">#  调试子进程</span></span><br><span class="line"><span class="built_in">set</span> follow-fort-mode child</span><br><span class="line"><span class="built_in">set</span> detach-on-fork on</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置运行参数</span></span><br><span class="line"><span class="built_in">set</span> args -c 1 -t 100 http://lpyuan.club</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置断点</span></span><br><span class="line">b Socket</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>生成gdb调试日志。使用gdb调试时候，我们可以将我们的调试的过程记录下来，方便后面或者别人帮忙一起分析。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">set logging file filename # gdb的默认日志文件为gdb.txt，我们也可以通过命令更改日志文件名。</span><br><span class="line">set logging on            # 开启日志记录。</span><br></pre></td></tr></table></figure></li>
<li><p>watch 监视内存断点</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 设置一个监视点，一旦表达式的值发生改变，立马强行终止当前调式程序，比较监视a变量，watch a。</span><br><span class="line">watch 表达式</span><br><span class="line">1. watch 变量的类型。</span><br><span class="line">(1)整形变量。</span><br><span class="line">	int a; </span><br><span class="line">	watch a:  # 监视变量a的值。</span><br><span class="line">(2)指针变量</span><br><span class="line">	char *a;</span><br><span class="line">	watch a:  # 此时监视的a变量这个地址，不是a执行的地址的值，查看的是*(&amp;a)。</span><br><span class="line">	watch *a: # 此时监视a所指向的地址的值的变化情况。</span><br><span class="line">(3)数组类型。</span><br><span class="line">	watch 一个数字或者内存区间。</span><br><span class="line">	char buf[128];</span><br><span class="line">	watch buf: # 对数组的128个值进行监视，此时采用的是软中断，不是采用的硬件断点，软中断方式去检查内存变量是比较耗费CPU的。</span><br><span class="line">	如果指明了精确的地址，则是采用的是硬件中断。</span><br><span class="line">	</span><br><span class="line">2. 当设置的监视点是一个局部变量时，局部变量无效后，则监视点也无效。</span><br><span class="line">3. 与watch命令相似的还有两个命令</span><br><span class="line">(1)rwatch   # 只要程序中出现读取目标变量（表达式）的值得操作，程序就会立即停止运行。</span><br><span class="line">(2)awatch   # 只要程序中出现读取目标变量（表达式）的值或者改变值得操作，程序就会立即停止运行。</span><br><span class="line">	</span><br></pre></td></tr></table></figure></li>
<li><p>加载带有符号信息可执行文件</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 调试没有符号信息的可执行文件，可以编译一个带有调试信息版本的程序。</span><br><span class="line"># 通过&#x27;file&#x27;参数加载符号，对其进行调试。</span><br><span class="line">(gdb) file webbench1 </span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[root@localhost Hera_tool]# gdb webbench</span><br><span class="line">GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-115.el7</span><br><span class="line">Copyright (C) 2013 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;...</span><br><span class="line">Reading symbols from /root/lpyuan/Hera_tool/webbench...(no debugging symbols found)...done.</span><br><span class="line">(gdb) file webbench1 </span><br><span class="line">Reading symbols from /root/lpyuan/Hera_tool/webbench1...done.</span><br><span class="line">(gdb) directory ../</span><br><span class="line">Source directories searched: /root/lpyuan/Hera_tool/..:$cdir:$cwd</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>多进程调试</p>
<table>
<thead>
<tr>
<th>follow-fork-mode</th>
<th>detach-on-fork</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>parent</td>
<td>on</td>
<td>单独调试主进程（默认情况下）</td>
</tr>
<tr>
<td>child</td>
<td>on</td>
<td>单独只调试子进程</td>
</tr>
<tr>
<td>parent</td>
<td>off</td>
<td>同时调试两个进程，<code>gdb</code>跟随主进程，子进程阻塞(block)在<code>fork</code>的位置</td>
</tr>
<tr>
<td>child</td>
<td>off</td>
<td>同时调试两个进程，<code>gdb</code>跟随子进程，主进程阻塞(block)在<code>fork</code>的位置</td>
</tr>
</tbody></table>
<p>GDB调试多进程的时候，如果该进程<code>fork()</code>出了一个子进程，那么GDB还是会继续调试当前进程不会自动的切换子进程调试，如果     我们在子进程里面设置了断点，那么子进程就会收到一个<code>SIGTRAP</code>信号并终止。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;...</span><br><span class="line">Reading symbols from /root/lpyuan/Hera_tool/webbench...(no debugging symbols found)...done.</span><br><span class="line">(gdb) set follow-fork-mode child </span><br><span class="line">(gdb) set detach-on-fork on</span><br><span class="line">(gdb) set args -c -t 100 http://lpyuan.club </span><br><span class="line">(gdb) show follow-fork-mode </span><br><span class="line">Debugger response to a program call of fork or vfork is &quot;child&quot;.</span><br><span class="line">(gdb) show detach-on-fork   </span><br><span class="line">Whether gdb will detach the child of a fork is on.</span><br><span class="line">(gdb) show args</span><br><span class="line">Argument list to give program being debugged when it is started is &quot;-c -t 100 http://lpyuan.club&quot;.</span><br><span class="line">(gdb) run</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong><em>Note</em>:</strong> </p>
<ol>
<li><p>交互模式下，重复回车则是重复执行上一个命令。</p>
</li>
<li><p>cgdb是一个更加强大的调试工具，交互命令和gdb一样，熟练使用gdb的同学也可以很快的上手。</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://www.gnu.org/software/gdb/documentation/">https://www.gnu.org/software/gdb/documentation/</a></p>
<p>[2] <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a></p>
<p>[3] <a href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/index.html">https://wizardforcel.gitbooks.io/100-gdb-tips/content/index.html</a></p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>调试工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Git使用指南</title>
    <url>/2021/06/10/74add858.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Git是什么"><a href="#Git是什么" class="headerlink" title="Git是什么"></a>Git是什么</h2><p>Git是目前世界上最先进的一款分布式版本控制系统，可以对我们的代码进行很好的版本管理。全球最大同性交流网站（Github）是程序员必逛的网站，学会使用Git是一个合格成熟的程序员必须掌握的技能之一，本篇文章主要介绍了Git的一个基本原理和常用的使用技巧。</p>
<p>如果使用Window，有一个Git版本控制客户端TortoiseGit非常好用，特别是像我以前使用惯了TortoiseSvn的人来说。</p>
<p>工具推荐：<a href="https://tortoisegit.org/download/">下载地址</a>。</p>
<p>Mac下还没找到特别好用的，暂时就先不推荐了^_^</p>
<a id="more"></a>

<h2 id="Git的原理"><a href="#Git的原理" class="headerlink" title="Git的原理"></a>Git的原理</h2><p>Git的代码管理原理可以简化如下图。</p>
<img src="/images/image-20211017101514515.png" alt="image-20211017101514515" style="zoom:50%;" />

<p>1、我们在工作目录编辑代码，当觉得OK的时候我们可以<code>git add files</code>将我们的代码提交大暂存区。</p>
<p>2、然后继续编辑代码，如果没有问题我们可以将一个功能或者特性<code>git commit</code>提交到版本中，如果发现有问题我们可以<code>git reset</code>回退代码。</p>
<p>3、如果测试没问题，我们可以将代码提交到远程仓库。</p>
<p><strong>代码提交规范</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">feat:新功能</span><br><span class="line">fix:修复bug</span><br><span class="line">docs:文档改变</span><br><span class="line">style:代码格式改变</span><br><span class="line">refactor:某个功能重构</span><br><span class="line">perf:性能优化</span><br><span class="line"><span class="built_in">test</span>:增加测试</span><br><span class="line">build:改变了build功能，如grunt变成了npm</span><br><span class="line">revert:撤销上一次commit</span><br><span class="line">chore:构建过程或者辅助功能的变动</span><br></pre></td></tr></table></figure>
<p><strong>Git的一些基本操作</strong></p>
<ul>
<li><p>初始化一个本地仓库。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li>
<li><p>添加远程仓库。有时候你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且将本地仓库同步到远程Git仓库。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:HDMLOVE/Git_test.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看分支</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看远程分支</span></span><br><span class="line">git branch -av</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前分支远程地址</span></span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure></li>
<li><p>下载（克隆）远程仓库代码</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:HDMLOVE/Git_test.git</span><br></pre></td></tr></table></figure></li>
<li><p>查看代码提交记录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看提交历史记录</span></span><br><span class="line">git <span class="built_in">log</span> --graph</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看代码详细修改</span></span><br><span class="line">git show HEAD(commitid)</span><br></pre></td></tr></table></figure></li>
<li><p>切换/创建分支</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到Test分支，本地分支不存在该分支，则会自动从远端仓库下载分支代码。</span></span><br><span class="line">git checkout Test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从master分支创建新的分支Git_test并切换到Git_test分支。</span></span><br><span class="line">git checkout -b Git_test master</span><br></pre></td></tr></table></figure></li>
<li><p>提交代码文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交某个&lt;file&gt;文件到暂存区。</span></span><br><span class="line">git add &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交当前目录下已经跟踪到的所有文件到暂存区</span></span><br><span class="line">git add .</span><br><span class="line">git add -u</span><br></pre></td></tr></table></figure></li>
<li><p>配置相关信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前用户全局（global）配置信息</span></span><br><span class="line">git config --global --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前仓库配置信息</span></span><br><span class="line">git config --<span class="built_in">local</span> --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># git status 没有颜色区分提示问题 </span></span><br><span class="line"><span class="comment"># Git显示颜色设置，也可以对其进行单独配置。</span></span><br><span class="line">git config --global color.ui <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># git diff 中文显示乱码问题</span></span><br><span class="line">git config --global core.quotepath <span class="literal">false</span>          <span class="comment"># 显示 status 编码</span></span><br><span class="line">git config --global gui.encoding utf-8            <span class="comment"># 图形界面编码</span></span><br><span class="line">git config --global i18n.commit.encoding utf-8    <span class="comment"># 提交信息编码</span></span><br><span class="line">git config --global i18n.logoutputencoding utf-8  <span class="comment"># 输出 log 编码</span></span><br><span class="line"><span class="built_in">export</span> LESSCHARSET=utf-8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置用户名、邮箱等信息</span></span><br><span class="line">git config --global user.name <span class="string">&quot;张三&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;helloworl@outlook.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置完毕后可以通过下面命令来修正本次提交所用的用户身份信息</span></span><br><span class="line">git commit --amend --reset-author</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>配置免密提交</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成ssh key</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;helloworld@sangfor.com&quot;</span> -b 4096</span><br><span class="line"><span class="comment"># 上传到git服务器上或者添加ssh key</span></span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></li>
<li><p>修改某个commit</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改最近的一次的commit信息</span></span><br><span class="line">git rebase --amend</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示最近的5次修改</span></span><br><span class="line">git rebase -i HEAD~5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改完成后，强制推送到远程分支</span></span><br><span class="line">git push origin &lt;master&gt; --force   &lt;==&gt;  git push master -f</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除分支</p>
<p>当我们不需要某个分支的时候我们可以使用以下命令进行分支删除，但是当我们处于该分支的时候是无法删除的，所以我们第一步应该是先使用<code>git checkout &lt;branch&gt;</code>切换到一个其他的分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除本地分支</span></span><br><span class="line">git branch -d &lt;branch&gt;	<span class="comment"># 删除分支（本地还有代码没推送到本地分支时候是无法删除的）</span></span><br><span class="line">git branch -D &lt;branch&gt; 	<span class="comment"># 强制删除分支（本地代码没有推送到远程也可以删除）</span></span><br></pre></td></tr></table></figure></li>
<li><p>分支重命名</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将分支old_branch重命名为new_branch</span></span><br><span class="line">git branch -m old_branch new_branch</span><br></pre></td></tr></table></figure></li>
<li><p>仓库太大下载单个分支</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git </span><br></pre></td></tr></table></figure></li>
<li><p>更新或者恢复某一个文件或者目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以直接使用命令对其进程恢复，或者先删除掉再使用该命令进行恢复</span></span><br><span class="line">git checkout -- test.c</span><br><span class="line">git checkout -- testdir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销暂存区的文件，git add 之后想要撤销，恢复到某个提交的版本（HEAD）</span></span><br><span class="line">git reset --hard HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销所有则执行如下命令</span></span><br><span class="line">git reset </span><br></pre></td></tr></table></figure></li>
<li><p>查看修改比较</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 工作区（work dict）和暂存区（stage）的比较</span></span><br><span class="line">git diff </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂存区（stage）和分支（所在）的比较</span></span><br><span class="line">git diff --cache</span><br></pre></td></tr></table></figure></li>
<li><p>忽略提交文件和类型</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 项目中添加文件可以忽略不需要提交的文件和类型</span></span><br><span class="line">.gitignore</span><br><span class="line">内容为：</span><br><span class="line">*.sh</span><br><span class="line">*.d</span><br><span class="line">*.o</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><strong>常见问题</strong></p>
<p>（1）linux普通用户无法使用git clone 克隆代码问题，一直报口令认证失败，公钥等其他问题均已排查过。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解决方案：修改tty权限。</span></span><br><span class="line">ll /dev/tty</span><br><span class="line">chmod 777 /dev/tty</span><br></pre></td></tr></table></figure>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://www.conventionalcommits.org/en/v1.0.0/">https://www.conventionalcommits.org/en/v1.0.0/</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>笔记</title>
    <url>/2021/05/16/61622d0e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="程序要的能力"><a href="#程序要的能力" class="headerlink" title="程序要的能力"></a>程序要的能力</h2><p>一个优秀的工程师应该具备哪些东西？</p>
<p>1、技术能力（不依靠Google能独自解决的能力）</p>
<p>2、产品能力–&gt;产品–&gt;项目</p>
<p>3、管理能力–&gt;</p>
<h2 id="dpdk"><a href="#dpdk" class="headerlink" title="dpdk"></a>dpdk</h2><p>Kni（kernel network interface）的定义是指内核网络接口，网卡过来的数据都被映射到内存中，我们可以直接对这些个数据进行处理，但是对于一些的数据我们不需要对其进行处理。</p>
<p>比如对于这个协议的数据我们只需要对udp进行处理，但是对于TCP 的数据包我们还是需要借助内核，这个时候我们就分为了两条通道，一个是我们自己用户空间的协议栈进行护理，另一个我们把数据重新丢回去给内核进行处理，kni就是内核提供的接口。</p>
<h3 id="dpdk应该学习那些东西"><a href="#dpdk应该学习那些东西" class="headerlink" title="dpdk应该学习那些东西"></a>dpdk应该学习那些东西</h3><p>1、dpdk的接口的熟悉</p>
<p>​    a.dpdk接收网卡数据</p>
<p>​    b.dpdk发送数据</p>
<p>​    c.dpdk基础上实现arp协议，tcp的测试，实现tcp协议栈，虚拟路由器，虚拟的交换机。</p>
<p>2、在这些基础接口上的应用，openswitch，vpp，snabb，pktgen，自己实现协议栈。</p>
<p>3、dpdk的原理与虚拟化技术。</p>
]]></content>
  </entry>
  <entry>
    <title>DPDK环境搭建</title>
    <url>/2021/05/11/d774139d.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp;Dpdk全称为（Data Plane Development Kit），字面上看解释其实就是一款数据面软件开发套件，究其本质，也就是一些底层的软件库组成。是一个高性能网络数据宝处理框架。我最初开始接触Dpdk的时候一脸懵逼，没有任何人教授，只能在网络上一点点啃，国内外各种资料慢慢磨，慢慢摸索出一些门道，现在还是很菜，但是至少有迹可循了！！记录下dpdk环境搭建开发的一个过程，帮助下有缘的小白们入门。</p>
<a id="more"></a>

<ol>
<li>安装操作系统</li>
</ol>
<p>我使用的操作系统是<a href="https://mirrors.tuna.tsinghua.edu.cn/centos-vault/8.0.1905/isos/x86_64/">Centos8.0</a>，实际使用的操作系统。其他的操作系统也可以，注意对应的版本的硬件CPU注意是否支持，方便述说，下面默认介绍Centos8.0操作系统上具体的步骤。</p>
<ol start="2">
<li>选择dpdk版本</li>
</ol>
<p>dpdk大版本之间的差异还是比较大的，可能有些接口就变了，所以选择一个稳定的版本进行开发还是很有必要的，我是学习使用所以就没那么多讲究，我使用的版本是17.08，<a href="http://core.dpdk.org/download/">源码下载地址</a>。下载源码，在服务器上解压。</p>
<ol start="3">
<li>编译dpdk</li>
</ol>
<p>dpdk提供了安装向导，可以在usertools目录下执行脚本<code>sh dpdk-setup.sh</code>，注意低版本可能没有。这个向导其实主有三个步骤，如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[22:49:37][root@xiaoluo usertools]#sh dpdk-setup.sh </span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line"> RTE_SDK exported as /root/lpyuan/dpdk/dpdk-stable-17.08.2</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"> Step 1: Select the DPDK environment to build</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">[1] arm64-armv8a-linuxapp-clang</span><br><span class="line">[2] arm64-armv8a-linuxapp-gcc</span><br><span class="line">[3] arm64-dpaa2-linuxapp-gcc</span><br><span class="line">[4] arm64-thunderx-linuxapp-gcc</span><br><span class="line">[5] arm64-xgene1-linuxapp-gcc</span><br><span class="line">[6] arm-armv7a-linuxapp-gcc</span><br><span class="line">[7] i686-native-linuxapp-gcc</span><br><span class="line">[8] i686-native-linuxapp-icc</span><br><span class="line">[9] ppc_64-power8-linuxapp-gcc</span><br><span class="line">[10] x86_64-native-bsdapp-clang</span><br><span class="line">[11] x86_64-native-bsdapp-gcc</span><br><span class="line">[12] x86_64-native-linuxapp-clang</span><br><span class="line">[13] x86_64-native-linuxapp-gcc</span><br><span class="line">[14] x86_64-native-linuxapp-icc</span><br><span class="line">[15] x86_x32-native-linuxapp-gcc</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------</span><br><span class="line"> Step 2: Setup linuxapp environment</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">[16] Insert IGB UIO module</span><br><span class="line">[17] Insert VFIO module</span><br><span class="line">[18] Insert KNI module</span><br><span class="line">[19] Setup hugepage mappings for non-NUMA systems</span><br><span class="line">[20] Setup hugepage mappings for NUMA systems</span><br><span class="line">[21] Display current Ethernet/Crypto device settings</span><br><span class="line">[22] Bind Ethernet/Crypto device to IGB UIO module</span><br><span class="line">[23] Bind Ethernet/Crypto device to VFIO module</span><br><span class="line">[24] Setup VFIO permissions</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------</span><br><span class="line"> Step 3: Run test application for linuxapp environment</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">[25] Run test application ($RTE_TARGET/app/test)</span><br><span class="line">[26] Run testpmd application in interactive mode ($RTE_TARGET/app/testpmd)</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------</span><br><span class="line"> Step 4: Other tools</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">[27] List hugepage info from /proc/meminfo</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------</span><br><span class="line"> Step 5: Uninstall and system cleanup</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">[28] Unbind devices from IGB UIO or VFIO driver</span><br><span class="line">[29] Remove IGB UIO module</span><br><span class="line">[30] Remove VFIO module</span><br><span class="line">[31] Remove KNI module</span><br><span class="line">[32] Remove hugepage mappings</span><br><span class="line"></span><br><span class="line">[33] Exit Script</span><br><span class="line"></span><br><span class="line">Option:</span><br></pre></td></tr></table></figure>
<p><code>Step 1: Select the DPDK environment to build</code>（选择dpdk环境进行编译）</p>
<p><code>Step 2: Setup linuxapp environment</code>（配置对应开发的应用层的程序环境的环境，主要是一些虚拟网卡的配置）</p>
<p><code>Step 3: Run test application for linuxapp environment</code>（测试我们搭建的环境是否可用）</p>
<p>由于我是<code>Centos 8.0</code>系统内核版本为<code>4.18.0-193.14.2.el8_2.x86_64</code>，我就选择了<code>[13] x86_64-native-linuxapp-gcc</code>编译项。</p>
<p>遇到报错：</p>
<img src="/images/image-20210510232108101.png" alt="image-20210510232108101" style="zoom:50%;" />

<p>以上报错是缺少numa.h头文件造成，执行命令安装<code>yum -y install numactl-devel.x86_64</code>安装，安装numa之后，重新选择编译，又再一次出现以下报错。</p>
<img src="/images/image-20210510232722134.png" alt="image-20210510232722134" style="zoom:50%;" />

<p>执行命令<code>elfutils-libelf-devel.x86_64</code>安装。</p>
<ol start="4">
<li>加载igb_uio驱动模块</li>
</ol>
<p>选择16选项，<code>[16] Insert IGB UIO module</code>。</p>
<img src="/images/image-20210510233519952.png" alt="image-20210510233519952" style="zoom:50%;" />

<ol start="5">
<li><p>绑定网卡</p>
</li>
<li><p>设置内存大页</p>
</li>
</ol>
<p>选择选项<code>[20] Setup hugepage mappings for NUMA systems</code>因为我的是2M的内存页，所以我输入1024那就是2014*2M等于2G。</p>
<img src="/images/image-20210510233850685.png" alt="image-20210510233850685" style="zoom:50%;" />

<ol start="7">
<li>配置全局环境变量</li>
</ol>
<p>实际的路径地址以你的目录地址为准！！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// 配置开发套件目录</span><br><span class="line"><span class="built_in">export</span> RTE_SDK=/root/lpyuan/dpdk/dpdk-stable-17.08.2</span><br><span class="line"></span><br><span class="line">// 配置dpdk目标目录</span><br><span class="line"><span class="built_in">export</span> RTE_TARGET=x86_64-native-linuxapp-gcc</span><br></pre></td></tr></table></figure>
<img src="/images/image-20210510235030390.png" alt="image-20210510235030390" style="zoom:50%;" />

<ol start="8">
<li>检测环境是否正常</li>
</ol>
<p>dpdk提供了一个简单的<code>hello world</code>示例程序在<code>examples/helloworld</code>目录下进入到该目录，执行<code>make命令 编译Makefile</code>，在build目录下会生成一个helloworld的可执行程序，执行运行命令<code>helloworld -c 0x3（CPU掩码）</code>执行1、3号core运行，成功运行则如下所示，由于我只有一个核心core所以只打印出出一个helloworld，下图显示在core 0上运行成功。</p>
<img src="/images/image-20210510235859069.png" alt="image-20210510235859069" style="zoom:50%;" />]]></content>
      <categories>
        <category>DPDK</category>
      </categories>
  </entry>
  <entry>
    <title>C编程技巧</title>
    <url>/2021/04/17/9df91191.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="分配器缓存对齐问题"><a href="#分配器缓存对齐问题" class="headerlink" title="分配器缓存对齐问题"></a>分配器缓存对齐问题</h2><p>看到一段代码，写一个内存分配器的时候发现代码编写如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">size = (st_szie + <span class="number">15</span>) &amp; <span class="number">0xffffff0</span></span><br><span class="line">size = (st_size + <span class="number">15</span>) &amp; ~<span class="number">0xf</span></span><br></pre></td></tr></table></figure>
<p>这种可以用来保证对齐，通常使SIMD优化，（SSE为16字节，AVX为32字节等）基地址’与’或者’或’来优化缓存的作用。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>Go单元测试</title>
    <url>/2021/03/13/6960d311.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp;在Go语言中有一个很有好的东西，就是Go本身自带有一套完整的单元测试和性能测试系统，开发者只是需要添加很少的一个代码就可以完成一个单元的测试。</p>
<p>&ensp;&ensp;&ensp;&ensp;我们在对应的单元模块下面执行 <code>go test</code>命令，那么Go本身会自己读取源码目录下面对应的名字为<code>*_test.go</code>的文件，生成并运行对应的测试可用的可执行文件。单元测试我们可以知道单元函数或者模块的一个运行情况，性能测试系统也可以给我们输出我们的代码的一个基本的性能数据，帮助我们分析性能问题。</p>
<a id="more"></a>

<img src="/images/image-20210313060643759.png" alt="image-20210313060643759" style="zoom: 33%;" />

<ul>
<li>单元测试源码文件可以由多个测试用例组成，每个测试用例函数名都需要以<code>Test</code>作为前缀，如 <code>func TestXXX(t *testing.T)</code>。</li>
<li>测试文件在编译时候不会参与正常的源码编译。</li>
<li>测试用例通过执行<code>go test</code>命令自动执行。</li>
<li>如果想要获取更多的测试信息，可以执行命令<code>go test -v</code></li>
</ul>
<p>下面是一份单元测试源文件和对应的单元测试用例代码示例：</p>
<p>user.go文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;goProject/goBooks/utils&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// User结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">	ID 			<span class="keyword">int</span></span><br><span class="line">	Username 	<span class="keyword">string</span></span><br><span class="line">	Password 	<span class="keyword">string</span></span><br><span class="line">	Email 		<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加User方法1,带预编译的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(user *User)</span><span class="title">AddUser</span><span class="params">()</span> <span class="title">error</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	sqlStr := <span class="string">&quot;insert into users(username, password, email) values (?, ?, ?)&quot;</span></span><br><span class="line">	inStmt, err := utils.Db.Prepare(sqlStr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;预编译异常：&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	_, err2 := inStmt.Exec(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="string">&quot;lpyuan21@gmail.com&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err2 != <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;执行出现异常: &quot;</span>, err2)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加User方法2，不带预编译的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(user *User)</span><span class="title">AddUser1</span><span class="params">()</span> <span class="title">error</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	sqlStr := <span class="string">&quot;insert into users(username, password, email) values (?, ?, ?)&quot;</span></span><br><span class="line">	_ , err:= utils.Db.Exec(sqlStr, <span class="string">&quot;lpyuan&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="string">&quot;lpyuan21@outlook.com&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Exec Error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>user_test.go文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以在测试函数开始执行之前做一些其他的操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;测试开始：&quot;</span>)</span><br><span class="line">	m.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试主方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUser</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;测试User&quot;</span>)</span><br><span class="line">	<span class="comment">// 通过调用t.Run可以调用测试用例中不是以Test前缀开头的函数</span></span><br><span class="line">	t.Run(<span class="string">&quot;测试添加用户程序:&quot;</span>, testAddUser)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试子方法,如果函数名字不是以Test开头，那么该函数默认不会执行，</span></span><br><span class="line"><span class="comment">// 我们可以将它设置成为一个子测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testAddUser</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;测试添加用户： &quot;</span>)</span><br><span class="line">	user := &amp;User&#123;&#125;</span><br><span class="line">	<span class="comment">// 调用</span></span><br><span class="line">	_ = user.AddUser()</span><br><span class="line">	_ = user.AddUser1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] 引用参考~</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>单测</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务（微服务概览与治理）</title>
    <url>/2021/03/10/1e16c98a.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h1><p>单体架构虽然有时候看起来也是模块化的逻辑，但是还是会打包成一个单体应用。其中的最主要的一个问题就是，如果这个应用太复杂，以致于我们的任何单个开发者都不可能搞懂整个应用。这样就会使得应用无法进行一个扩展，可靠性就会极其低下，最终的结果则是我们的敏捷性开发和部署变的特别的困难。</p>
<a id="more"></a>

<img src="/images/image-20210311020330353.png" alt="image-20210311020330353" style="zoom: 50%;" />

<p><strong>应对的思路：化繁为简，分而治之。</strong></p>
<h1 id="微服务概览"><a href="#微服务概览" class="headerlink" title="微服务概览"></a>微服务概览</h1><p>我们常说SOA（面向服务）架构，其实微服务是有一定的关系的，我们 可以认为，微服务是SOA的一种实践。</p>
<ul>
<li>小即是美，小的服务代码量少，bug也少，容易测试，可以快速的迭代和部署。</li>
<li>单职责，一个服务只需要做好一件事，专注才能做好。</li>
<li>尽可能的创建原型，尽可能早的提供API服务，建立完整的服务契约，达成服务之间的一致性，实现和完善的可以后面慢慢再弄。</li>
<li>可移植性比效率更重要。服务之间的轻量级交互协议在效率上和可以执行二者的之间，首先考虑的应该是兼容性和移植性。</li>
</ul>
<img src="/images/image-20210311074830857.png" alt="image-20210311074830857" style="zoom: 50%;" />

<p>微服务每个服务独占一个DB，很多个DB又可以组成集群，理论上单个DB讲无法无限制的扩容，拆分出来之后，他们的之间性能可能会好点。</p>
<p><strong>微服务的定义</strong></p>
<p>微服务指的是围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以实现全自动独立部署，每个服务之间可以采用不同的编程语言和数据存储计数。通过对业务架构的一个拆分可以实现服务组件化，通过组件组合快速开发系统，业务单一的服务组件可以独立部署，是的整个的系统架构变的清晰灵活。</p>
<p><strong>主要有以下特点：</strong></p>
<ul>
<li>原子服务</li>
<li>独立进程</li>
<li>隔离部署</li>
<li>去中心化的服务治理</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>以来于基础设置的建设，同时复杂度高。</li>
</ul>
<img src="/images/image-20210311075519001.png" alt="image-20210311075519001" style="zoom: 50%;" />



<p>未完待续~</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://u.geekbang.org/subject/go?utm_source=time_web&amp;utm_medium=menu&amp;utm_term=timewebmenu&amp;utm_identify=geektime&amp;utm_content=menu&amp;utm_campaign=timewebmenu&amp;gk_cus_user_wechat=university%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E6%AF%9B%E8%80%81%E5%B8%88%E8%AF%BE%E7%A8%8B%EF%BC%89">https://u.geekbang.org/subject/go?utm_source=time_web&amp;utm_medium=menu&amp;utm_term=timewebmenu&amp;utm_identify=geektime&amp;utm_content=menu&amp;utm_campaign=timewebmenu&amp;gk_cus_user_wechat=university（极客时间毛老师课程）</a></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go进阶训练营</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈基金</title>
    <url>/2021/03/01/2c85f35d.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先要认识到，购买基金是一个投资的行为（区别于投机），投资一定是拿我们<strong>闲散的资金</strong>进行投资基金投资是一个长期的过程一般这个过程需三年以上。</p>
<a id="more"></a>

<p>基金投资的最佳策略：长期卧倒不动！！！</p>
<p>1、做好本职工作。</p>
<p>2、长期定投。</p>
<p>3、不断的学习相关的知识，设计相关的领域。</p>
<h2 id="基金连续下跌怎么办？"><a href="#基金连续下跌怎么办？" class="headerlink" title="基金连续下跌怎么办？"></a>基金连续下跌怎么办？</h2><p>1、连续一段时间每天看下你是否能跑赢大盘，如果能跑赢大盘，说明整体组合不错，这时候不需要惊慌，长期投资即可。</p>
<p>2、如果跑不赢大盘，说明你的组合可能行业基金比较多，比较偏科，这时候其实我们的抗风险能力是比较弱的，如果遇到行业回调，</p>
<p>这时候就很容易会出问题，很容易被沪深300远远甩到后面。</p>
<h2 id="分析每一只基金"><a href="#分析每一只基金" class="headerlink" title="分析每一只基金"></a>分析每一只基金</h2><p>首先要明确一个概念，我们购买基金是一个投资行为，首要的是保持我们手上闲散资金的一个价值，其次才是追求超额收益。我们应该坚持价值投资，而不是来回倒腾，低买高卖赚取差价，只要我们买的是国内一流的企业从一个长远来看，他们是很优秀的最终都是可以获取一些超额收益，这才是我们普通人的投资选择。</p>
]]></content>
      <categories>
        <category>金融理财</category>
      </categories>
      <tags>
        <tag>基金</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux非阻塞模式下的EAGIN异常</title>
    <url>/2021/02/19/6f167ca3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前在写一个并发聊天室时候在多个客户端连续发送数据的时候遇到EAGIN错误，如图。</p>
<img src="/images/image-20210218231840685.png" alt="image-20210218231840685" style="zoom:20%;" />

<p>Linux下，管道、FIFO以及一些设备（通常是终端和网络）一般有以下几种性质。</p>
<a id="more"></a>

<p>1、一次read操作返回的数据可能会少于所要求的数据，及时此时没有到达文件尾部也可能会出现这种情况。对于这种情况，我们不认为是错误，而是视为一种异常，应该继续对此设备进行读取。</p>
<p>2、一次write或send操作的返回值也可能会少于指定的输出的字节数。通常这可能是由于某一种因素引起的，比如在处理网络数据的时，内核输出的缓冲区满，此时写不进数据。我们也通常不认为这是一种错误，应当继续将余下的数据进行写入。（通常遇到这种情况的场景是非阻塞描述符，或者捕捉到某一种信号的时候，才会发生中途返回。）</p>
<p>服务端server.cpp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;utility.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 服务器IP+PORT */</span>    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>;</span></span><br><span class="line">    serverAddr.sin_family = PF_INET;</span><br><span class="line">    serverAddr.sin_port = htons(SERVER_PORT);</span><br><span class="line">    serverAddr.sin_addr.s_addr = inet_addr(SERVER_IP);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> listener = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(listener &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">int</span> opt=<span class="number">1</span>;</span><br><span class="line">	setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;listen socket success, listenfd = %d\n&quot;</span>, listener);</span><br><span class="line">    <span class="keyword">if</span>(bind(listener, (struct sockaddr *)&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = listen(listener, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;listen failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start listen: %s\n&quot;</span>, SERVER_IP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在内核中创建事件列表 */</span></span><br><span class="line">    <span class="keyword">int</span> epfd = epoll_create(EPOLL_SIZE);</span><br><span class="line">    <span class="keyword">if</span>(epfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;epoll create, epollfd = %d\n&quot;</span>, epfd);</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">EPOLL_SIZE</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 往内核事件列表添加事件 */</span></span><br><span class="line">    addfd(epfd, listener, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主循环 */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//epoll_events_count 表示就绪事件的数目</span></span><br><span class="line">        <span class="keyword">int</span> epoll_events_count = epoll_wait(epfd, events, EPOLL_SIZE, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(epoll_events_count &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait failed&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;epoll_events_count:%d\n&quot;</span>, epoll_events_count);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 处理epoll_events_count个就绪事件 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;epoll_events_count; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span> (sockfd == listener)&#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddr</span>;</span></span><br><span class="line">                <span class="keyword">socklen_t</span> clientAddrLen = <span class="keyword">sizeof</span>(clientAddr);</span><br><span class="line">                <span class="keyword">int</span> connfd = accept(listener, (struct sockaddr *)&amp;clientAddr, &amp;clientAddrLen);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;client connection from %s:%d clientfd=%d\n&quot;</span>, inet_ntoa(clientAddr.sin_addr), ntohs(clientAddr.sin_port), connfd);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 将新的客户端添加到事件列表中 */</span></span><br><span class="line">                addfd(epfd, connfd, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 服务端用list保存用户连接 */</span></span><br><span class="line">                clients_list.push_back(connfd);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Add new clientfd = %d to epoll.\n&quot;</span>, connfd);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Now there are %d clients int the chat room\n&quot;</span>, (<span class="keyword">int</span>)clients_list.size());</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 服务端发送欢迎信息 */</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;welcome message\n&quot;</span>);</span><br><span class="line">                <span class="keyword">char</span> message[BUF_SIZE];</span><br><span class="line">                bzero(message, BUF_SIZE);</span><br><span class="line">                <span class="built_in">snprintf</span>(message, <span class="keyword">sizeof</span>(message), SERVER_WELCOME, connfd);</span><br><span class="line">                <span class="keyword">int</span> ret = send(connfd, message, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123; </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;line:%d errno:%d\n&quot;</span>, __LINE__, errno);</span><br><span class="line">                    perror(<span class="string">&quot;send failed&quot;</span>); </span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> ret = sendBroadcastMessage(sockfd);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;line:%d errno:%d\n&quot;</span>, __LINE__, errno);</span><br><span class="line">                    perror(<span class="string">&quot;send failed&quot;</span>); </span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关闭socket */</span></span><br><span class="line">    close(listener);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关闭内核 不在监控这些注册事件是否发生 */</span></span><br><span class="line">    close(epfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端client.cpp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;utility.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">2</span> )&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Please inout ipAddr, eg:%s 127.0.0.1\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;    </span><br><span class="line">    <span class="comment">/* 用户连接服务器 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>;</span></span><br><span class="line">    serverAddr.sin_family = PF_INET;</span><br><span class="line">    serverAddr.sin_port = htons(SERVER_PORT);</span><br><span class="line">    serverAddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)&#123; </span><br><span class="line">        perror(<span class="string">&quot;socket failed&quot;</span>); </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 连接服务端 */</span></span><br><span class="line">    <span class="keyword">if</span>(connect(sockfd, (struct sockaddr *)&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect faild&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建管道，其中fd[0]用于父进程读，fd[1]用于子进程写 */</span></span><br><span class="line">    <span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(pipe(pipe_fd) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建epoll */</span></span><br><span class="line">    <span class="keyword">int</span> epfd = epoll_create(EPOLL_SIZE);</span><br><span class="line">    <span class="keyword">if</span>(epfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> epoll_event events[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将sockfd和管道读端描述符都添加到内核事件列表中 */</span></span><br><span class="line">    addfd(epfd, sockfd, <span class="literal">true</span>);</span><br><span class="line">    addfd(epfd, pipe_fd[<span class="number">0</span>], <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 表示客户端是否正常工作标志 */</span></span><br><span class="line">    <span class="keyword">bool</span> isClientWork = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 聊天信息缓冲区 */</span></span><br><span class="line">    <span class="keyword">char</span> message[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//FORK</span></span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>( pid &lt; <span class="number">0</span> )&#123; </span><br><span class="line">        perror(<span class="string">&quot;fork failed&quot;</span>); </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( pid == <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="comment">/* 子进程 */</span></span><br><span class="line">        <span class="comment">/* 子进程负责写入管道，因此先关闭读端 */</span></span><br><span class="line">        close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please input &#x27;exit&#x27; to exit the chat room!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(isClientWork)&#123;</span><br><span class="line">            bzero(message, BUF_SIZE);</span><br><span class="line">            fgets(message, BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 客户端输出exit，并退出 */</span></span><br><span class="line">            <span class="keyword">if</span>( strncasecmp(message, EXIT, <span class="built_in">strlen</span>(EXIT)) == <span class="number">0</span> )&#123;</span><br><span class="line">                isClientWork = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">/* 子进程将信息写入管道 */</span></span><br><span class="line">                <span class="keyword">if</span>(write(pipe_fd[<span class="number">1</span>], message, <span class="built_in">strlen</span>(message)<span class="number">-1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                &#123; </span><br><span class="line">                    perror(<span class="string">&quot;write failed&quot;</span>); </span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">/* pid&gt;0 父进程 */</span></span><br><span class="line">        <span class="comment">/* 父进程负责读取管道数据，因此先关闭写端 */</span></span><br><span class="line">        close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">while</span>(isClientWork)&#123;</span><br><span class="line">            <span class="keyword">int</span> epoll_events_count = epoll_wait(epfd, events, <span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;epoll_events_count; i++)&#123;</span><br><span class="line">                bzero(message, BUF_SIZE);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">/* 接收服务端发来的消息 */</span></span><br><span class="line">                <span class="keyword">if</span>(events[i].data.fd == sockfd)&#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">/* 接收服务端的消息 */</span></span><br><span class="line">                    <span class="keyword">int</span> ret = recv(sockfd, message, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* ret == 0 服务端关闭 */</span></span><br><span class="line">                    <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Server closed connection:%d\n&quot;</span>, sockfd);</span><br><span class="line">                        close(sockfd);</span><br><span class="line">                        isClientWork = <span class="number">0</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">/* 子进程写入事件发生，父进程处理并发送服务器 */</span></span><br><span class="line">                    <span class="comment">/* 父进程从管道中读取数据 */</span></span><br><span class="line">                    <span class="keyword">int</span> ret = read(events[i].data.fd, message, BUF_SIZE);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//ret=0</span></span><br><span class="line">                    <span class="keyword">if</span>( ret == <span class="number">0</span> )&#123;</span><br><span class="line">                        isClientWork = <span class="number">0</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">/* 信息发送服务器 */</span></span><br><span class="line">                        send(sockfd, message, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid)&#123;</span><br><span class="line">        close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">        close(sockfd);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>头文件utility.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UTILITY_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UTILITY_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* clients_list save all the client&#x27;s socket */</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; clients_list;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******* macro defintion ***********/</span></span><br><span class="line"><span class="comment">//server ip</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_IP <span class="meta-string">&quot;0.0.0.0&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//server port</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 8888</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//epoll size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLL_SIZE 5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//BUF_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 0xffff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_WELCOME <span class="meta-string">&quot;welcome you join the chat room! Your chat ID is: Client #%d&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_MESSAGE <span class="meta-string">&quot;ClientID %d say &gt;&gt; %s&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//exit</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXIT <span class="meta-string">&quot;EXIT&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAUTION <span class="meta-string">&quot;There is only one in the char room!&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *@param sockfd:socket descriptor</span></span><br><span class="line"><span class="comment"> *@return 0 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblockint</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>&#123;</span><br><span class="line">    fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFD, <span class="number">0</span>)|O_NONBLOCK);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *@param epollfd:epoll handle</span></span><br><span class="line"><span class="comment"> *@param fd:sockfd descriptor</span></span><br><span class="line"><span class="comment"> *@param enable_et: enable_et = true, epoll use ET;otherwise LT</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> enable_et)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span>(enable_et)</span><br><span class="line">        ev.events = EPOLLIN|EPOLLET;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;ev);</span><br><span class="line">    setnonblockint(fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd added to epoll!\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *@param clientfd: socket descriptor</span></span><br><span class="line"><span class="comment"> *@return :len</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendBroadcastMessage</span><span class="params">(<span class="keyword">int</span> clientfd)</span></span>&#123;</span><br><span class="line">    <span class="comment">//buf[BUF_SIZE] receive new chat message</span></span><br><span class="line">    <span class="comment">//message[BUF_SIZE] save format message</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="keyword">char</span> message[BUF_SIZE];</span><br><span class="line">    bzero(buf, BUF_SIZE);</span><br><span class="line">    bzero(message, BUF_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read from client(clientID = %d)\n&quot;</span>, clientfd);</span><br><span class="line">    <span class="keyword">int</span> len = recv(clientfd, buf, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* len == 0 means the client closed connection */</span></span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        close(clientfd);</span><br><span class="line">        <span class="comment">/* server remove the client */</span></span><br><span class="line">        clients_list.remove(clientfd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ClientID=%d close.\n now there are %d client in the chat room!\n&quot;</span>, clientfd, (<span class="keyword">int</span>)clients_list.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* this means is only one in the room */</span></span><br><span class="line">        <span class="keyword">if</span>(clients_list.size() == <span class="number">1</span>)&#123;</span><br><span class="line">            send(clientfd, CAUTION, <span class="built_in">strlen</span>(CAUTION), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">snprintf</span>(message, <span class="keyword">sizeof</span>(message), SERVER_MESSAGE, clientfd, buf);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span>(it=clients_list.begin(); it!=clients_list.end(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (*it != clientfd)&#123;</span><br><span class="line">                <span class="keyword">if</span>(send(*it, message, BUF_SIZE, <span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;line:%d errno:%d\n&quot;</span>, __LINE__, errno);</span><br><span class="line">                    perror(<span class="string">&quot;send failed&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>Makefile文件</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: server client</span></span><br><span class="line"></span><br><span class="line"><span class="section">server:</span></span><br><span class="line">	g++ server.cpp -o server</span><br><span class="line"><span class="section">client:</span></span><br><span class="line">	g++ client.cpp -o client</span><br><span class="line"></span><br><span class="line"><span class="section">.PHONLY:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf server client</span><br></pre></td></tr></table></figure>
<p>未完待续~</p>
]]></content>
      <categories>
        <category>Unix环境高级编程</category>
      </categories>
      <tags>
        <tag>Unix</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>GoError错误处理</title>
    <url>/2021/02/02/b424edbd.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Go 的处理异常逻辑是不引入 exception，支持多参数返回，所以你很容易的在函数签名中带上实现了 error Interface 的对象，交由调用者来判定。如果一个函数返回了 value, error，你不能对这个 value 做任何假设，必须先判定 error。唯一可以忽略 error 的是，如果你连 value 也不关心。</p>
<a id="more"></a>

<p>Go error  就是普通的一个接口，普通的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The error built-in interface type is the conventional interface for</span></span><br><span class="line"><span class="comment">// representing an error condition, with the nil value representing no error.</span></span><br><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">	Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 封装Go 防止野生的goruntime panic导致程序挂掉 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Go</span><span class="params">(x <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Println(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		x()</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;he&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;lpyuan2&quot;</span>)</span><br><span class="line">		fmt.Println(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;lpyuan1&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>未完待续~</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://u.geekbang.org/subject/go?utm_source=time_web&amp;utm_medium=menu&amp;utm_term=timewebmenu&amp;utm_identify=geektime&amp;utm_content=menu&amp;utm_campaign=timewebmenu&amp;gk_cus_user_wechat=university%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E6%AF%9B%E5%89%91%E8%AF%BE%E7%A8%8B%EF%BC%89">https://u.geekbang.org/subject/go?utm_source=time_web&amp;utm_medium=menu&amp;utm_term=timewebmenu&amp;utm_identify=geektime&amp;utm_content=menu&amp;utm_campaign=timewebmenu&amp;gk_cus_user_wechat=university（极客时间毛剑课程）</a></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go进阶训练营</tag>
      </tags>
  </entry>
  <entry>
    <title>Go操作MySQL数据库</title>
    <url>/2021/01/07/81dd58c3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Go语言中的<code>database/sql</code>包提供了保证SQL或类SQL数据库的泛用接口，并不提供具体的数据库驱动。使用<code>database/sql</code>包时必须注入（至少）一个数据库驱动。</p>
<p>我们常用的数据库基本上都有完整的第三方实现。例如：<a href="https://github.com/go-sql-driver/mysql">MySQL驱动</a></p>
<a id="more"></a>

<h1 id="基本的数据库操作接口"><a href="#基本的数据库操作接口" class="headerlink" title="基本的数据库操作接口"></a>基本的数据库操作接口</h1><p>下面是操作mysql数据库的基本接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* open函数打开一个指定的数据库，数据库的类型使用driverName参数字段表示的数据库类型，</span></span><br><span class="line"><span class="comment">dataSourceName参数字段则是指定的数据库账户密码地址等信息 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(driverName, dataSourceName <span class="keyword">string</span>)</span> <span class="params">(*DB, error)</span></span> </span><br><span class="line"></span><br><span class="line"><span class="comment">/* QueryRow函数执行一次查询，并且返回一行数据 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span><span class="title">QueryRow</span><span class="params">(query <span class="keyword">string</span>, args...<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Row</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Query函数执行一次查询，返回多行数据结果，参数中args表示函数中的占位数 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span><span class="title">Query</span><span class="params">(query <span class="keyword">string</span>, args...<span class="keyword">interface</span>&#123;&#125;)</span><span class="params">(*Rows, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* exec执行一次命令（包括删除、更新、插入等），返回的Result是已执行的sql命令的SQL命令的总结。</span></span><br><span class="line"><span class="comment">参数args表示query中的占位数 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span><span class="title">Exec</span><span class="params">(query <span class="keyword">string</span>, args...<span class="keyword">interface</span>&#123;&#125;)</span><span class="params">(Result, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Prepare函数会先将sql语句发送给sql数据库，返回一个已经准备好的句柄（准备好的状态）</span></span><br><span class="line"><span class="comment">用于后面的查询和命令，返回值可以同时执行多个查询和命令 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span><span class="title">Prepare</span><span class="params">(query <span class="keyword">string</span>)</span><span class="params">(*Stmt, error)</span></span></span><br></pre></td></tr></table></figure>


<h2 id="MySQL事务操作"><a href="#MySQL事务操作" class="headerlink" title="MySQL事务操作"></a>MySQL事务操作</h2><p><strong>事务:</strong> 事务是一个最小的不可再分的一个执行单位，主要是某些场景用来保证完整性。</p>
<p>在MySQL中只有使用了Innodb数据库引擎的数据库或者表才会支持事务操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 开始事务 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span><span class="title">Begin</span><span class="params">()</span><span class="params">(*Tx, error)</span></span></span><br><span class="line"><span class="comment">/* 提交事务 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span><span class="title">Commit</span><span class="params">()</span><span class="title">error</span></span> </span><br><span class="line"><span class="comment">/* 回滚事务 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span><span class="title">Rollback</span><span class="params">()</span><span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>Go操作mysql数据库的使用实例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义查询结果集结构 */</span></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">  id   <span class="keyword">int</span></span><br><span class="line">  age  <span class="keyword">int</span></span><br><span class="line">  name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化全部的数据库句柄 */</span></span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化数据库连接 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDb</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">  dsn := <span class="string">&quot;root:yuan1121@tcp(127.0.0.1:3306)/lpyuan?charset=utf8mb4&amp;parseTime=True&quot;</span></span><br><span class="line">  db, err = sql.Open(<span class="string">&quot;mysql&quot;</span>, dsn)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;open mysql failed&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 尝试与数据库连接 */</span></span><br><span class="line">  err = db.Ping()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查询单行数据 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryRowDemon</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> u user</span><br><span class="line">  sqlstr := <span class="string">&quot;select id, name, age from user where id =?&quot;</span></span><br><span class="line">  err := db.QueryRow(sqlstr, <span class="number">2</span>).Scan(&amp;u.id, &amp;u.name, &amp;u.age)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;scan failed, err:%v\n&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;id:%d name:%s age:%d\n&quot;</span>, u.id, u.name, u.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查询多行数据 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryMultiRowDaemon</span><span class="params">()</span></span> &#123;</span><br><span class="line">  sqlstr := <span class="string">&quot;select id, name, age from user where id &gt; ?&quot;</span></span><br><span class="line">  rows, err := db.Query(sqlstr, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;db.Query failed, err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> rows.Close()</span><br><span class="line">  <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">    <span class="keyword">var</span> u user</span><br><span class="line">    err := rows.Scan(&amp;u.id, &amp;u.name, &amp;u.age)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Scan failed , err:&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;id:%d name:%s age:%d\n&quot;</span>, u.id, u.name, u.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入数据 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertRowDaemon</span><span class="params">()</span></span> &#123;</span><br><span class="line">  sqlstr := <span class="string">&quot;insert into user(name, age) values (?, ?)&quot;</span></span><br><span class="line">  ret, err := db.Exec(sqlstr, <span class="string">&quot;张龙&quot;</span>, <span class="number">26</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Exec failed&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  theId, err := ret.LastInsertId()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;get last insterId is failed&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;insert success, the id is %d&quot;</span>, theId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除数据操作 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  sqlStr := <span class="string">&quot;delete from user where id = ?&quot;</span></span><br><span class="line">  ret, err := db.Exec(sqlStr, <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;delete failed, err:%v\n&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  n, err := ret.RowsAffected() <span class="comment">// 操作影响的行数</span></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;get RowsAffected failed, err:%v\n&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;delete success, affected rows:%d\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareDemon</span><span class="params">()</span></span> &#123;</span><br><span class="line">  sqlstr := <span class="string">&quot;insert into user(name, age) values(?, ?)&quot;</span></span><br><span class="line">  stmt, err := db.Prepare(sqlstr)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Prepare sqlstr failed&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> stmt.Close()</span><br><span class="line">  _, err = stmt.Query(<span class="string">&quot;马汉&quot;</span>, <span class="number">23</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;stmt.Query failed&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  _, err = stmt.Query(<span class="string">&quot;李白&quot;</span>, <span class="number">21</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;stmt.Query failed &quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="string">&quot;赵虎&quot;</span>:<span class="number">22</span>,</span><br><span class="line">    <span class="string">&quot;打算的撒&quot;</span>:<span class="number">23</span>,</span><br><span class="line">    <span class="string">&quot;银行&quot;</span>:<span class="number">24</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    stmt.Exec(k, v)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;insert success&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提交事务操作 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transactionDemon</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">/* 开启事务 */</span></span><br><span class="line">  tx, err := db.Begin()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> tx != <span class="literal">nil</span>&#123;</span><br><span class="line">      tx.Rollback()</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;begin trans failed, err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  sqlstr1 := <span class="string">&quot;Update user set age = 30 where id = ?&quot;</span></span><br><span class="line">  ret1, err := tx.Exec(sqlstr1, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Exec sql1 error, err:&quot;</span>, err)</span><br><span class="line">    tx.Rollback()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  affRows1, err := ret1.RowsAffected()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    tx.Rollback()</span><br><span class="line">    fmt.Println(<span class="string">&quot;RowsAffected failed&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  sqlstr2 := <span class="string">&quot;Update user set age=40 where id=?&quot;</span></span><br><span class="line">  ret2, err := tx.Exec(sqlstr2, <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    tx.Rollback()</span><br><span class="line">    fmt.Println(<span class="string">&quot;exec sqlstr2 failed, err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  affRows2, err := ret2.RowsAffected()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    tx.Rollback()</span><br><span class="line">    fmt.Println(<span class="string">&quot;RowsAffected failed, err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;affRows1:%d affRows2:%d\n&quot;</span>, affRows1, affRows2)</span><br><span class="line">  <span class="keyword">if</span> affRows1 == <span class="number">1</span> &amp;&amp; affRows2 == <span class="number">1</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;事务提交了。。。&quot;</span>)</span><br><span class="line">    tx.Commit()</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    tx.Rollback()</span><br><span class="line">    fmt.Println(<span class="string">&quot;事务回滚了~&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;exec trans success&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主函数main */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  err := initDb()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;initDB error!&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;连接数据库成功&quot;</span>)</span><br><span class="line">  fmt.Println(<span class="string">&quot;单行查询：&quot;</span>)</span><br><span class="line">  queryRowDemon()</span><br><span class="line">  fmt.Println(<span class="string">&quot;多行查询：&quot;</span>)</span><br><span class="line">  queryMultiRowDaemon()</span><br><span class="line">  transactionDemon()</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p>[1] <a href="https://www.liwenzhou.com/posts/Go/go_mysql/">https://www.liwenzhou.com/posts/Go/go_mysql/</a></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>链表相关问题</title>
    <url>/2021/01/07/e655a013.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>链表在Linux内核中可以说是一种最简单的、也是最普通的一种线性的数据结构。链表是一种存放和操作可变数量元素（通常我们称之为节点）的数据结构。</p>
<p>可以用最简单的数据结构来表示这样一个链表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 一个链表中的一个一个元素 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_element</span>&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *data;				<span class="comment">/* 有效数据 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_element</span> *<span class="title">next</span>;</span>	<span class="comment">/* 指向下一个节点指针 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下图描述一个链表结构体：</p>
<img src="/images/image-20210220120514901.png" alt="image-20210220120514901" style="zoom:50%;" />

<a id="more"></a>

<h2 id="实现一种算法，找出单向链表的倒数第k个节点"><a href="#实现一种算法，找出单向链表的倒数第k个节点" class="headerlink" title="实现一种算法，找出单向链表的倒数第k个节点"></a>实现一种算法，找出单向链表的倒数第k个节点</h2><p>示例：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">1-&gt;2-&gt;3-&gt;4-&gt;5 和 k=2</span><br><span class="line">输出：4 </span><br></pre></td></tr></table></figure>
<p>说明：</p>
<p>给定的k值是有效的。</p>
<p><strong>解题思路</strong></p>
<ul>
<li><p>先让t向前走k步</p>
</li>
<li><p>head和t同时向前走一直到链表尾部，此时head就是倒数第k个节点。</p>
</li>
</ul>
<p><strong>示例代码</strong></p>
<p>C/C++示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(struct listNode *head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">p</span> =</span> head;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">q</span> =</span> head;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(p)&#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> q-&gt;val;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">q</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;<span class="number">0</span>)</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;val;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>Go语言示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kthToLast</span><span class="params">(head *ListNode, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    fast := head</span><br><span class="line">    slow := head</span><br><span class="line">    <span class="keyword">for</span> k&gt;<span class="number">0</span>&#123;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">        k--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span>&#123;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow.Val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="给定一个链表，旋转该链表，将链表的每一个节点向右移动k个位置，其中k是非负数。"><a href="#给定一个链表，旋转该链表，将链表的每一个节点向右移动k个位置，其中k是非负数。" class="headerlink" title="给定一个链表，旋转该链表，将链表的每一个节点向右移动k个位置，其中k是非负数。"></a>给定一个链表，旋转该链表，将链表的每一个节点向右移动k个位置，其中k是非负数。</h2><img src="/images/image-20210220042214993.png" alt="image-20210220042214993" style="zoom:40%;" />

<p><strong>解题思路</strong></p>
<ul>
<li>遍历整个链表，找到链表的尾部同时获取链表的长度，将链表的尾部与链表头相连形成一个环。</li>
<li>然后通过取余计算计算k的余数。最后通过直接断开这个环，返回头指针即可。</li>
</ul>
<p>Go语言 示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotateRight</span><span class="params">(head *ListNode, k <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    n, p := <span class="number">1</span>, head</span><br><span class="line">    <span class="keyword">for</span> p.Next != <span class="literal">nil</span>&#123;</span><br><span class="line">        p = p.Next</span><br><span class="line">        n++</span><br><span class="line">    &#125;</span><br><span class="line">    p.Next = head</span><br><span class="line">    k %= n</span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">1</span> ; i&lt;= n-k; i++&#123;</span><br><span class="line">        p = p.Next</span><br><span class="line">    &#125;</span><br><span class="line">    head, p.Next = p.Next, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现一种算法，删除单向链表中间的某个节点（即不是第一个或者最后一个节点），界定你只能访问该节点。"><a href="#实现一种算法，删除单向链表中间的某个节点（即不是第一个或者最后一个节点），界定你只能访问该节点。" class="headerlink" title="实现一种算法，删除单向链表中间的某个节点（即不是第一个或者最后一个节点），界定你只能访问该节点。"></a>实现一种算法，删除单向链表中间的某个节点（即不是第一个或者最后一个节点），界定你只能访问该节点。</h2><img src="/images/image-20210220042243290.png" alt="image-20210220042243290" style="zoom:33%;" />

<p><strong>解题思路</strong></p>
<ul>
<li><p>由于只能访问该节点，无法获取他的前驱节    点，我们不能简单的对节点进行删除操作。</p>
</li>
<li><p>我们换一种思路，将cur-&gt;next的值拷贝到当前节点将其值覆盖，然后将cur的next节点删除掉，以达到删除当前节点的效果。(狸猫换太子)</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(struct listNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">temp</span> =</span> node-&gt;next;</span><br><span class="line">  node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">  <span class="built_in">free</span>(temp);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(node *listNode)</span></span>&#123;</span><br><span class="line">  node.Val, node.Next = node.Next.Val, node.Next.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h2><p>给你两个非空链表来代表两个非负整数。数字最高位位于链表的开始位置，他们的每个节点只是存储一个数字。将这两数相加会返回一个新的链表节点，你可以假设除了数字之外，这连个数字都不会以零开头。</p>
<p>进阶：</p>
<p>如果输入链表不能修改该如何处理，换句话说，你不能对列表中的节点进行翻转。</p>
<img src="/images/image-20210220042322096.png" alt="image-20210220042322096" style="zoom:33%;" />

<p><strong>解题思路</strong></p>
<ul>
<li>对两个参数链表进行翻转，翻转之后，对对应的位进行一个相加进位处理。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>给定一个单链表的头节点，请你反转链表，并且返回反转之后的链表。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">示例1：</span></span><br><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br><span class="line"><span class="meta">#</span><span class="bash">示例2：</span></span><br><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br><span class="line"><span class="meta">#</span><span class="bash">示例3：</span></span><br><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p>解题思路：</p>
<blockquote>
<p>（1）直接将链表prev和next指针原地反转</p>
<p>（2）返回新的链表头节点</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">reverseList</span><span class="params">(struct ListNode *head)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">prev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        node = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = prev;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><p>给定一个单向链表的头节点，从尾到头反过来返回每一个节点的值（用数据返回）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">示例1</span></span><br><span class="line">输入：head = [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br><span class="line">限制：0 &lt;= 链表长度 &lt;= 10000</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解题思路：</p>
<p>（1）先将链表进行反转，同时获取链表长度</p>
<p>（2）将反转后的链表的值从头到尾赋值给数组，并返回数组。</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">reverseList</span><span class="params">(struct ListNode *head, <span class="keyword">int</span> *len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *len = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">prev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        (*len)++;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> =</span> cur-&gt;next;</span><br><span class="line">        cur-&gt;next = prev;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从尾到头打印链表</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">reversePrint</span><span class="params">(struct ListNode* head, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!returnSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">new_list</span> =</span> reverseList(head, &amp;len);</span><br><span class="line">    <span class="keyword">int</span> *retArray = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * len);</span><br><span class="line">    <span class="keyword">if</span> (!retArray) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">ptr</span> =</span> new_list;</span><br><span class="line"> 	<span class="keyword">while</span> (ptr) &#123;</span><br><span class="line">        retArray[i++] = ptr-&gt;val;</span><br><span class="line">        ptr = ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h2><p>给定一个已排序的链表的表头head，删除所有重复的元素，使得每个元素只出现一次，返回已排序的链表。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">输入：[1,1,2]</span><br><span class="line">输出：[1,2]</span><br><span class="line"></span><br><span class="line">输入：head = [1,1,2,3,3]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解题思路：</p>
<p>（1）将当前节点与下一个节点进行比较</p>
<p>（2）如果两个节点的值相同，则将下一个节点释放表，以此类推。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">deleteDuplicates</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;next &amp;&amp; (node-&gt;next-&gt;val == node-&gt;val)) &#123;</span><br><span class="line">            tmp = node-&gt;next;</span><br><span class="line">            node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h2><blockquote>
<p>解题思路：</p>
<p>（1）</p>
<p>（2）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">getIntersectionNode</span><span class="params">(struct ListNode *headA, struct ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!headA || !headB)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node1</span> =</span> headA;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node2</span> =</span> headB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (node1 != node2) &#123;</span><br><span class="line">        node1 = node1 ? node1-&gt;next : headB;</span><br><span class="line">        node2 = node2 ? node2-&gt;next : headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br><span class="line"></span><br><span class="line">输入：head = [], val = 1</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">输入：head = [7,7,7,7], val = 7</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解题思路：</p>
<p>（1）在前面增加一个哨兵节点</p>
<p>（2）使用迭代的方式，进行链表遍历操作</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">removeElements</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">guard_head</span> =</span> (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    <span class="keyword">if</span> (!guard_head)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    guard_head-&gt;next = head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span> =</span> guard_head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (node-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;next-&gt;val == val) &#123;</span><br><span class="line">            tmp = node-&gt;next;</span><br><span class="line">            node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> guard_head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2021/01/07/735e5788.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>排序算法对于我们程序员来讲肯定是不陌生的，我们平时工作的过程中肯定也遇到需要对数据就行排序的情况。现在大多数的高级语言已经对这些排序算法进行封装，并且性能也很不错，但是了解这些算法背后的思想却是很有必要的，能够很好提升我们思维。</p>
<p>十大经典排序算法为：冒泡，选择，插入、希尔、归并、快速、堆、计数、桶、基数</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 打印数组元素 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> a[] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">  print_array(a, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>])); </span><br><span class="line">  <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// BubbleSort(a, sizeof(a)/sizeof(a[0]));</span></span><br><span class="line">  SelectSort(a, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line">  print_array(a, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>（1）比较相邻的两个元素，如果第一个比第二个大，就交换他们。</p>
<p>（2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>
<p>（3）针对所有的元素重复以上的步骤，除了最后一个。</p>
<img src="/images/image-20210220125922984.png" alt="image-20210220125922984" style="zoom:40%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* C语言代码实现 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len<span class="number">-1</span>-i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                Swap(&amp;<span class="built_in">array</span>[j], &amp;<span class="built_in">array</span>[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* C语言代码实现 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> min, index;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; len<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min = <span class="built_in">array</span>[i];</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="keyword">for</span> ( j = i+<span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; <span class="built_in">array</span>[j])</span><br><span class="line">            &#123;</span><br><span class="line">                min = <span class="built_in">array</span>[j];</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Swap(&amp;<span class="built_in">array</span>[i], &amp;<span class="built_in">array</span>[index]);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* C语言代码实现 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = <span class="built_in">array</span>[i];</span><br><span class="line">        <span class="keyword">for</span> ( j = i<span class="number">-1</span>; j &gt;=<span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* code */</span></span><br><span class="line">            <span class="keyword">if</span> (temp &lt; <span class="built_in">array</span>[j])&#123;</span><br><span class="line">                <span class="built_in">array</span>[j+<span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[j+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>海量数据处理问题</title>
    <url>/2021/01/07/39a6906f.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="海量日志数据，提取出某日访问百度次数最多的那个IP。"><a href="#海量日志数据，提取出某日访问百度次数最多的那个IP。" class="headerlink" title="海量日志数据，提取出某日访问百度次数最多的那个IP。"></a>海量日志数据，提取出某日访问百度次数最多的那个IP。</h3><p>首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。</p>
<a id="more"></a>

<p>算法思想：分而治之+哈希</p>
<p>1、IP地址最多有2^32=4G种取值情况，所以不能一次性直接都完全加载到内存中。</p>
<p>2、考虑分而治之的思想，将IP地址进行hash(IP)%1024，把海量的数据分别存储到1024个文件中，这样，每个文件最有就含有4MB个IP地址。</p>
<p>3、对于每一个小文件，可以进行构造一个key value的hash map，将IP作为key值，出现的次数作为value值，同时记录下当前出现次数最多的那个IP地址。</p>
<p>4、可以得到1024个文件📃中出现次数最多的IP，再根据常规的排序算法得到总体上的出现次数最多的IP。</p>
<h3 id="搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节"><a href="#搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节" class="headerlink" title="搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节"></a>搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节</h3><p>假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p>
<p>算法思想：经典的topK问题。</p>
<p>1、先对这批海量数据进行预处理，在O(n)的时间之内用hash表完成统计。</p>
<p>2、借助堆这个数据结构，找出topk，时间复杂度为nlogK。借助堆这个数据结构，我们可以在log量级的时间内查找和调整移动。我们可以维护一个大顶堆，然后遍历这300万左右的数据，分别和根元素进行比对，最后得出前十个热门的查询串。</p>
<h3 id="有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词"><a href="#有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词" class="headerlink" title="有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词"></a>有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词</h3><p>算法思想：分而治之+hash</p>
<p>1、顺序读取文件，对于读取的每一个值，可以使用hash(x)%5000，将读取的词存储到5000个文件中，每个文件大概200k，如果还是有文件大于1m，可以按照这个方法继续往下分，直到可以直接放入内存中为止。</p>
<p>2、对于每一个小文件，统计每个文件节点中出现的词以及相应的一个频率（tries树🌲或者hashMap都可以）。取出出现频率最大的一百个词（可以采用含有100个节点的最小堆），这样又可以得到5000个文件。最后一步，可以将这5000个文件进行归并过程了（类似于归并排序）。</p>
<h3 id="在2-5亿个整数中找出不重复的整数，内存不足以容纳这2-5亿个整数。"><a href="#在2-5亿个整数中找出不重复的整数，内存不足以容纳这2-5亿个整数。" class="headerlink" title="在2.5亿个整数中找出不重复的整数，内存不足以容纳这2.5亿个整数。"></a>在2.5亿个整数中找出不重复的整数，内存不足以容纳这2.5亿个整数。</h3><p>方案1：可以采用2-bitmap进行，共需要内存</p>
<h3 id="海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。"><a href="#海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。" class="headerlink" title="海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。"></a>海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。</h3><h3 id="腾讯面试题：给40亿个不重复的unsigned-int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？"><a href="#腾讯面试题：给40亿个不重复的unsigned-int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？" class="headerlink" title="腾讯面试题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？"></a>腾讯面试题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</h3><p>使用bitmap，或者布隆过滤器。</p>
<h3 id="10亿个域名如何判断，新来一个域名，如何判断在还是不在"><a href="#10亿个域名如何判断，新来一个域名，如何判断在还是不在" class="headerlink" title="10亿个域名如何判断，新来一个域名，如何判断在还是不在"></a>10亿个域名如何判断，新来一个域名，如何判断在还是不在</h3><p>可以使用布隆过滤器，判断不在就一定不在，判断在的话可能不在。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>结构体对齐</title>
    <url>/2021/01/06/6aac47f4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="结构体对齐"><a href="#结构体对齐" class="headerlink" title="结构体对齐"></a>结构体对齐</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><blockquote>
<p>&ensp;&ensp;&ensp;&ensp;结构体对齐一直是一个老生常谈的问题，我面试过就被问过几次，但是每一次都复习准备好好的，但是一到面试时候，总能被面试官问倒（卑微~）其实主要的原因就是自己没有准确的深刻的理解结构体对齐这个知识点，没有对其进行一个总结。</p>
</blockquote>
<h2 id="为什么需要结构体对齐"><a href="#为什么需要结构体对齐" class="headerlink" title="为什么需要结构体对齐"></a>为什么需要结构体对齐</h2><p>&ensp;&ensp;&ensp;&ensp;结构体需要对其的原因主要就是对CPU对内存访问效率优化的一个问题。假设是intel 32的CPU， 每个总线周期都是要从偶地址读取32位的内存数据。</p>
<p>假设我们的CPU和总线都是64位的，每次可以从内存中获取8个字节（Byte）64位（bit）的数据，这8个字节就是对齐的，假设就是0<del>7，8</del>15类似这样，你不能从中间3<del>10这样取值。如果需要取值3</del>10之间的数据，就需要取两次，分别是0<del>7，再取8</del>15。所以CPU的取值效率就下降了。</p>
<a id="more"></a>

<h2 id="对齐的几个基本的原则"><a href="#对齐的几个基本的原则" class="headerlink" title="对齐的几个基本的原则"></a>对齐的几个基本的原则</h2><p>1、结构体变量的起始地址能够被其最宽的成员大小整除。</p>
<p>2、结构体每个成员相对于起始地址的偏移能够被自身大小整除，如果不能则在前一个成员后面补充字节。</p>
<p>3、结构体总的大小能够被最宽的成员大小整除，如果不能则是在后面进行一个补齐。</p>
<p>结构体其实也是可以指定编译器对齐大小的，例如以下的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">	<span class="keyword">int</span>  b;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">a</span>;</span></span><br></pre></td></tr></table></figure>
<p>sizeof(a)的大小为5。</p>
<h2 id="几种变形情况"><a href="#几种变形情况" class="headerlink" title="几种变形情况"></a>几种变形情况</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">	<span class="keyword">int</span>  b;</span><br><span class="line">	<span class="keyword">short</span> c;</span><br><span class="line">&#125;A1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>变量a，自身按1字节对齐，</p>
</blockquote>
<p>未完待续~</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://www.zhihu.com/question/27862634">https://www.zhihu.com/question/27862634</a></p>
<p>[2] <a href="https://cloud.tencent.com/developer/article/1055149?from=information.detail.linux%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90">https://cloud.tencent.com/developer/article/1055149?from=information.detail.linux%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90</a></p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>进程间通信</title>
    <url>/2021/01/04/a9fd59ec.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p><strong>原子操作</strong>，即不可分割开的操作；该操作一定是在同一个cpu时间片中完成，这样即使线程被切换，多个线程也不会看到同一块内存中不完整的数据。</p>
<p>线程同步的主要方式–线程锁 线程同步最常用的方法是使用<strong>锁</strong>(Lock)。锁是一种非强制机制，每一个线程访问数据或资源之前，首先试图获取(Acquireuytreewq)锁,并在访问结束之后释放(release)。在锁已经被占用时获取锁，线程会等待，直到该锁被释放。</p>
<a id="more"></a>

<p><strong>互斥锁</strong> 是在很多平台上都比较常用的一种锁。它属于sleep-waiting类型的锁。即当锁处于占用状态时，其他线程会挂起，当锁被释放时，所有等待的线程都将被唤醒，再次对锁进行竞争。在挂起与释放过程中，涉及用户态与内核态之间的context切换，而这种切换是比较消耗性能的。</p>
<p><strong>自旋锁</strong> 与互斥锁有点类似，只是自旋锁被某线程占用时，其他线程不会进入睡眠(挂起)状态，而是一直运行（自旋/空转）直到锁被释放。由于不涉及用户态与内核态之间的切换，它的效率远远高于互斥锁。</p>
<p>**信号量(Semaphore)**，有时被称为信号灯，是在多线程环境下使用的一种设施, 它负责协调各个线程, 以保证它们能够正确、合理的使用公共资源。</p>
<p>信号量可以分为几类：</p>
<ul>
<li>二进制信号量(binary semaphore) / 二元信号量 ：只允许信号量取0或1值，，只有两种状态：占用与非占用，其同时只能被一个线程获取。</li>
<li>整型信号量（integer semaphore)：信号量取值是整数，它可以被多个线程同时获得，直到信号量的值变为0。</li>
<li>记录型信号量（record semaphore)：每个信号量s除一个整数值value（计数）外，还有一个等待队列List，其中是阻塞在该信号量的各个线程的标识。当信号量被释放一个，值被加一后，系统自动从等待队列中唤醒一个等待中的线程，让其获得信号量，同时信号量再减一。</li>
</ul>
<p>信号量通过一个计数器控制对共享资源的访问，信号量的值是一个非负整数，所有通过它的线程都会将该整数减一。如果计数器大于0，则访问被允许，计数器减1；如果为0，则访问被禁止，所有试图通过它的线程都将处于等待状态。</p>
<p><strong>条件变量</strong> （Condition Variable） 作为一种同步手段类似于栅栏，允许线程以一种无竞争的方式等待某个条件的发生。当该条件没有发生时，线程会一直处于休眠状态。当被其它线程通知条件已经发生时，线程才会被唤醒从而继续向下执行。条件变量是比较底层的同步原语，直接使用的情况不多，往往用于实现高层之间的线程同步。使用条件变量的一个经典的例子就是线程池(Thread Pool)了。</p>
<p>未完待续~</p>
</blockquote>
<h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><blockquote>
<p>共享内存允许两个或者多个进程共享一个给定的存储区，因为数据不需要再客户即和服务器之间复制，所以共享内存是最快的一种 I IPC。使用共享内存唯一的诀窍就是多个进程之间对一给定的存储区之间数据的同步存取问题。通常，信号量被用来实现对共享存储存取的同步。（记录锁也可以用于这种场合）。</p>
<p>对于操作系统而言，在并行程序设计中难免会遇到数据同步和共享的问题，本文针对这个问题，以windows系统为例回顾一下资源同步的相关问题。</p>
<p>要点如下：</p>
<p>1.同步和数据共享数据征用</p>
<p>2.同步原语 1.互斥和临界区 2.自旋锁 3.信号量 4.读写锁 5.屏障 6.原子操作与无锁代码</p>
</blockquote>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p>[1] <a href="https://juejin.cn/post/6844903543527178248">https://juejin.cn/post/6844903543527178248</a></p>
]]></content>
      <categories>
        <category>Unix环境高级编程</category>
      </categories>
  </entry>
  <entry>
    <title>信号Signal</title>
    <url>/2021/01/03/67a506ce.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h1><p>信号是一种软中断，信号提供了一种处理异步事件的方法。通过<code>kill -l</code>命令我们可以很清楚的看待linux下对应的信号有64个。这些信号主要可以分为两大类，<strong>可靠信号</strong>与<strong>不可靠信号</strong>。</p>
<a id="more"></a>

<p>信号的产生：比如终端运行着一个程序，我们在设备输入一个ctrl+c中断停止的按键，那么我们实际上通过触发一个信号停止了一个程序。</p>
<p>信号的处理:</p>
<p>（1）可以直接将其忽略掉。大多数信号可以直接忽略掉但有两种信号却决不能被忽略，它们是SIGKILL和SIGSTOP信号。</p>
<p>（2）捕捉信号，注册信号处理函数。</p>
<p>（3）执行系统的默认动作。</p>
<p>信号</p>
<p>未完待续~</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://blog.csdn.net/wangquan1992/article/details/108511628">https://blog.csdn.net/wangquan1992/article/details/108511628</a></p>
]]></content>
      <categories>
        <category>Unix环境高级编程</category>
      </categories>
  </entry>
  <entry>
    <title>手撕代码</title>
    <url>/2020/12/27/7a4494fd.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="面试常见的手撕代码题型"><a href="#面试常见的手撕代码题型" class="headerlink" title="面试常见的手撕代码题型"></a>面试常见的手撕代码题型</h1><p>所有代码都已经跑过，可以正常编译运行。</p>
<a id="more"></a>

<h2 id="经典排序"><a href="#经典排序" class="headerlink" title="经典排序"></a>经典排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 交换两个数据 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp;</span><br><span class="line">  temp = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = temp;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 冒牌排序算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == arr)</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;len-i<span class="number">-1</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j]&lt;arr[j<span class="number">-1</span>])</span><br><span class="line">        swap(arr[j], arr[j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> arr[<span class="number">10</span>]=&#123;<span class="number">7</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">  BubbleSort(arr);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p>0 1 5 7 7 7 8 8 9</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp;</span><br><span class="line">  temp = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = temp;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j, temp;</span><br><span class="line">  <span class="keyword">if</span>(left &gt; right)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">/* temp存放的是基数 */</span></span><br><span class="line">  temp = arr[left];</span><br><span class="line">  i = left;</span><br><span class="line">  j = right;</span><br><span class="line">  <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line">    <span class="comment">/* 顺序很重要，要从右边开始找 */</span></span><br><span class="line">    <span class="keyword">while</span>(arr[j] &gt;= temp &amp;&amp; i &lt; j)</span><br><span class="line">      j--;</span><br><span class="line">    <span class="comment">/* 再从左开始找 */</span></span><br><span class="line">    <span class="keyword">while</span>(arr[i] &lt;= temp &amp;&amp; i &lt; j)</span><br><span class="line">      i++;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; j)</span><br><span class="line">      swap(&amp;arr[i], &amp;arr[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  arr[left] = arr[i];</span><br><span class="line">  arr[i] = temp;</span><br><span class="line">  </span><br><span class="line">  quickSort(left, i<span class="number">-1</span>);</span><br><span class="line">  quickSort(i+<span class="number">1</span>, right);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分查找也叫做折半查找，其优点是查找速度快，缺点是要求所要査找的数据必须是有序序列。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hight = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid, midVal;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= hight)&#123;</span><br><span class="line">        mid = (low+hight)/<span class="number">2</span>;</span><br><span class="line">        midVal = arr[mid];</span><br><span class="line">        <span class="keyword">if</span>(midVal &lt; key)</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(midVal &gt; key)</span><br><span class="line">            hight = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>]=&#123;<span class="number">-32</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">36</span>, <span class="number">45</span>, <span class="number">59</span>, <span class="number">98</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]); i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input the data.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;key);</span><br><span class="line">    <span class="keyword">int</span> ret = binarySearch(a, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]), key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == ret)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the key %d is exits.\n&quot;</span>, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the key %d is not exits.\n&quot;</span>, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表操作"><a href="#链表操作" class="headerlink" title="链表操作"></a>链表操作</h2><h3 id="反转单链表"><a href="#反转单链表" class="headerlink" title="反转单链表"></a>反转单链表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义链表结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">listNode</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;listNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 反转链表 */</span></span><br><span class="line"><span class="function">listNode *<span class="title">reverseList</span><span class="params">(listNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == head || <span class="literal">NULL</span> == head-&gt;next)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  listNode *cur = head;</span><br><span class="line">  listNode *prev = <span class="literal">NULL</span>;</span><br><span class="line">  listNode *next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">/* 存放下一个节点 */</span></span><br><span class="line">    next = cur-&gt;next;</span><br><span class="line">    <span class="comment">/* 翻转头结点的下一个节点 */</span></span><br><span class="line">    cur-&gt;next = prev;</span><br><span class="line">    <span class="comment">/* 移动上一个节点 */</span></span><br><span class="line">    prev = cur;</span><br><span class="line">    <span class="comment">/* 更新当前节点 */</span></span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> prev；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[]=&#123;<span class="number">7</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>])); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>==i%<span class="number">16</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 判断链表是否有环 */</span></span><br><span class="line"><span class="function">linkNode *<span class="title">isCircle</span><span class="params">(linkNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(head != <span class="literal">NULL</span>);</span><br><span class="line">    linkNode *slow = head-&gt;next;               <span class="comment">/* 慢指针 */</span></span><br><span class="line">    linkNode *fast = head-&gt;next-&gt;next;         <span class="comment">/* 快指针 */</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(slow == fast)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;   <span class="comment">/* 无环 */</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> slow;    <span class="comment">/* 有环 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="实现memcpy函数"><a href="#实现memcpy函数" class="headerlink" title="实现memcpy函数"></a>实现memcpy函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 不考虑内存重叠的情况 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">myMemcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == dest||<span class="literal">NULL</span> == src)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">char</span> *d = (<span class="keyword">char</span> *)dest;</span><br><span class="line">  <span class="keyword">char</span> *s = (<span class="keyword">char</span> *)src;</span><br><span class="line">  <span class="keyword">while</span>(n--)</span><br><span class="line">    *d++ = *s++;</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 优化版本按照CPU位宽度进行拷贝优化 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  *<span class="title">myMemcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> nchucks = num/<span class="keyword">sizeof</span>(dest);  <span class="comment">/* 按照CPU的位宽进行拷贝 */</span></span><br><span class="line">  <span class="keyword">int</span> slice = num%/<span class="keyword">sizeof</span>(dest);   <span class="comment">/* 剩余的字节数按照一个一个字节进行拷贝 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> *s = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)src;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> *d = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)dest;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">while</span>(nchucks--)</span><br><span class="line">    *d++ = *s++;</span><br><span class="line">  <span class="keyword">while</span>(slice--)</span><br><span class="line">    *((<span class="keyword">char</span>*)d++) = *((<span class="keyword">char</span>*)s++);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 考虑内存重叠的情况 */</span></span><br></pre></td></tr></table></figure>


<h3 id="实现strstr函数"><a href="#实现strstr函数" class="headerlink" title="实现strstr函数"></a>实现strstr函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">myStrstr</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="实现strlen函数"><a href="#实现strlen函数" class="headerlink" title="实现strlen函数"></a>实现strlen函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myStrlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  assert(arr);</span><br><span class="line">  <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="string">&#x27;\0&#x27;</span> != *arr++)</span><br><span class="line">    count++;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="实现strcpy函数"><a href="#实现strcpy函数" class="headerlink" title="实现strcpy函数"></a>实现strcpy函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">myStrcpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  assert(dest);</span><br><span class="line">  assert(src);</span><br><span class="line">  <span class="keyword">char</span> *d = dest;</span><br><span class="line">  <span class="keyword">char</span> *s = src;</span><br><span class="line">  <span class="keyword">while</span>(<span class="string">&#x27;\0&#x27;</span> != *s)</span><br><span class="line">    *d++ = *s++;</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://blog.csdn.net/weixin_43496874/article/details/100868367?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control">https://blog.csdn.net/weixin_43496874/article/details/100868367?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control</a></p>
<p>[2] <a href="http://c.biancheng.net/cpp/html/2744.html">http://c.biancheng.net/cpp/html/2744.html</a></p>
]]></content>
      <categories>
        <category>面试宝典</category>
      </categories>
  </entry>
  <entry>
    <title>docker</title>
    <url>/2020/12/20/f255ffad.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Docker 类似一个虚拟机。</p>
<p>在docker中有几个基本的概念。</p>
<p>1、镜像：类似于平时使用的iso或者image镜像文件。</p>
<p>2、容器：容器其实就会类似于虚拟机</p>
<p>3、tar文件：类似于vmdk文件，可以直接打个包在别的地方直接run运行。</p>
<p>4、docker file。docker 的一些配置</p>
<p>5、仓库：存放有很多已经打包好的镜像，MySQL镜像、ngnix镜像等。</p>
<a id="more"></a>

<img src="/images/image-20201220085110478.png" alt="image-20201220085110478" style="zoom:33%;" />

<h2 id="常用的操作命令"><a href="#常用的操作命令" class="headerlink" title="常用的操作命令"></a>常用的操作命令</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接从远程仓库下载mysql镜像</span></span><br><span class="line">docker search mysql <span class="comment"># 查找mysql镜像</span></span><br><span class="line">docker pull mysql   <span class="comment"># 拉取mysql镜像</span></span><br><span class="line"><span class="comment"># 等价于命令docker pull mysql:latest,不指定版本会直接默认下载最新的版本镜像。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看本地的镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 删除镜像，注意：如果有容器示例正在使用该镜像则是无法删除，需要先停止删除容器示例。</span></span><br><span class="line">docker rmi &lt;imagesID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行容器</span></span><br><span class="line">docker run -d 3307:3306 mysql</span><br><span class="line"><span class="comment"># -d 指定后台运行不阻塞当前shell窗口</span></span><br><span class="line"><span class="comment"># -p 指定内外部端口映射 外部:内部</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看正在运行的容器，查看活跃的容器。</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment"># 查看所有的容器（包括运行和不运行的）</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it id bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动停止容器</span></span><br><span class="line">docker stop &lt;容器ID&gt;</span><br><span class="line">docker restart &lt;容器ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除docker实例</span></span><br><span class="line">docker rm -f 实例ID</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9、保存容器镜像</span></span><br><span class="line">docker commit 实例ID 新的名字</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入tar镜像</span></span><br><span class="line">docker load &lt; Test.tar</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="/images/image-20201220090133527.png" alt="image-20201220085110478" style="zoom:33%;" />

<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="在docker容器内出现命令没有的情况"><a href="#在docker容器内出现命令没有的情况" class="headerlink" title="在docker容器内出现命令没有的情况"></a>在docker容器内出现命令没有的情况</h3><p>1.执行命令<code>apt-get update</code>。</p>
<p>更新<code>/etc/apt/sources.list</code>和<code>/etc/apt/sources.list.d</code>目录下的源索引，更新软件包，</p>
<p>2、安装对应的软件包。</p>
<p>例如vim没有安装命令找不到，可以直接执行命令安装<code>apt-get install vi</code>。</p>
<p>3、宿主机<br>检查/etc/docker/daemon.json文件dns是否正常。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span>:[<span class="string">&quot;https:adada.com&quot;</span>],	<span class="comment">//镜像源</span></span><br><span class="line">  <span class="attr">&quot;dns&quot;</span>:[<span class="string">&quot;114.114.114.114&quot;</span>, <span class="string">&quot;8.8.8.8&quot;</span>]		<span class="comment">//dns</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>IO多路复用</title>
    <url>/2020/12/20/b21cb050.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>我们可以将标准输入、套接字等都看做IO的一路，多路复用的意思是在任何一路IO有事件的情况下，通知应用程序去处理相应的IO事件，这样程序就仿佛可以同一时刻处理多个IO事件了。</p>
</blockquote>
<a id="more"></a>

<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><blockquote>
<ul>
<li><p>select fd_set结构，底层是一个bitmap结构，是定长的1024，不容易改，如果需要改需要重新编译内核代码。</p>
</li>
<li><p>使用select函数，通知内核挂起进程，当一个或者多个IO事件发生之后，控制权限返回给应用程序，由应用程序进行IO事件的处理。</p>
</li>
<li><p>当有事件发生的时候，并不知道具体是哪几条流（可能有一个也可能有多个），只能轮询一遍出所有的流，找出相应的数据，或者写入数据的流，**时间复杂度为O(n)**。</p>
</li>
<li><p>需要维护一个存放大量fd的数据结构，当用户空间向内核空间传递该数据结构的时候会发生大量的拷贝，拷贝开销大，从而影响效率。</p>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfd, fd_set *readset, fd_set *writeset, fd_set *expectset, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">	<span class="keyword">long</span> tv_sec;		<span class="comment">/* 秒 */</span></span><br><span class="line">	<span class="keyword">long</span> tv_usec;		<span class="comment">/* 微秒 */</span></span><br><span class="line">&#125;</span><br><span class="line">timeout可以有三种情况：</span><br><span class="line">timeout == <span class="literal">NULL</span>;	<span class="comment">/* 等待无限长的时间 */</span></span><br><span class="line">timeout-&gt;tv_sec == <span class="number">0</span> &amp;&amp; timeout-&gt;tv_usec == <span class="number">0</span>	<span class="comment">/* 不等待，直接返回。（Noblock 非阻塞）*/</span></span><br><span class="line">timeout-&gt;tv_sec != <span class="number">0</span> || timeout-&gt;usec != <span class="number">0</span>	<span class="comment">/* 等待指定的时间 */</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* FD_ZERO 将一个fd_set类型的变量的所有的位都设置为0 */</span></span><br><span class="line"><span class="keyword">int</span> FD_ZERO(fd_set *fdset);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* FD_CLR 可以将某一个位进行清除 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_CLR</span><span class="params">(fd_set *fdset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* FD_SET 用来将某一个位进行置位1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* FD_ISSET 用来检测某一个位是否被置位 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>返回值（return value）:做好准备的文件描述符个数，超时为0， 错误为-1。</p>
<p>中间的三个参数readset、writeset、exepectset，分别是读描述符集合 readset、写描述符集合 writeset 和异常描述符集合 exceptset，这些参数指明了我们关心哪一些描述符，和需要满足什么条件。一个文件描述符保存在fd_set类型之中，fd_set其实就是一个位图bitmap。</p>
<p>int maxfd; 指的是最大的文件描述符加1。</p>
<p>Linux环境下编程，系统给提供了一组宏定义，可以对我们的fd_set进行赋值等操作。</p>
<p>Demo:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        error(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;usage: select01 &lt;IPaddress&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> socket_fd = tcp_client(argv[<span class="number">1</span>], SERV_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> recv_line[MAXLINE], send_line[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    fd_set readmask;</span><br><span class="line">    fd_set allreads;</span><br><span class="line">    FD_ZERO(&amp;allreads);</span><br><span class="line">    FD_SET(<span class="number">0</span>, &amp;allreads);</span><br><span class="line">    FD_SET(socket_fd, &amp;allreads);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        readmask = allreads;</span><br><span class="line">        <span class="keyword">int</span> rc = select(socket_fd + <span class="number">1</span>, &amp;readmask, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rc &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            error(<span class="number">1</span>, errno, <span class="string">&quot;select failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(socket_fd, &amp;readmask)) &#123;</span><br><span class="line">            n = read(socket_fd, recv_line, MAXLINE);</span><br><span class="line">            <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                error(<span class="number">1</span>, errno, <span class="string">&quot;read error&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                error(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;server terminated \n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            recv_line[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">fputs</span>(recv_line, <span class="built_in">stdout</span>);</span><br><span class="line">            <span class="built_in">fputs</span>(<span class="string">&quot;\n&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(STDIN_FILENO, &amp;readmask)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fgets(send_line, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="built_in">strlen</span>(send_line);</span><br><span class="line">                <span class="keyword">if</span> (send_line[i - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                    send_line[i - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;now sending %s\n&quot;</span>, send_line);</span><br><span class="line">                <span class="keyword">size_t</span> rt = write(socket_fd, send_line, <span class="built_in">strlen</span>(send_line));</span><br><span class="line">                <span class="keyword">if</span> (rt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    error(<span class="number">1</span>, errno, <span class="string">&quot;write failed &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;send bytes: %zu \n&quot;</span>, rt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h1><blockquote>
<p>poll其实本质和select一样没有太大的区别，主要有几点改变。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"> <span class="keyword">short</span> events;</span><br><span class="line"> <span class="keyword">short</span> revents;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">long</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Events可以表示多个不同的事件，具体的实现可以通过二进制掩码位操作来完成，例如<code>POLLIN</code>和<code>POLLOUT</code>表示可读可写事件。</p>
</li>
<li><p>与select不同的在于，poll每次检测之后的结果不会修改元凯的传入的值，而是将结果保留在revents字段中，这样就不用每次检测完成之后都要重置待检测的描述字和感兴趣的事件。revents可以理解<code>return events</code>。</p>
</li>
<li><p>如果对某个pollfd结构进行事件检测，可以将对应的pollfd结构的fd成员设置成一个负值，poll函数将会忽略该事件。</p>
</li>
<li><p>突破了select(1024)最大文件描述符的限制，原因是它是基于链表来存储</p>
</li>
</ul>
<p><strong>同样存在缺点</strong></p>
<p>1、依旧是大量的fd数组在用户空间和内核空间之间进行拷贝。</p>
<p>2、poll是水平触发，如果fd就绪被报告之后没有对其进行处理，下次poll韩式会再次报告该事件。</p>
</blockquote>
<h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><p>epoll接口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>


<blockquote>
<ul>
<li><p>epoll_create 函数是一个系统调用函数，函数将会在内核空间开辟一块新的空间，可以理解为epoll结构空间，返回值为epoll的文件描述符编号，方便后续操作使用。</p>
</li>
<li><p>epoll_ctl是epoll事件的注册函数，epoll与select不同，select函数是调用时指定的需要监听的描述符和事件，epoll先将用户感兴趣的描述符事件注册到epoll空间内，此函数是非阻塞函数，作用仅仅是增删改epoll空间内的描述符信息。<br>  参数1：epfd，epoll结构的进程fd编号，函数将依靠该编号找到对应的epoll结构。<br>  参数2：op，表示当前的请求的类型，由三个定义：</p>
<p>  EPOLL_CTL_ADD:注册新的fd到epoll中。</p>
<p>  EPOLL_CTL_MOD:修改已经注册的fd的监听事件。</p>
</li>
</ul>
<p>EPOLL_CTL_DEL:从epfd中删除一个fd。<br>    参数3：fd,需要监听的文件描述符，一般指的是sockfd。<br>    参数4：event，告诉内核该fd资源感兴趣的事件。</p>
<ul>
<li>epoll_wait函数，等待事件的发生，类似于select()函数调用。根据参数timeout，决定是否处于阻塞模式。<br>  参数1：epfd，指定一个感兴趣事件列表。<br>  参数2：*events，是一个指针，必须指向一个epoll_event结构数组，当函数返回的时候，内核会将就绪状态的的数据拷贝到该数组中。<br>  参数3：maxevents，标明参数2epoll_event结构数组最多能接收的数据量，即本次操作做多能获取多少就绪数据。<br>  参数4: timeout，单位为毫秒。  0：表示立即返回。   -1：阻塞调用，直到有用户感兴趣事件就绪为止。</li>
</ul>
<p><strong>epoll_create函数</strong></p>
<ul>
<li>epoll_create 函数是一个系统调用函数，函数将会在内核空间开辟一块新的空间，可以理解为epoll结构空间，返回值为epoll的文件描述符编号，方便后续操作使用。</li>
</ul>
<p><strong>epoll_ctl函数</strong></p>
<p>epoll_ctl是epoll事件的注册函数，epoll与select不同，select函数是调用时指定的需要监听的描述符和事件，epoll先将用户感兴趣的描述符事件注册到epoll空间内，此函数是非阻塞函数，作用仅仅是增删改epoll空间内的描述符信息。</p>
<ul>
<li><p>参数1：epfd，epoll结构的进程fd编号，函数将依靠该编号找到对应的epoll结构。</p>
</li>
<li><p>参数2：op，表示当前的请求的类型，由三个定义：</p>
</li>
</ul>
<p>EPOLL_CTL_ADD:注册新的fd到epoll中。</p>
<p>EPOLL_CTL_MOD:修改已经注册的fd的监听事件。</p>
<p>EPOLL_CTL_DEL:从epfd中删除一个fd。</p>
<ul>
<li><p>参数3：fd,需要监听的文件描述符，一般指的是sockfd。</p>
</li>
<li><p>参数4：event，告诉内核该fd资源感兴趣的事件。</p>
</li>
</ul>
<p><strong>epoll_wait函数</strong></p>
<p>epoll_wait函数，等待事件的发生，类似于select()函数调用。根据参数timeout，决定是否处于阻塞模式。</p>
<ul>
<li><p>参数1：epfd，指定一个感兴趣事件列表.。</p>
</li>
<li><p>参数2：*events，是一个指针，必须指向一个epoll_event结构数组，当函数返回的时候，内核会将就绪状态的的数据拷贝到该数组中。</p>
</li>
<li><p>参数3：maxevents，标明参数2epoll_event结构数组最多能接收的数据量，即本次操作做多能获取多少就绪数据。</p>
</li>
<li><p>参数4: timeout，单位为毫秒。</p>
</li>
</ul>
<p>0 表示立即返回。</p>
<p>-1 阻塞调用，直到有用户感兴趣事件就绪为止。</p>
<p>&gt;0 阻塞调用，阻塞指定的时间内如果有时间就绪则是提前返回，否则就等待指定的事件后返回。<br>  返回值（return value）：本次就绪的fd的个数。</p>
<p><strong>工作模式</strong></p>
<p>epoll对文件描述符的操作有两种模式：LT(水平触发)和ET(边缘触发)。LT是默认模式，两者的区别如下：</p>
<p>LT(level 水平触发)：事件就绪之后，用户可以选择处理或者不处理，如果用户本次未进行处理，那么下次调用epoll_wait时候仍然会将未出的事件打包给你。</p>
<p>ET(edge 边缘触发)： 事件就绪之后，用户必须处理，因为内核不给给你兜底，内核把就绪的事件打包给用户态之后，就会把对应的就绪事件清理掉，不会再次通知用户。</p>
<p>ET模式在很大的程度上减少了epoll事件被重复触发的次数，因此被认为效率比LT模式高，也是epoll重要的杀手锏。</p>
<p><strong>epoll优点</strong></p>
<p>1、没有最大文件描述符限制</p>
<p>2、使用mmap文件映射内存加速与内核空间的消息传递，不再是大量的fd从用户空间拷贝到内核空间，大大减少了拷贝的开销。</p>
<p>3、效率提升，不再使用轮询</p>
</blockquote>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://blog.csdn.net/qq_35976351/article/details/85228002">https://blog.csdn.net/qq_35976351/article/details/85228002</a></p>
<p>[2] <a href="https://time.geekbang.org/column/article/138948">https://time.geekbang.org/column/article/138948</a></p>
]]></content>
      <categories>
        <category>Unix环境高级编程</category>
      </categories>
  </entry>
  <entry>
    <title>编写Makefile</title>
    <url>/2020/10/06/dfbf19f0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="编写Makefile"><a href="#编写Makefile" class="headerlink" title="编写Makefile"></a>编写Makefile</h1><hr>
<p>&ensp;&ensp;&ensp;&ensp;Makefile编写的好可以在工程项目编译链接的过程中省去很多麻烦，平时在练习的过程中也是能方便高效的学习。</p>
<blockquote>
<ul>
<li>整理知识，学习笔记</li>
<li>发布日记，杂文，所见所想</li>
<li>撰写发布技术文稿（代码支持）</li>
<li>撰写发布学术论文（LaTeX 公式支持）</li>
</ul>
</blockquote>
<a id="more"></a>

<p><img src="https://www.zybuluo.com/static/img/logo.png" alt="cmd-markdown-logo"></p>
<h2 id="一、Makefile相关知识点"><a href="#一、Makefile相关知识点" class="headerlink" title="一、Makefile相关知识点"></a>一、Makefile相关知识点</h2><p>&ensp;&ensp;&ensp;&ensp;需要掌握的一些Makefile相关的基础知识。</p>
<h3 id="1-忽略出错的命令。"><a href="#1-忽略出错的命令。" class="headerlink" title="1. 忽略出错的命令。"></a>1. 忽略出错的命令。</h3><p>&ensp;&ensp;&ensp;&ensp;如果不希望某条命令因为出错了而导致整个make执行被终止，可以在命令前面加上“-”，表示不管该命令出不出错，后面的命令都将继续执行下去。如：<br>&ensp;&ensp;&ensp;&ensp;mkdir lpyuan<br>&ensp;&ensp;&ensp;&ensp;如果不加“-”并且dir已经存在，则这条命令就会出错，并将导致整个make执行被终止。要想不被终止，则需要在前加上’-‘符号。<br>&ensp;&ensp;&ensp;&ensp;-mkdir dir</p>
<h3 id="2-显示命令。"><a href="#2-显示命令。" class="headerlink" title="2. 显示命令。"></a>2. 显示命令。</h3><p>&ensp;&ensp;&ensp;&ensp;一般默认make会把命令原样显示出来后再去执行命令，如果我们不需要原样显示命令，则可以在命令前面加一个“@”， 如<br>&ensp;&ensp;&ensp;&ensp;@m -rf lpyuan<br>&ensp;&ensp;&ensp;&ensp;则是不会输出命令。</p>
<h3 id="3-特殊符号。"><a href="#3-特殊符号。" class="headerlink" title="3. 特殊符号。"></a>3. 特殊符号。</h3><p>&ensp;&ensp;&ensp;&ensp;$@  表示目标文件<br>&ensp;&ensp;&ensp;&ensp;$^  表示所有的依赖文件<br>&ensp;&ensp;&ensp;&ensp;$&lt;  表示第一个依赖文件<br>&ensp;&ensp;&ensp;&ensp;$?  表示比目标还要新的依赖文件列表</p>
<p>如一个目录下有如下文件：<br>&ensp;&ensp;&ensp;&ensp;hello.c&ensp;&ensp;hi.c&ensp;&ensp;main.c&ensp;&ensp;Makefile<br>按照 Makefile 规则规规矩矩的写：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">main: main.o hello.o hi.o</span></span><br><span class="line">        gcc -o main main.o hello.o hi.o</span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">        cc -c main.c</span><br><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">        cc -c hello.c</span><br><span class="line"><span class="section">hi.o: hi.c</span></span><br><span class="line">        cc -c hi.c</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm *.o</span><br><span class="line">        rm main</span><br><span class="line">        </span><br><span class="line">改为用上述符号进行替代：</span><br><span class="line"></span><br><span class="line"><span class="section">main: main.o hello.o hi.o</span></span><br><span class="line">        gcc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">        cc -c <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">        cc -c <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">hi.o: hi.c</span></span><br><span class="line">        cc -c <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm *.o</span><br><span class="line">        rm main</span><br></pre></td></tr></table></figure>
<h3 id="4-Makefile中的常用函数。"><a href="#4-Makefile中的常用函数。" class="headerlink" title="4. Makefile中的常用函数。"></a>4. Makefile中的常用函数。</h3><h4 id="4-1-函数名称-：反过滤函数—filter-out。"><a href="#4-1-函数名称-：反过滤函数—filter-out。" class="headerlink" title="4.1 函数名称 ：反过滤函数—filter-out。"></a>4.1 函数名称 ：反过滤函数—filter-out。</h4><p>格式：$(filter-out PATTERN…,TEXT)<br>函数功能 ：和“filter”函数实现的功能相反。过滤掉字串“TEXT”中所有符合“PATTERN”的单词，保留所有不符合的单词。可以多个模式。存在多模式时，模式表达式之间使用空格分割。<br>返回值 ：空格分割的“TEXT”字串中所有不符合模式“PATTERN”的字串。<br>函数说明： “filter-out”函数也可以用来去除一个变量中的某些字符串（实现和“filter”函数相反）。<br>下面有个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects=main1.o foo.o main2.o bar.o </span><br><span class="line">mains=main1.o main2.o</span><br><span class="line">$(filter-out<span class="variable">$(mains)</span>,<span class="variable">$(objects)</span>)</span><br><span class="line">实现了去除变量<span class="string">&quot;objects&quot;</span>中<span class="string">&quot;mains&quot;</span>定义的字串（文件名）功能。它的返回值为<span class="string">&quot;foo.o bar.o&quot;</span>。</span><br></pre></td></tr></table></figure>
<h3 id="5-调试Makefile变量"><a href="#5-调试Makefile变量" class="headerlink" title="5 调试Makefile变量"></a>5 调试Makefile变量</h3><h4 id="5-1-如何打印Makefile变量名"><a href="#5-1-如何打印Makefile变量名" class="headerlink" title="5.1 如何打印Makefile变量名"></a>5.1 如何打印Makefile变量名</h4><p>有时间我们的项目包含多个makefile文件，需要调试某个变量时候，make没有直接的调试器，这样就会使得我们定位为题很不好操作。</p>
<p>但是我们也有以下方法对进行调试。makefile展开所有变量之后才会进行执行编译，所以利用这个特性，我们可以创建一个vars.mk的makefile文件用于调试makefile文件中变量。</p>
<p>比如要打印<code>SRC</code>变量<code>make -f Makefile -f vars.mk SRC</code></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vars.mk</span></span><br><span class="line"><span class="section">print-%:</span></span><br><span class="line">	@echo &#x27;<span class="variable">$*</span>=$(<span class="variable">$*</span>)&#x27;</span><br><span class="line">	@echo <span class="string">&quot;origin=$(origin <span class="variable">$*</span>)&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;value=$(value <span class="variable">$*</span>)&quot;</span></span><br><span class="line">	@echo <span class="string">&quot;flavor=$(flavor <span class="variable">$*</span>)&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="5-2-查看make执行的具体命令"><a href="#5-2-查看make执行的具体命令" class="headerlink" title="5.2 查看make执行的具体命令"></a>5.2 查看make执行的具体命令</h4><p>有时候以下命令由于设置了一些选项，导致有些命令被隐藏了，需要知道具体执行的命令时候我们有以下方法可以实现。</p>
<p><code>make -n</code>命令展开make执行的命令，但是不会真正执行编译任务。</p>
<p><code>make V=1</code>命令可以将编译过程的详细信息打印出来。</p>
<h3 id="6-编译器中的一些知识点"><a href="#6-编译器中的一些知识点" class="headerlink" title="6 编译器中的一些知识点"></a>6 编译器中的一些知识点</h3><h4 id="6-1-目录说明"><a href="#6-1-目录说明" class="headerlink" title="6.1 目录说明"></a>6.1 目录说明</h4><p><code>C_INCLUDE_PATH</code> 编译C程序时候用于查找头文件的环境变量。</p>
<p><code>CPLUS_INCLUDE_PATH</code> 编译C++时候查找头文件使用的环境变量。</p>
<p><code>LIBRARY_PATH</code> 程序链接阶段用户查找库文件路径使用的环境变量。</p>
<p><code>LD_LIBRARY_PATH</code> 程序运行时，查找动态库路径使用的环境变量。</p>
<p><code>OBJ_INCLUDE_PATH</code>编译Obj-C程序时候使用的环境变量用于查找头文件。</p>
<p><code>CPATH</code>编译C/C++时程序使用的环境变量，用于查找头文件。</p>
<h2 id="二、Makefile通用模板"><a href="#二、Makefile通用模板" class="headerlink" title="二、Makefile通用模板"></a>二、Makefile通用模板</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TARGET=server</span><br><span class="line">CC=g++</span><br><span class="line">CFLAG=-c -g -static</span><br><span class="line"><span class="comment">#所有的.c文件</span></span><br><span class="line">SRCS:=<span class="variable">$(<span class="built_in">wildcard</span> ../*.c)</span></span><br><span class="line">FILTERS=../hello.c</span><br><span class="line"><span class="comment">#从SRCS中除了hello.c文件 filter函数可以选择满足条件的</span></span><br><span class="line">SRCS:=<span class="variable">$(<span class="built_in">filter</span>-out <span class="variable">$(FILTERS)</span>, <span class="variable">$(SRCS)</span>)</span></span><br><span class="line">OBJS:=<span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(SRCS)</span>)</span></span><br><span class="line">CURRENT_PATH=<span class="variable">$(PWD)</span></span><br><span class="line">CPPFLAGS= -I../<span class="keyword">include</span> -I../util</span><br><span class="line">LIBS_PATH=-L../lib64</span><br><span class="line">LIBS=-lmylib</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断是哪个系统32bit编译还是在64bit编译。</span></span><br><span class="line">ARCH:=<span class="variable">$(<span class="built_in">shell</span> uname -m)</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(ARCH)</span>, x86_64)</span><br><span class="line">VERSION:=X86_64</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">VERSION:=i686</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJS)</span></span><br><span class="line">        <span class="variable">$(CC)</span> <span class="variable">$(DEBUG)</span> <span class="variable">$(SRCS)</span> <span class="variable">$(LIBS_PATH)</span> <span class="variable">$(LIBS)</span> <span class="variable">$(CPPFLAGS)</span> -o <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(OBJS)</span>:%.o:%.c</span><br><span class="line">        <span class="variable">$(CC)</span> <span class="variable">$(CFLAG)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm -rf *~ *.bak <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line">【顶层Makefile编写】</span><br><span class="line"><span class="section">all: all_client all_server</span></span><br><span class="line">    rm -rf *~ *.bak</span><br><span class="line"><span class="section">all_client:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C client</span><br><span class="line"><span class="section">all_server:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C server</span><br><span class="line"></span><br><span class="line"><span class="section">clean: clean_client clean_server</span></span><br><span class="line">    rm -rf *~ *.bak</span><br><span class="line"><span class="section">clean_client:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C client clean</span><br><span class="line"><span class="section">clean_server:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C server clean</span><br></pre></td></tr></table></figure>
<hr>
<p>感谢您花费时间阅读这篇文章，书中有错误的地方或者有什么建议都可以留言，或者通过邮件祝您在这里记录、阅读、分享愉快！</p>
<p>作&ensp;者:&ensp;lpyuan<br>Email:&ensp;<a href="mailto:&#x6c;&#x70;&#x79;&#117;&#x61;&#x6e;&#x32;&#49;&#x40;&#111;&#117;&#x74;&#x6c;&#111;&#x6f;&#x6b;&#46;&#99;&#111;&#109;">&#x6c;&#x70;&#x79;&#117;&#x61;&#x6e;&#x32;&#49;&#x40;&#111;&#117;&#x74;&#x6c;&#111;&#x6f;&#x6b;&#46;&#99;&#111;&#109;</a><br>2020年02月28日 02:52:00   </p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>Testing</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/2020/04/13/d0edc1ed.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="linux下常用的一下命令"><a href="#linux下常用的一下命令" class="headerlink" title="linux下常用的一下命令"></a>linux下常用的一下命令</h1><p>工作中我们会经常遇到各种各样的问题，遇到我们解决不了的我们会查找相关的资料，下面就是我平时工作中遇到的一些场景，记录的一些关于linux下操作的相关命令，希望对大家有用，会不定时更新~</p>
<a id="more"></a>

<h2 id="防火墙相关的命令"><a href="#防火墙相关的命令" class="headerlink" title="防火墙相关的命令"></a>防火墙相关的命令</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=4400-4600/udp --permanent(指定端口范围为4400-4600通过防火墙)</span><br><span class="line"> 其中：</span><br><span class="line">--zone <span class="comment"># 作用域 </span></span><br><span class="line">--add-port=80/tcp <span class="comment"># 添加端口，格式为：端口/通讯协议 </span></span><br><span class="line">--permanent <span class="comment"># 永久生效</span></span><br><span class="line"></span><br><span class="line">firewall-cmd --zone=public --remove-port=80/tcp --permanent（关闭指定端口）</span><br><span class="line"></span><br><span class="line">firewall-cmd --zone=public --list-ports（查看通过的端口）</span><br><span class="line"></span><br><span class="line">firewall-cmd --state <span class="comment"># 查看默认防火墙状态（关闭后显示notrunning，开启后显示running）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">1、iptables -L</span><br><span class="line"><span class="comment"># 查看iptables规则</span></span><br><span class="line"><span class="comment"># 查看filter表的iptables规则，包括所有的链。filter表包含INPUT、OUTPUT、FORWARD三个规则链。</span></span><br><span class="line"><span class="comment"># 说明：-L是--list的简写，作用是列出规则。</span></span><br><span class="line"> </span><br><span class="line">2、iptables -L [-t 表名]</span><br><span class="line"><span class="comment"># 只查看某个表的中的规则。</span></span><br><span class="line"><span class="comment"># 说明：表名一共有三个：filter,nat,mangle，如果没有指定表名，则默认查看filter表的规则列表（就相当于第一条命令）。</span></span><br><span class="line"><span class="comment"># 举例：iptables -L -t filter</span></span><br><span class="line"></span><br><span class="line">3、iptables -L [-t 表名] [链名]</span><br><span class="line"><span class="comment"># 这里多了个链名，就是规则链的名称。</span></span><br><span class="line"><span class="comment"># 说明：iptables一共有INPUT、OUTPUT、FORWARD、PREROUTING、POSTROUTING五个规则链。</span></span><br><span class="line"><span class="comment"># 举例：iptables -L INPUT</span></span><br><span class="line"><span class="comment"># 注意：链名必须大写。在Linux系统上，命令的大小写很敏感。</span></span><br><span class="line"></span><br><span class="line">4、iptables -n -L</span><br><span class="line"><span class="comment"># 说明：以数字形式显示规则。如果没有-n，规则中可能会出现anywhere，有了-n，它会变成0.0.0.0/0</span></span><br><span class="line"></span><br><span class="line">5、iptables -nv -L</span><br><span class="line"><span class="comment"># 说明：你也可以使用“iptables -L -nv”来查看，这个列表看起来更详细，对技术人员更友好，呵呵。</span></span><br><span class="line"><span class="comment"># 如果想删除iptables规则我们可以如下操作</span></span><br><span class="line"><span class="comment"># 删除之前添加的规则（iptables -A INPUT -s 192.168.1.5 -j DROP）：</span></span><br><span class="line">iptables -D INPUT -s 192.168.1.5 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有时候要删除的规则太长，删除时要写一大串，既浪费时间又容易写错，这时我们可以</span></span><br><span class="line"><span class="comment">#先使用–line-number找出该条规则的行号，再通过行号删除规则。</span></span><br><span class="line">iptables -nL --line-number</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除第二行规则</span></span><br><span class="line">iptables -D INPUT 2</span><br><span class="line"></span><br><span class="line">Reference：</span><br><span class="line">https://blog.csdn.net/chengxuyuanyonghu/article/details/51897666</span><br></pre></td></tr></table></figure>


<h2 id="find-查找命令"><a href="#find-查找命令" class="headerlink" title="find 查找命令"></a>find 查找命令</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">	find / -name test.cpp -<span class="built_in">exec</span> ls -l &#123;&#125; \;</span><br><span class="line">&#123;&#125; 代表的是find找到的内容，find的结果会被放置到&#123;&#125;位置中。</span><br><span class="line">-<span class="built_in">exec</span> 一直到\;是关键字，代表的是find额外的动作开始(-<span class="built_in">exec</span>)到结束(;\)。</span><br><span class="line">因为在bash环境下’;‘符号是有特殊意义的，因此用反斜杠<span class="string">&#x27;\\&#x27;</span>来跳脱。</span><br></pre></td></tr></table></figure>
<h2 id="yum-安装软件包"><a href="#yum-安装软件包" class="headerlink" title="yum 安装软件包"></a>yum 安装软件包</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install epel-release <span class="comment"># 安装&quot;epel-release&quot;的软件包</span></span><br><span class="line">yum install tcpreplay</span><br></pre></td></tr></table></figure>
<h2 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -eLf	 <span class="comment">#查看进程线程情况</span></span><br></pre></td></tr></table></figure>
<h2 id="压缩、解压命令"><a href="#压缩、解压命令" class="headerlink" title="压缩、解压命令"></a>压缩、解压命令</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">压缩：</span><br><span class="line">tar -zcvf /tmp/etc.tar.gz  /etc      <span class="comment">#将/etc下的所有文件及目录打包到/etc，并使用gz压缩  </span></span><br><span class="line">tar -cvf /home/abc.tar /home/abc     <span class="comment">#只打包，不压缩</span></span><br><span class="line">tar -zcvf /home/abc.tar.gz /home/abc <span class="comment">#打包，并用gzip压缩</span></span><br><span class="line"></span><br><span class="line">解压：</span><br><span class="line">tar -zxvf /tmp/etc.tar.gz</span><br></pre></td></tr></table></figure>
<h2 id="服务的锁定与取消"><a href="#服务的锁定与取消" class="headerlink" title="服务的锁定与取消"></a>服务的锁定与取消</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl mask firewalld   <span class="comment"># 需要锁定该服务时执行</span></span><br><span class="line">systemctl unmask firewalld <span class="comment"># 实现取消服务的锁定</span></span><br></pre></td></tr></table></figure>
<h2 id="路由配置相关"><a href="#路由配置相关" class="headerlink" title="路由配置相关"></a>路由配置相关</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加IPV6地址</span></span><br><span class="line">ip -6 addr add &lt;ipv6address&gt;/&lt;prefixlength&gt; dev &lt;interface&gt;</span><br><span class="line">ip -6 addr add 2001:0db8:0:f101::1/64 dev eth0</span><br><span class="line"></span><br><span class="line">ifconfig &lt;interface&gt; inet6 add &lt;ipv6address&gt;/&lt;prefixlength&gt;</span><br><span class="line">ifconfig eth0 inet6 add 2001:0db8:0:f101::1/64</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加默认路由</span></span><br><span class="line">ip -6 route add &lt;ipv6network&gt;/&lt;prefixlength&gt; via &lt;ipv6address&gt;</span><br><span class="line">ip -6 route add default via 2001:0db8:0:f101::1</span><br><span class="line"></span><br><span class="line">route -A inet6 add &lt;ipv6network&gt;/&lt;prefixlength&gt; gw</span><br><span class="line">route -A inet6 add default gw 2001:0db8:0:f101::1</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看路由</span></span><br><span class="line">ip -6 route show</span><br><span class="line">route -A <span class="string">&#x27;inet6&#x27;</span></span><br><span class="line">route -6</span><br><span class="line"></span><br><span class="line"><span class="comment">#windows查看路由表</span></span><br><span class="line">route <span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看邻居缓存</span></span><br><span class="line">ip -6 neighbor show</span><br><span class="line"></span><br><span class="line"><span class="comment">#windows查看邻居缓存</span></span><br><span class="line">netsh interface ipv6 show neighbors</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看smtp服务器</span></span><br><span class="line">ping smtp.sohu.com </span><br><span class="line">ping smtp.qq.com</span><br></pre></td></tr></table></figure>
<h2 id="更新内核命令"><a href="#更新内核命令" class="headerlink" title="更新内核命令"></a>更新内核命令</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum update kernel -y</span><br></pre></td></tr></table></figure>
<h2 id="大文件重定向有效信息"><a href="#大文件重定向有效信息" class="headerlink" title="大文件重定向有效信息"></a>大文件重定向有效信息</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重定向dmesg.txt关键字Call Trace的前后2000行到nn.txt：</span></span><br><span class="line">grep -C 2000 ‘Call Trace’ dmesg.txt &gt;nn.txt</span><br></pre></td></tr></table></figure>
<h2 id="Shell递归删除指定字符串文件或者目录"><a href="#Shell递归删除指定字符串文件或者目录" class="headerlink" title="Shell递归删除指定字符串文件或者目录"></a>Shell递归删除指定字符串文件或者目录</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">文件：find . -name <span class="string">&quot;*.rej&quot;</span> | xargs rm -rf</span><br><span class="line">目录：find . -<span class="built_in">type</span> d -name <span class="string">&quot;*.rej&quot;</span> | xargs rm -rf</span><br></pre></td></tr></table></figure>
<h2 id="文件夹建立软链接（用绝对地址"><a href="#文件夹建立软链接（用绝对地址" class="headerlink" title="文件夹建立软链接（用绝对地址)"></a>文件夹建立软链接（用绝对地址)</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ln -s 源地址 目的地址   <span class="comment">#比如我把linux文件系统rootfs_dir软链接到/home/jyg/目录下</span></span><br><span class="line">ln -s /opt/linux/rootfs_dir  /home/jyg/rootfs_dir <span class="comment">#就可以了</span></span><br></pre></td></tr></table></figure>
<h2 id="大数据报文件分割"><a href="#大数据报文件分割" class="headerlink" title="大数据报文件分割"></a>大数据报文件分割</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">windows下 d:&gt;wireshark&gt;editcap -C 1000000(文件大小) 待分割文件路径 新文件名称</span><br><span class="line">linux 可使用split命令</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="ps查看进程存活时间"><a href="#ps查看进程存活时间" class="headerlink" title="ps查看进程存活时间"></a>ps查看进程存活时间</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -eo pid,lstart,etime|grep pid</span><br></pre></td></tr></table></figure>
<h2 id="CPU相关"><a href="#CPU相关" class="headerlink" title="CPU相关"></a>CPU相关</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">1、查看物理CPU的个数</span><br><span class="line">cat /proc/cpuinfo |grep <span class="string">&quot;physical id&quot;</span>|sort |uniq|wc -l</span><br><span class="line"></span><br><span class="line">2、 查看逻辑CPU的个数</span><br><span class="line">cat /proc/cpuinfo |grep <span class="string">&quot;processor&quot;</span>|wc -l</span><br><span class="line"></span><br><span class="line">3、 查看CPU是几核</span><br><span class="line">cat /proc/cpuinfo |grep <span class="string">&quot;cores&quot;</span>|uniq</span><br><span class="line"> </span><br><span class="line">4、查看CPU的主频</span><br><span class="line">cat /proc/cpuinfo |grep MHz|uniq </span><br></pre></td></tr></table></figure>
<h2 id="watch实时监控"><a href="#watch实时监控" class="headerlink" title="watch实时监控"></a>watch实时监控</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">1、每一秒输出系统的平均负载</span><br><span class="line">watch -n 1 <span class="string">&#x27;cat /proc/loadavg&#x27;</span></span><br><span class="line"></span><br><span class="line">2、每秒输出变化</span><br><span class="line">watch -n 1 -d <span class="string">&#x27;pstree|grep http&#x27;</span> </span><br></pre></td></tr></table></figure>
<h2 id="rpm命令"><a href="#rpm命令" class="headerlink" title="rpm命令"></a>rpm命令</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">1、查看.rpm 包依赖</span><br><span class="line">rpm -qpR [package]</span><br><span class="line"></span><br><span class="line">2、安装.rpm 包时，如果缺少依赖，报错信息中会打印出缺少的依赖</span><br><span class="line">rpm -ivh [package]</span><br><span class="line"> </span><br><span class="line">3、查看已经安装的数据包</span><br><span class="line">rpm -qa</span><br><span class="line"> </span><br><span class="line">4、查询包的依赖关系</span><br><span class="line">https://pkgs.org/ </span><br></pre></td></tr></table></figure>
<h2 id="Linux删除乱码文件"><a href="#Linux删除乱码文件" class="headerlink" title="Linux删除乱码文件"></a>Linux删除乱码文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">1、查看文件索引节点</span><br><span class="line">ls -il</span><br><span class="line"></span><br><span class="line">2、删除对应的索引节点</span><br><span class="line">find -inum 203179434 -<span class="built_in">exec</span> rm &#123;&#125; -rf \</span><br></pre></td></tr></table></figure>
<h2 id="mount挂载文件系统"><a href="#mount挂载文件系统" class="headerlink" title="mount挂载文件系统"></a>mount挂载文件系统</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把根目录文件系统设为可读写</span></span><br><span class="line"></span><br><span class="line">mount -n -o remount,rw /</span><br></pre></td></tr></table></figure>
<h2 id="ftp命令"><a href="#ftp命令" class="headerlink" title="ftp命令"></a>ftp命令</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">1、使用binary的方式来传输文件</span><br><span class="line">binary</span><br><span class="line"></span><br><span class="line">2、 查看本地目录<span class="built_in">local</span> change director</span><br><span class="line">lcd  </span><br><span class="line"></span><br><span class="line">3、 上传命令</span><br><span class="line">mput D:\User\Desktop\Desktop\*</span><br></pre></td></tr></table></figure>
<h2 id="CPU相关-1"><a href="#CPU相关-1" class="headerlink" title="CPU相关"></a>CPU相关</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置某个进程运行在某个cpu上</span></span><br><span class="line">taskset -p pid</span><br><span class="line">taskset -pc 0 pid</span><br></pre></td></tr></table></figure>
<h2 id="udvadm-命令"><a href="#udvadm-命令" class="headerlink" title="udvadm 命令"></a>udvadm 命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找指定设备的属性信息</span></span><br><span class="line">udevadm info --query=all --name=/dev/vda</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>面试知识点</title>
    <url>/2020/03/14/dc0b7f4a.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h1><h2 id="大端小端网络字节序"><a href="#大端小端网络字节序" class="headerlink" title="大端小端网络字节序"></a>大端小端网络字节序</h2><p>&ensp;&ensp;&ensp;&ensp;”大端”，”小端”指的是表示多字节的值哪一端存储在该值的起始地址处；多字节小端存储起始地址处称为小端字节序，多字节的大端存储在起始地址处称为大端字节序。<br>&ensp;&ensp;&ensp;&ensp;通俗的说就是。</p>
<p>&ensp;&ensp;&ensp;&ensp;常用的X86架构就是采用的小端存储，最高有效位在最高位地址。</p>
<p>&ensp;&ensp;&ensp;&ensp;大端字节序：最高有效位存于最低的内存地址，最低的有效位存于最高的内存地址。<br>&ensp;&ensp;&ensp;&ensp;小端字节序：最高有效位存于最高的内存地址，最低的有效位存于最低的内存地址。</p>
<a id="more"></a>

<img src="/images/image-20201220131133527.jpg" alt="image-20201220131133527" style="zoom:80%;" />

<p>网络字节序，网络上传输的数据都是字节流。**UDP/TCP/IP协议规定:**把接收到的第一个字节当作高位字节看待,这就要求发送端发送的第一个字节是高位字节。而在发送端发送数据时,发送的第一个字节是该数值在内存中的起始地址处对应的那个字节,也就是说,该数值在内存中的起始地址处对应的那个字节就是要发送的第一个高位字节(即:高位字节存放在低地址处);由此可见,<strong>多字节数值在发送之前,在内存中因该是以大端法存放的</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">union 联合体成员存放的顺序都是从低地址开始存放，并且是所有的成员共享同一个内存空间，</span></span><br><span class="line"><span class="comment">可以利用这个特性进行一个大小端的判断。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义联合体结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">testUnion</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">&#125;testUnion;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断大小端 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isBigEndStorage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    testUnion a;</span><br><span class="line">    a.a = <span class="number">0x01</span>;</span><br><span class="line">    <span class="keyword">return</span> a.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == isBigEndStorage())</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端存储&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端存储&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="tcp三次握手"><a href="#tcp三次握手" class="headerlink" title="tcp三次握手"></a>tcp三次握手</h2><p>&ensp;&ensp;&ensp;&ensp;为什么建立连接需要三次握手？TCP的两次握手是最基本的，第一次握手，客户端发了个连接请求消息到服务端，服务端收到信息后知道自己与客户端是可以连接成功的，但此时客户端并不知道服务端是否已经接收到了它的请求，所以服务端接收到消息后的应答，客户端得到服务端的反馈后，才确定自己与服务端是可以连接上的，这就是第二次握手。<br>&ensp;&ensp;&ensp;&ensp;客户端只有确定了自己能与服务端连接上才能开始发数据。所以两次握手肯定是最基本的。<br>&ensp;&ensp;&ensp;&ensp;到了这，有人肯定又有疑问，两次握手不就可以了吗，为什么需要第三次握手。其实，第三次握手主要的原因是防止已经失效的连接请求报文由于某种原因突然又回到服务端，从而就会产生错误。比如，一个请求的数据包，因为某些原因滞留在网络中很久，一直到了连接释放的时候才到达服务端，这时候，服务端以为是客户端的第一次连接回应了客户端从而建立了连接，实际上是不必要的连接客户端并没有任何数据要发送，当存在大量的这种情况下，会造成很大的资源浪费。所以需要第三次握手，只有客户端再次回应一下，就可以避免这种情况。</p>
<img src="/images/image-20201220131233527.jpg" alt="image-20201220131233527" style="zoom:50%;" />

<h2 id="TCP与UDP的概念"><a href="#TCP与UDP的概念" class="headerlink" title="TCP与UDP的概念"></a>TCP与UDP的概念</h2><p>&ensp;&ensp;&ensp;&ensp;TCP:一种面向连接的，可靠的，基于字节流的通信协议。<br>&ensp;&ensp;&ensp;&ensp;UDP:提供无连接的通信，不可靠的，基于数据报的通信协议。<br><strong>两者的主要区别是</strong>：<br>&ensp;&ensp;&ensp;&ensp;（1）TCP是面向连接的传输控制协议，而UDP是提供无连接的数据报服务。<br>&ensp;&ensp;&ensp;&ensp;（2）TCP具有高可靠性，能确保数据的完整性和正确性。<br>&ensp;&ensp;&ensp;&ensp;（3）TCP需要的系统资源比较多，而UDP需要的就相对少一些。<br>&ensp;&ensp;&ensp;&ensp;（4）UDP实时性比较高，低延迟，但是TCP的工作效率相对高一些。</p>
<h2 id="UDP调用connect函数作用"><a href="#UDP调用connect函数作用" class="headerlink" title="UDP调用connect函数作用"></a>UDP调用connect函数作用</h2><p>&ensp;&ensp;&ensp;&ensp;UDP调用connect函数的作用，并不会引起和服务器目标端的网络交互，也就是说并不会触发所谓的”握手🤝“报文的过程。其主要的作用是让应用程序能够接收到”异步错误“的信息。假设在服务器不开启的情况下，客户端程序是不会报错的，程序会一直阻塞在recvfrom函数上，等待返回或者超时。如果将UDP套接字进行connect绑定，将UDP套接字建立“上下文”，那么这时候操作系统内核接收到的信息就可以和相应的套接字进行相关联。</p>
<h2 id="TCP如何设定超时时间"><a href="#TCP如何设定超时时间" class="headerlink" title="TCP如何设定超时时间"></a>TCP如何设定超时时间</h2><img src="/images/image-20201220131433527.jpg" alt="image-20201220131433527" style="zoom:33%;" />

<p>如果TCP握手🤝的SYN超时按照上图来backoff。在Linux中，net.ipv4.tcp_syn_retries参数表示建立TCP连接时SYN报文重试的次数，最多会尝试7次。2的7次幂减去1刚好是127。我们将net.ipv4.tcp_syn_retries参数改成1，就可以将connect超时时间改成3秒。</p>
<p>&ensp;&ensp;&ensp;&ensp;tcp设置发送和接收超时，可以通过SO_SNDTIMEO和SO_RCVTIMEO的选项来设置超时。</p>
<h2 id="SYN-flood洪水攻击"><a href="#SYN-flood洪水攻击" class="headerlink" title="SYN flood洪水攻击"></a>SYN flood洪水攻击</h2><p>&ensp;&ensp;&ensp;&ensp;正常的情况下，TCP需要经过三次握手才能建立连接。于是就出现了对握手🤝，过程进行的攻击。通过发送大量的SYN数据包，服务器响应（SYN+ACK）包。但是这个时候，攻击者不会回应ACK数据包，这个时候服务器不知道发送的（SYN+ACK）包是否发送成功，默认情况下会重试5次（tcp_syn_retries）。这样的话，对于服务器的内存、带宽都会有消耗。如果处于公网地址，攻击者伪造大量的报文进行攻击，那么如果服务器没有任何防护设施的话，可能会直接导致服务器连接资源耗尽，导致拒绝对外服务。</p>
<p>&ensp;&ensp;&ensp;&ensp;从服务器防御的角度来看，可以采取以下措施。</p>
<p>&ensp;&ensp;&ensp;（1）对内核参数进行调优。</p>
<p>&ensp;&ensp;&ensp;（2）利用防火墙禁止掉部分IP。</p>
<p>&ensp;&ensp;&ensp;&ensp;Linux内核参数调优主要从下面几个方面进行：</p>
<p>&ensp;&ensp;&ensp;（1）限制SYN并发的数量，超时时间</p>
<p>&ensp;&ensp;&ensp;（2）增大tcp_max_syn_backblog</p>
<p>&ensp;&ensp;&ensp;&ensp;当半连接的请求数量超过了tcp_max_syn_backlog时，内核就会启用SYN cookie机制，不再把半连接请求放到队列里，而是用SYN cookie来检验。</p>
<p>&ensp;&ensp;&ensp;（3）减小tcp_synack_retries</p>
<p>&ensp;&ensp;&ensp;（4）启用tcp_syncookies</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;SYN cookie是非常巧妙地利用了TCP规范来绕过了TCP连接建立过程的验证过程，从而让服务器的负载可以大大降低在三次握手中，当服务器回应（SYN + ACK）包后，客户端要回应一个n + 1的ACK到服务器。其中n是服务器自己指定的。当启用tcp_syncookies时，backlog满了后，linux内核生成一个特定的n值，而不并把客户的连接放到半连接的队列backlog里（即没有存储任何关于这个连接的信息，不浪费内存）。当客户端提交第三次握手的ACK包时，linux内核取出n值，进行校验，如果通过，则认为这个是一个合法的连接。</p>
<h2 id="tcp-粘包半包问题怎么处理？"><a href="#tcp-粘包半包问题怎么处理？" class="headerlink" title="tcp 粘包半包问题怎么处理？"></a>tcp 粘包半包问题怎么处理？</h2><p>粘包与分包的处理方法：</p>
<p>（1）一个是采用分隔符方式。在封装要传输的数据包的时候，采用的固定的符号作为结束符🔚。这样接收到的数据中，如果接收到数据后，出如果出现结尾标识，即进行人为的将粘包分开，如果一个包中没有我们定义的结尾标识符，则是人为出现了分包，则此时我们需要等待下一个数据包进行组包。如HTTP协议以\r\n结尾。</p>
<p>（2）在数据包中添加长度的方式。在数据包的头部或者某个固定的位置封装一个数据包的长度信息。当收到数据包之后，先解析长度然后按照长度截取数据包。</p>
<p>（3）</p>
<h2 id="域套接字比流式套接字快的原因"><a href="#域套接字比流式套接字快的原因" class="headerlink" title="域套接字比流式套接字快的原因"></a>域套接字比流式套接字快的原因</h2><p>域套接字用于同一台计算机上进程间的通信，</p>
<p>1、它仅仅只是复制数据.。</p>
<p>2、不执行协议的处理，不需要增加或删除网络报头。</p>
<p>3、不进行检验和的计算，也不产生序列号，不需要进行校验和的计算</p>
<p>4、无需发送确认报文</p>
<h2 id="tcp的socket怎么收取数据的，recv的返回值。"><a href="#tcp的socket怎么收取数据的，recv的返回值。" class="headerlink" title="tcp的socket怎么收取数据的，recv的返回值。"></a>tcp的socket怎么收取数据的，recv的返回值。</h2><p>TCP收取数据的时候，可以使用函数recv或者read对数据进行读取。</p>
<p>一般的返回值有：</p>
<p>ret  &gt; 0 成功从内核缓冲区读取到的数据大小</p>
<p>ret = 0 TCP连接已经关闭</p>
<p>ret=-1 错误，需要读取错误码进行判断</p>
<p>主要的错误码(errno)有：</p>
<p>EINTR：操作被信号中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cnt = (<span class="keyword">int</span>)recv(m_socket, pBuf,RECVSIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>( cnt &gt;<span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//正常处理数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">         <span class="keyword">if</span>((cnt&lt;<span class="number">0</span>) &amp;&amp;(errno == EAGAIN||errno == EWOULDBLOCK||errno == EINTR)) </span><br><span class="line">         <span class="comment">//这几种错误码，认为连接是正常的，继续接收</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">//继续接收数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//跳出接收循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TCP慢启动、拥塞控制、快重传、快恢复"><a href="#TCP慢启动、拥塞控制、快重传、快恢复" class="headerlink" title="TCP慢启动、拥塞控制、快重传、快恢复"></a>TCP慢启动、拥塞控制、快重传、快恢复</h2><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>&ensp;&ensp;&ensp;&ensp;进程：进程是具有一定独立功能的程序关于某一个数据集合的一心运行活动，他是系统进程资源分配和调度的一个基本单位。<br>&ensp;&ensp;&ensp;&ensp;线程：线程是进程的一个实体，他是CPU分配和调度的基本单位。<br><strong>线程的优点</strong>：<br>&ensp;&ensp;&ensp;&ensp;（1）易于调度。<br>&ensp;&ensp;&ensp;&ensp;（2）线程可以提供并发性，利用线程可以有效的实现并发。<br>&ensp;&ensp;&ensp;&ensp;（3）线程开销小。<br>&ensp;&ensp;&ensp;&ensp;（4）有利于发挥对处理器的优点。通过创建多线程，每个线程可以不同的处理器上运行，从而实现应用程序的并行，使得每个处理器都能得到充分发挥。<br><strong>进程与线程的区别</strong>：<br>&ensp;&ensp;&ensp;&ensp;&ensp;(1) 一个线程属于一个进程，而一个进程可以有多个线程。<br>&ensp;&ensp;&ensp;&ensp;（2）一个进程的所有线程共享一个进程的所有资源，这些资源包括有打开的文件，创建的socket，不同的进程是相互独立的<br>&ensp;&ensp;&ensp;&ensp;（3）线程是轻量级进程，进程有进程控制块，线程也有线程控制块。但是线程控制块比进程控制块小的很多，线程切换代价小，进程空间切换代价大，线程空间切换代价小。</p>
<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p><strong>定义</strong>：<br>&ensp;&ensp;&ensp;&ensp;ps 命令观察进程的执行状态的时候，看到状态栏为defunct状态的进程，这些就是所谓的僵尸进程。<br><strong>僵尸进程的危害</strong><br>&ensp;&ensp;&ensp;&ensp;进程表中占用一个位置（slot）,由于进程表的容量是有限的，所以defunct进程不仅会占用系统资源，影响系统的性能，如果数目太多的话会导致系统的崩溃。<br><strong>僵尸进程产生的原因</strong><br>&ensp;&ensp;&ensp;&ensp;(1)操作系统对所有的进程维护一张进程表，每一个进程在进程表中都有一个entry（进入点），核心程序在执行该进程时候所使用的一切信息都是存储在entry（进入点）中，ps命令查看的就是这个进程表中的相关数据。<br>&ensp;&ensp;&ensp;&ensp;(2)当一个父进程fork()系统调用建立一个新的进程之后，核心进程就会在进程表中给子进程分配一个entry（进入点），然后将这些信息存放在对应的进程表内，这些信息中有一项就是其父进程的识别码。<br>&ensp;&ensp;&ensp;&ensp;(3)当子进程结束之后，其实该没有被真正的销毁，而此时进程表中的数据会被该进程的退出码（exit code），执行所需要的的CPU时间等等数据结构所取代，这些数据会一直保存到父进程读取为止。<br>&ensp;&ensp;&ensp;&ensp;（4）此时，该进程几乎已经放弃所有的把内存空间，没有任何可执行代码，同时也不能被调度，仅仅只是在进程表中保留一个位置，除此之外该进程不占用任何存储空间。该父进程一直没有注册SIGCHILD信号处理函数调用wait或者waitpid等待子进程结束，或者也没有注册忽略该信号，那么这些进程将会变成僵尸进程（zombie），如果父进程一直处于循环状态，系统中就会有很多的僵尸进程。<br><strong>解决的方法</strong><br>&ensp;&ensp;&ensp;&ensp;（1）重启服务器电脑，这个是最简单，最易用的方法，但是如果你服务器电脑上运行有其他的程序，那么这个方法，代价很大。<br>&ensp;&ensp;&ensp;&ensp;（2）找到僵尸进程的父进程，将父进程杀掉。ps -ef |grep defunct_process_id。<br><strong>如何防止僵尸进程</strong><br>&ensp;&ensp;&ensp;&ensp;（1）父进程fork之前注册之前忽略SIG_CLILD信号，忽略子进程退出相关的信息。调用函数：signal（SIGCHILD, SIG_IGN）。<br>&ensp;&ensp;&ensp;&ensp;（2）父进程调用wait,waitpid函数收集子进程退出的状态码。<br>&ensp;&ensp;&ensp;&ensp;（3）在父进程创建子进程的时候，连续调用两次fork()，而且使紧跟的子进程直接退出，使其孙子进程成为孤儿进程，从而init进程将代替父进程来接手，负责清除这个孤儿进程，系统自动回收。<br>##死锁是怎么样产生的##<br><strong>死锁的定义</strong><br>&ensp;&ensp;&ensp;&ensp;系统中有若干个进程在并发运行，他们不断的申请和释放资源，在这一个过程中，由于争夺资源而处于无限期的等待资源的状态，此时导致程序无法继续进行，若无外力的作用，他都将无法推进下去，这是系统处于死锁状态，或者系统产生了死锁。<br><strong>产生死锁的原因</strong><br>&ensp;&ensp;&ensp;&ensp;（1）系统的资源不足，例如多个打印机，但是由于纸张不够，进程推进不下去，产生了死锁。<br>&ensp;&ensp;&ensp;&ensp;（2）进程推进顺序不对。<br>&ensp;&ensp;&ensp;&ensp;（3）资源的分配不当。<br><strong>产生死锁的条件</strong><br>&ensp;&ensp;&ensp;&ensp;（1）互斥性，每个资源每次只能被一个进程使用。<br>&ensp;&ensp;&ensp;&ensp;（2）请求与保持等待，当一个进程因为请求资源而被阻塞等待时，对已经获得的资源保持不释放。<br>&ensp;&ensp;&ensp;&ensp;（3）不可剥夺，进程已经获得资源，未使用完之前，不可被其他剥夺。<br>&ensp;&ensp;&ensp;&ensp;（4）环路等待，若干进程之间 形成首尾相接的的等待资源的关系。</p>
<h2 id="CPU的执行方式"><a href="#CPU的执行方式" class="headerlink" title="CPU的执行方式"></a>CPU的执行方式</h2><img src="/images/image-20201220131633527.jpg" alt="image-20201220131633527" style="zoom:60%;" />

<p>CPU的工作主要分为五个阶段：<br>1、取指令（IF，instruction fetch）。将一条程序执行指令从主存中取出来放到指令寄存器的一个过程。<br>2、指令译码阶段（ID，instruction decode）。取出指令之后，指令译码器按照预定的指令格式对取回的指令进行拆分和解释，识别区分不同的指令类别以及获取各种操作数的方法。<br>3、执行指令的阶段（EX，execute）。具体实现指令的功能，CPU的不同部分被连接起来，以执行所需的操作。<br>4、访问存取数的阶段（MEM，memory）。根据指令的需要访问主存，读取操作数，CPU得到操作数在主存的地址，并从主存中读取该操作数用于运算。<br>5、结果回写阶段（WB，write back）。作为最后一个阶段，结果写回阶段把指令的运行结果数据“写回”到某种存储形式。</p>
<p>资料参考<br>[1] <a href="https://www.jianshu.com/p/05c6c1d73144">https://www.jianshu.com/p/05c6c1d73144</a><br>[2] <a href="https://www.jianshu.com/p/bfff5d0e718e">https://www.jianshu.com/p/bfff5d0e718e</a></p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>资料参考<br>[1] <a href="https://blog.csdn.net/Al_xin/article/details/38602093">https://blog.csdn.net/Al_xin/article/details/38602093</a></p>
<h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><img src="/images/image-20201220131733527.jpg" alt="image-20201220131733527" style="zoom:60%;" />

<p>32位系统0-4G地址空间，用户空间内存，从低到高分别是五种不同的内存段。<br>1、只读段，主要包括有代码和一些常量。<br>2、数据段，主要包括全局变量。<br>3、堆，主要包括分配的内存，从低地址开始向上增长。<br>4、文件映射段，主要包括动态库、共享内存等，从高地址向下增长。<br>5、栈，包括局部变量，函数的调用的上下文等，栈的大小一般是固定的，一般是8M。<br>在这五个内存段中，堆和文件映射段是动态内存分配的，malloc或者mmap等。<br><strong>堆是线程私有还是共有？栈呢？</strong><br>1、在多线程环境下，每个线程拥有一个栈和一个程序计数器。<br>2、栈和程序计数器用来保存线程的执行历史和线程的执行状态，是线程私有的资源。<br>3、其他的资源（比如堆、地址空间、全局变量）是由同一个进程内的多个线程共享。</p>
<p>资料参考<br>[1] <a href="https://time.geekbang.org/column/article/74272">https://time.geekbang.org/column/article/74272</a></p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程，指的就是微线程。是应用层的一种概念。</p>
<p>&ensp;&ensp;&ensp;&ensp;协程最大的优势就是具有极高的执行效率。可以把协程看做是一种子程序，因为子程序的切换不是进程也不是线程的切换，因此没有进程或者线程的切换的开销。</p>
<h2 id="列出常见的信号，并解释下信号是怎么处理的。"><a href="#列出常见的信号，并解释下信号是怎么处理的。" class="headerlink" title="列出常见的信号，并解释下信号是怎么处理的。"></a>列出常见的信号，并解释下信号是怎么处理的。</h2><p>&ensp;&ensp;&ensp;&ensp;linux 系统下可以使用命令kill -l查看常见的信号。</p>
<p>&ensp;&ensp;&ensp;&ensp;信号实际上就是一种很短的信息，信号可以被发送到一个进程或者一组进程。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>不可靠信号：</strong>指的是非实时的信号📶，其中1~31信号就是不可靠信号。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>可靠信号：</strong>指的是实时的信号，其中32~64信号是可靠信号📶。</p>
<p>&ensp;&ensp;&ensp;&ensp;可靠信号与不可靠信号的区别在于：不可靠信号不支持排队，可能会造成信号丢失，但是可靠信号不会。如果一个不可靠的信号📶被连续发送多次，那么只有其中的一个会被发送到接收进城。</p>
<p>&ensp;&ensp;&ensp;&ensp;内核给进程发送信号📶，实在进程所在的进程表项的信号阈设置相应的信号的位。</p>
<p>&ensp;&ensp;&ensp;&ensp;进程检查信号的时机是：进程即将从内核态返回用户态的时候。如果进程睡眠了，要看睡眠能不能被中断，如果能被中断则是进行唤醒。</p>
<h2 id="i-或者-i是否是原子操作，为什么。"><a href="#i-或者-i是否是原子操作，为什么。" class="headerlink" title="i++或者++i是否是原子操作，为什么。"></a>i++或者++i是否是原子操作，为什么。</h2><p>&ensp;&ensp;&ensp;&ensp;这个不是原子操作。因为i++这个可以在拆分为三个过程。</p>
<p>&ensp;&ensp;&ensp;&ensp;1、内存到寄存器</p>
<p>&ensp;&ensp;&ensp;&ensp;2、寄存器自增</p>
<p>&ensp;&ensp;&ensp;&ensp;3、写回内存。</p>
<p>&ensp;&ensp;&ensp;&ensp;这其中的任何一个阶段都有可能会被中断。</p>
<p>&ensp;&ensp;&ensp;&ensp;++i这个其实在多核处理器上，CPU在读取内存时候，也会可能发生同时读取到一个值，这样其实也会导致两次自增，实际上只是增加了一次。</p>
<p>&ensp;&ensp;&ensp;&ensp;所以，i++和++i都是不是原子操作。</p>
<h2 id="linux下的同步机制，以及死锁，如何避免死锁。"><a href="#linux下的同步机制，以及死锁，如何避免死锁。" class="headerlink" title="linux下的同步机制，以及死锁，如何避免死锁。"></a>linux下的同步机制，以及死锁，如何避免死锁。</h2><p>&ensp;&ensp;&ensp;&ensp;1、原子操作。原子操作不会被任何事物所打断，通常用于资源的计数，引用的计数。例如有TCP/IP协议栈的IP碎片计数。</p>
<p>&ensp;&ensp;&ensp;&ensp;2、信号量。就像房间内有好几把钥匙🗝，拿到钥匙就去访问。设置为1的时候变为了mutex。绝大多数部分可以作为互斥锁来进行使用。</p>
<p>&ensp;&ensp;&ensp;&ensp;3、读写信号量。可以允许多个读，一个写。一旦有人在写，就大家都不可以读取，如果没有在写，可以允许多个人进行读取。</p>
<p>&ensp;&ensp;&ensp;&ensp;4、锁🔐。自旋锁和互斥锁的区别在于是否会进行休眠。如果自旋锁被其他执行单元持有，那么调用者就会一直在那自旋，循环等待资源的释放。在持有时间很短的情况下一般使用自旋锁会比互斥锁稍微高效一些。</p>
<p><strong>死锁产生的必要条件：</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;1、资源一定是互斥的。</p>
<p>&ensp;&ensp;&ensp;&ensp;2、资源是不可抢占的。</p>
<p>&ensp;&ensp;&ensp;&ensp;3、占有且需要申请的。</p>
<p>&ensp;&ensp;&ensp;&ensp;4、需要循环等待的。</p>
<h2 id="exit和-exit-EXIT-的区别"><a href="#exit和-exit-EXIT-的区别" class="headerlink" title="exit和_exit(_EXIT)的区别"></a>exit和_exit(_EXIT)的区别</h2><p>&ensp;&ensp;&ensp;&ensp;_exit和_EXIT函数调用时候立即进入内核，exit函数则是会先进行一些清理处理，然后再返回内核。</p>
<p>&ensp;&ensp;&ensp;&ensp;exit函数总是会先执行一个标准的I/O库的清理关闭操作，对于所有打开流调用fclose函数，会将输出缓冲区中的所有数据都被冲洗。</p>
<p>&ensp;&ensp;&ensp;&ensp;_exit函数调用则是直接关闭文件📃，文件缓冲区中的内容也就直接消失了，这个时候是不会再输出到显示设备了。</p>
<h2 id="linux内存管理机制"><a href="#linux内存管理机制" class="headerlink" title="linux内存管理机制"></a>linux内存管理机制</h2><p>&ensp;&ensp;&ensp;&ensp;linux操作系统采用虚拟内存管理技术，将不同进程的虚拟地址空间和不同的内存物理地址映射起来，使得每个进程都有各自互不干扰的进程地址空间。</p>
<p>&ensp;&ensp;&ensp;&ensp;在32位的系统上该空间的大小为4G的现行虚拟空间，用户所看到的或者接触的都是虚拟地址空间，并不会看到实际的物理地址。操作系统引入了虚拟内存，那么进程持有的虚拟地址就会通过CPU的内存管理单元（MMU）的映射关系，转化成物理地址，然后再通过物理地址进程访问。只有那些实际使用的UNINEICUN才分配物理内存，并且分配之后的物理内存是通过内存映射来管理的。</p>
<p>&ensp;&ensp;&ensp;&ensp;内存映射，其实就是讲虚拟内存地址映射到物理内存地址，为了完成内存映射，内核为每一个进程都维护了一张页表，记录虚拟地址与物理地址之间的映射关系。页表实际上存储在CPU的内存管理单元MMU中，这样情况下，处理器可以直接通过硬件找出需要访问的内存。当进程访问虚拟地址在页表中查询不到的时候，系统就会产生一个缺页异常，进入到内核空间进行分配物理内存，更新进程页表，最后返回到用户空间，回复进程的运行。</p>
<img src="/images/image-20201220131833527.jpg" alt="image-20201220131833527" style="zoom:40%;" />

<p>MMU并不是以字节为单位来管理内存的，而是规定了一乐内存映射的最小单位，页。通常是4KB大小，这样每一个内存映射，都需要关联4KB或者4KB的整数倍的内存空间。</p>
<p><strong>多级页表</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;多级页表就是把内存分成区块来进行管理，将原来的映射关系改成区块索引和区块偏移。由于虚拟地址空间通常只用很少的一部分，那么多级页表就只保存这些使用的区块，这样就可以大大的减少页表的项数。</p>
<p>Linux是用过四级页表来管理内存的，如下图。虚拟地址被分为5个部分，前四个表项用于选择页，而最后一个表项这是索引表示页内偏移。</p>
<img src="/images/image-20201220131933527.jpg" alt="image-20201220131933527" style="zoom:40%;" />

<p>再看大页，大页指的是比普通页更大的内存块，常见的大小有2MB和1GB。大页通常用在使用大量内存的进程上，比如Oracle、DPDK等。</p>
<p><strong>内存的分配与回收♻️</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;在C标准库中，malloc是其提供的内存分配函数，对应的系统调用上主要有两种实现的方式，即brk()和mmap()。</p>
<p>&ensp;&ensp;&ensp;&ensp;（1）对于小块的内存，C标准库使用brk()来进行分配，也就是通过移动堆顶的位置来进行分配内存，这些内存释放之后不会立刻归还给系统，而是会被缓存起来，这样可以重复使用。</p>
<p>&ensp;&ensp;&ensp;&ensp;（2）对于大块的内存（大于128K），则是使用内内存映射mmap()来进行分配，也就是在文件映射段找到一块空闲的内内存分配出去。</p>
<p>这两种方式的优缺点：</p>
<p>&ensp;&ensp;&ensp;&ensp;brk()方式的缓存，可以减少却也一行的发生，可以提高内存的访问效率，不过，由于这些内存没有归还给系统，在内存繁忙的时候，频繁的内存分配和释放会造成内存碎片。</p>
<p>&ensp;&ensp;&ensp;&ensp;mmap()方式的分配内存，会在释放时候直接归还给系统，所以每次mmap都会发生缺页异常。在内存工作繁忙的时候，频繁的内存分配会导致大量的缺页异常的发生，使得内存的管理负担增大，这也是malloc只对大块内存使用mmap的原因。</p>
<p>&ensp;&ensp;&ensp;&ensp;了解了这两种，调用方式之后，我们还需要清楚的了解一点，就是当发生这两种调用方式之后，其实没有镇长的分配内存，这些实际使用的内存，只有在首次访问的时候才进行分配，也就是通过缺页异常进入到内核中，再由内核进行分配内存。</p>
<h2 id="Linux的任务调度机制"><a href="#Linux的任务调度机制" class="headerlink" title="Linux的任务调度机制"></a>Linux的任务调度机制</h2><p>&ensp;&ensp;&ensp;&ensp;&ensp;Linux作为一个多任务的操作系统，必须支持程序的并发执行。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;多任务一般分为两类，非抢占式多任务与抢占式多任务。</p>
<p><strong>&ensp;&ensp;&ensp;&ensp;&ensp;非抢占式多任务：</strong>除非任务自己结束🔚，否则将会一直执行。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;<strong>抢占式多任务：</strong>这种情况下，由调度程序来决定什么时候停止一个进程的运行，这个强制的挂起动作则是<strong>抢占</strong>。抢占式多任务的基础就是使用<strong>时间片轮转</strong>机制来为每一个进程分配可以运行的时间单位。</p>
<p><strong>策略：</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;<strong>I/O消耗性和CPU消耗形。</strong>为了保证交互式桌面系统的性能，linux一般更倾向于优先调度I/O消耗形的进程。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;<strong>进程优先级。</strong>Linux采用两种不同的优先级范围。</p>
<p>&ensp;&ensp;&ensp;&ensp;（1）使用nice值：越大的nice值意味着更低的优先级。（-19~20之间）</p>
<p>&ensp;&ensp;&ensp;&ensp;（2）实时优先级：可以配置，越高表示进程的优先级越高。</p>
<h2 id="标准库函数和系统调用的区别"><a href="#标准库函数和系统调用的区别" class="headerlink" title="标准库函数和系统调用的区别"></a>标准库函数和系统调用的区别</h2><p>&ensp;&ensp;&ensp;&ensp;标准库函数，是语言本身的一部分，系统函数则是内核提供给应用层程序的一个接口，属于系统的一部分。函数库调用是语言或者应用程序的一部分，而系统调用则是操作系统的一部分。</p>
<p>&ensp;&ensp;&ensp;&ensp;系统调用通常用于<strong>底层文件访问（low-level file access）</strong>，例如在驱动程序中对设备文件的直接访问。</p>
<p>&ensp;&ensp;&ensp;&ensp;系统调用是操作系统相关的，因此一般没有跨操作系统的可移植性。</p>
<h2 id="如何查看进程打开的文件"><a href="#如何查看进程打开的文件" class="headerlink" title="如何查看进程打开的文件"></a>如何查看进程打开的文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、查看谁正在使用某个文件</span></span><br><span class="line">lsof /filepath/file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、通过某个进程号显示该进行打开的文件</span></span><br><span class="line">lsof -p 1</span><br></pre></td></tr></table></figure>
<h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">https://blog.csdn.net/zhangye3017/article/details/80382496</span><br></pre></td></tr></table></figure>


<h1 id="C语言基础"><a href="#C语言基础" class="headerlink" title="C语言基础"></a>C语言基础</h1><h2 id="memcpy比较两个结构体"><a href="#memcpy比较两个结构体" class="headerlink" title="memcpy比较两个结构体"></a>memcpy比较两个结构体</h2><p>不能。结构体struct 对象由于内存对齐会有内存间隙，就算其中的成员变量相等，内存直接比较还是不能相等。</p>
<p>1、结构体赋值之前可以初始化memset一下，然后可以用memcpy来进行对比，（如果有指针的话 不行）</p>
<p>2、可以使用运算符重载进行成员一一比较，看看变量是否相等。</p>
<p>每个<strong>特定平台</strong>上的编译器都有自己的默认“<strong>对齐系数</strong>”。可以通过预编译命令#pragma pack(n)</p>
<p>在经过对齐原则分析后，检查计算出的存储单元是否为所有元素中所占内存最大的元素的长度的整数倍，是，则结束；若不是，则补齐为它的整数倍。</p>
<h2 id="strcpy与memcpy的区别"><a href="#strcpy与memcpy的区别" class="headerlink" title="strcpy与memcpy的区别"></a>strcpy与memcpy的区别</h2><p>1、一个是字符串拷贝函数一个是内存拷贝函数</p>
<p>2、strcpy无需制定长度，遇到’\0’结束，无法复制0值</p>
<p>3、memcpy是内存拷贝函数，将制定长度的字节直接整个拷贝不进行内容检查。</p>
<p>4、strcpy是不安全字符串操作函数，如果参数dest所指定的内存空间不够大，那么久会出现缓冲区溢出问题，严重的话会导致程序崩溃。</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p><strong>Redis内存数据库的内存指的是共享内存么</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;Redis 是目前最火爆的内存数据库之一，通过在内存中读写数据，大大提高了读写速度，可以说 Redis 是实现网站高并发不可或缺的一部分，并不是指在一定只是在共享内存存取数据。</p>
<h2 id="redis持久化方式"><a href="#redis持久化方式" class="headerlink" title="redis持久化方式"></a>redis持久化方式</h2><p>Redis的持久化方式主要有两种RDB和AOF两种。<br>&ensp;&ensp;&ensp;&ensp;RDB持久化是在一定的时间间隔内生成内存数据集的时间点的一个快照。<br>&ensp;&ensp;&ensp;&ensp;AOF持久化则是记录服务器执行的所有写操作命令，并且在服务器启动的时候，通过执行这些命令来对数据进行还原。<br><strong>RDB的优点</strong><br>&ensp;&ensp;&ensp;&ensp;1、采用RDB方式持久化，整个redis数据库将会只包含一个文件，对于这个备份文件来说很完美的。一旦系统出现故障，我们可以很快的进行恢复。<br>&ensp;&ensp;&ensp;&ensp;2、对于灾难恢复，RDB是一个不错的选择，可以压缩成 其他格式进行存储。<br>&ensp;&ensp;&ensp;&ensp;3、能使性能最大化。在进行持久化之时候，只需要fork一个子进程进行持久化工作，这样服务进程就能极大的避免进行IO操作。<br>&ensp;&ensp;&ensp;&ensp;4、相对于AOF而言，如果数据库的数据集很大的话，RDB的启动效率会高一些。<br><strong>RDB的缺点</strong><br>主要有两点：<br>&ensp;&ensp;&ensp;&ensp;1、在持久化任务进行之前，如果系统出现宕机，那么此前还没有进行持久化写入磁盘的数据将会丢失，对于数据的高可用性、完整性要求比较高的场景这种持久化的方式将不会是一个很好的选择。<br>&ensp;&ensp;&ensp;&ensp;2、因为RDB是通过fork子进程来进行协助完成持久化，如果数据集特别大的话，可能这个时候服务器会停止服务几百毫秒甚至一秒。<br><strong>AOF的优点</strong><br>&ensp;&ensp;&ensp;&ensp;1、相比于RDB有更好的数据安全性和数据持久性。在redis中主要提供了三种同步策略，每秒同步，每修改同步，还有不同同步。<br>&ensp;&ensp;&ensp;&ensp;2、由于这个机制对日志文件的写入操作是以append追加的方式进行。所以即使系统宕机了也不会破坏日志文件中已经存在的内容。<br>&ensp;&ensp;&ensp;&ensp;3、AOF日志文件中包含了对数据库的所有修改操作，我们可以通过该日志文件完成数据的重建。<br><strong>AOF的缺点</strong><br>&ensp;&ensp;&ensp;&ensp;1、对于相同的数据集而言，AOF文件通常大于RDB文件，在进行数据恢复的时候速通常比RDB慢。<br>&ensp;&ensp;&ensp;&ensp;2、根据同步的策略，AOF在运行效率上往往会慢于RDB。</p>
<h2 id="持久化方式的选择"><a href="#持久化方式的选择" class="headerlink" title="持久化方式的选择"></a>持久化方式的选择</h2><p>&ensp;&ensp;&ensp;&ensp;1、对于数据一致性要求比较高的场景，建议使用使用AOF。<br>&ensp;&ensp;&ensp;&ensp;2、对于数据丢失的一部分没有那么看重的话，建议选择RDB。<br>&ensp;&ensp;&ensp;&ensp;3、如果对于数据的一致性、完整性特别重视，建议两种都开启。<br>&ensp;&ensp;&ensp;&ensp;4、AOF方式在不开启fsync的时候，性能和RDB相当。建议开启AOF方式的每秒钟同步一次。</p>
<h2 id="redis和mysql有什么区别，用于什么场景"><a href="#redis和mysql有什么区别，用于什么场景" class="headerlink" title="redis和mysql有什么区别，用于什么场景"></a>redis和mysql有什么区别，用于什么场景</h2><p>&ensp;&ensp;&ensp;&ensp;1、redis 基于内存，读写速度快，可以持久化但是内存空间有限，数据量超过内存空间时，需要进行扩充内存。<br>&ensp;&ensp;&ensp;&ensp;2、MySQL则是磁盘存储，读写相对于redis扫稍慢些，但是不受空间容量限制，性价比高。</p>
<p>&ensp;&ensp;&ensp;&ensp;在大多数的场景下都是MySQL+Redis配合使用，MySQL作为主存储库，Redis用作缓存可以加快访问速度。在需要高性能的地方使用Redis在不需要的高性能的地方使用MySQL。存储数据在MySQL和Redis之间做同步。</p>
<p>&ensp;&ensp;&ensp;&ensp;使用Redis缓存到MySQL。可以把表中经常访问的数据记录在Redis中，在需要查询数据的时候，先去Redis查询，如果查询不到再去MySQL中进行查找，这样可以实现读写分离。现在的软件大量的软件使用Redis作为MySQL在本地的缓存数据库，再适当的时候和MySQL同步。</p>
<h2 id="Redis缓存更新的模式以及出现的问题和应对思路"><a href="#Redis缓存更新的模式以及出现的问题和应对思路" class="headerlink" title="Redis缓存更新的模式以及出现的问题和应对思路"></a>Redis缓存更新的模式以及出现的问题和应对思路</h2><p>首先了解三个概念。<br>&ensp;&ensp;&ensp;&ensp;1、缓存雪崩<br>&ensp;&ensp;&ensp;&ensp;2、缓存穿透<br>&ensp;&ensp;&ensp;&ensp;3、缓存击穿<br><strong>缓存雪崩</strong><br>&ensp;&ensp;&ensp;&ensp;目前电商的首页以及热点的数据都会去做缓存，一般的缓存都是定时任务去更新或者说是查不到数据之后去数据库更新，在这里定时更新就会可能出现问题。缓存雪崩就是同一时间内大量的key值失效的瞬间或者同一瞬间大面积的请求数据库。这一瞬间，Redis缓存和没有一样，这个时候这个数量级别的请求直接打在数据库上几乎就是灾难性的。这就是缓存雪崩。</p>
<p>应对思路：在批量往Redis存储数据的时候，需要把每个key的失效时间都加个随机值就好了，这样可以保证同一时间大面积失效。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">setRedis(key, values, time+Math.random()*<span class="number">10000</span>)	</span><br></pre></td></tr></table></figure>
<p><strong>缓存穿透</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;缓存穿透，指的是缓存和数据库中都没有请求的数据，而且用户却不断发起请求，导致数据库压力大，严重时候会直接击垮数据库。</p>
<p>应对思路：接口层做参数校验，比如用户授权检验，参数做校验，对于不符合的数据直接return返回。对于Java来说，还有个高级的用法采用<em><strong>布隆过滤器（Bloom Filter）</strong></em>这个也可以很好的防止缓存穿透的发生，他的原理就是利用高效的数据结构和算法快速判断这个key在数据库中是否存在。</p>
<p><strong>缓存击穿</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;缓存击穿和和缓存雪崩有点类似，但是两者有点区别。雪崩是因为大面积缓存失效，打崩数据库。缓存击穿则是指的是一个key非常热点，在不停的扛着大并发，大并发集中对一个点进行访问，当这个key在失效的瞬间，持续的大并发就会击穿缓存，直接请求数据库，就像在一个完好无损的桶上开了一个洞。</p>
<p>应对思路：设置热点数据永不过期，或者加上互斥锁🔐就可以解决这个问题。</p>
<h2 id="Redis的hash是什么实现的"><a href="#Redis的hash是什么实现的" class="headerlink" title="Redis的hash是什么实现的"></a>Redis的hash是什么实现的</h2><p>&ensp;&ensp;&ensp;&ensp;Redis中的字典采用哈希表作为底层实现，一个哈希表多个节点，每个节点保存一个键值对。Redis数据库就是使用字典作为底层实现的，通过key和value的键值对形式，代表了数据库中的全部数据。而且对数据库的增删改查都是建立在对字典的操作上。</p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>1、100万数据个是topK。</p>
<p>2、32位无符号整形个数的QQ号记录QQ号的状态 上线和下线，计算使用多少内存。</p>
<p>3、printf(“%d “, 1, 2, 3);  printf(“%s”)；</p>
<p>4、HTTP 和 HTTPS的区别。1、对称加密和非对称加密。2、效率问题的瓶颈。</p>
<p>5、阻塞问题</p>
<p>1、对端接收处理不过来 。流量控制。</p>
<p>2、网络阻塞。拥塞控制。</p>
<p>3、项目问题</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://blog.csdn.net/xp731574722/article/details/82868560">https://blog.csdn.net/xp731574722/article/details/82868560</a></p>
<p>[2] <a href="https://blog.csdn.net/kozazyh/article/details/5495532">https://blog.csdn.net/kozazyh/article/details/5495532</a></p>
<p>[3] <a href="https://blog.csdn.net/zhangye3017/article/details/80382496">https://blog.csdn.net/zhangye3017/article/details/80382496</a></p>
]]></content>
      <categories>
        <category>面试宝典</category>
      </categories>
  </entry>
  <entry>
    <title>Google浏览器无法安装问题</title>
    <url>/2020/03/02/e3aa8e8f.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img src="/images/20210219125929354.jpg" alt="20210219125929354" style="zoom:50%;" />

<p>今天遇到一个有趣的问题，Google浏览器莫名其面的一直安装不上，自己捣鼓了好久最后才解决。网上有很多方法说是因为注册表有残留，准确的说是GoogleUpdate这个东西在作怪，解决的方法只需要将注册表里Google相关的东西删除。</p>
<a id="more"></a>

<h1 id="打开注册表直接Win-R输入regedit"><a href="#打开注册表直接Win-R输入regedit" class="headerlink" title="打开注册表直接Win+R输入regedit"></a>打开注册表直接Win+R输入regedit</h1><img src="/images/20210219130029354.jpg" alt="20210219130029354" style="zoom:80%;" />

<h1 id="删除注册表残留数据。"><a href="#删除注册表残留数据。" class="headerlink" title="删除注册表残留数据。"></a>删除注册表残留数据。</h1><p>删除\HKEY_CURRENT_USER\Software\和HKEY_LOCAL_MACHINE\SOFTWARE目录下的Google及对应的子目录就可以了。但是我操作的时候出现了问题，删除Google目录时候报错，后面发现是权限问题。解决方法：右键该目录修改管理员权限可以删除。</p>
<h1 id="确认电脑系统版本。"><a href="#确认电脑系统版本。" class="headerlink" title="确认电脑系统版本。"></a>确认电脑系统版本。</h1><p>可以删除之后还是发现无法安装，最后发现照着网上的帖子没有用，因为帖子估计都比较老，我的是win10系统，所以导致删除的路径不对，导致依旧无法正常安装，需要删除对应的路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">32位：HKEY_LOCAL_MACHINE\SOFTWARE\Google</span><br><span class="line">64位：HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Google</span><br></pre></td></tr></table></figure>
<h1 id="重启安装应用。"><a href="#重启安装应用。" class="headerlink" title="重启安装应用。"></a>重启安装应用。</h1><p>重新双击运行安装应用程序，完美解决！</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
  </entry>
  <entry>
    <title>釜山行</title>
    <url>/2020/02/25/3b09f244.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一开始听到影片讲丧尸的时候，我对这一步电影是拒绝的，谁知道朋友圈的伙伴们便对我进行一番嘲讽，不服气的我便是选择勇敢地看完。</p>
<a id="more"></a>

<p>从来不喜欢看恐怖片的我一直单纯的以为这只是一部恐怖片，但是默默地看到了最后，给我留下的不是恐怖，但最多的却是感动，是沉思。这部是一部直透人性最深处，其中包含了亲情、爱情、友情、自私、冷漠…… </p>
<p>政府，在我们的理解中是一个国家民众最基本的依靠，当一个政府里的高官被所谓的政治冲昏头脑的时候，政府就会变得自私自利。与此同时，政府也变回失去了他原本存在的意义。影片的一开始政府的举动让我很是不解，看到了最后，我才渐渐明白，剧中当灾难来临的时候，政府官员竟然掩盖真相，抛弃民众，不管民众的死活，并谎称这只是一场暴动，这一切的一切都值得我们思考。</p>
<p>爱情，有人说它是世界上最伟大的力量，而我想说，面对灾难来临时依旧坚不可摧的爱情才是最伟大的。剧中大叔与他的妻子圣京女士之间的爱情让许多人动容，面对另一节车厢中冷漠的人们的举动使他无法继续生存下去的时刻，毅然选择牺牲了自己保全了自己的爱人与那还未出生的女儿。还有就是年轻的棒球少女，自己生死的紧要关头却是从未舍弃自己喜欢的那个人，坚持要打开车门最后的最后虽然两人都被变成了尸人，但却是令我非常的感动。大叔和圣京女士代表了结婚的后依旧能够相守的一类人，而年轻棒球少女和年轻男子则是代表了正在青春萌动中了我们。</p>
<p>亲情，感情线路最为复杂的就是男主也就是秀安的爸爸，做为一个忙于工作的父亲。从一开始是忙于工作不抽出时间来陪伴女儿的形象，到接下来的呈现的是无私的父爱，同时也是自私的民众。父亲从为了保护自己的女儿不顾别人的死活，到最后被女儿的纯真善良所感动，开始去帮去身边的人。</p>
<p>自私，冷漠。在被尸人追赶逃跑的过程中不断有人把身边的人推向尸人以此来保全自己。但令我印象最为深刻的便是那最后一个车厢的人们，男主他们经历了重重尸人到达安全车厢的时候，那一整车厢的人竟然因害怕感染自己而拒绝开门从而导致大叔与奶奶被同化成了尸人，他们最后的目光我无法忘记，那是一种怎样的目光？是求生，或亦是对人性的绝望。<br>总的来说，这一步电影带给我的不是恐惧，最多的是来源于亲情，爱情以及纯真善良的感动，带给我的是自私冷漠的沉思，画面虽然夸张但是情感却是真实。</p>
<p>借用老刘的话说，那就是躲过了三姐车厢的丧尸，却是没有躲过一节车厢的人心。也想补充一句，无论如何请相信这世界依然有爱。<br>                                                                                                                                                                                                                    2016.9.17</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>电影🎬</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/02/17/4a17b156.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
</search>
